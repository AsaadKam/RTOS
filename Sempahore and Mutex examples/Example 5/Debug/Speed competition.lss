
Speed competition.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001c86  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000006a  00800060  00001c86  00001d1a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000667  008000ca  008000ca  00001d84  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001d84  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001db4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003e8  00000000  00000000  00001df0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005177  00000000  00000000  000021d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001337  00000000  00000000  0000734f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000031a7  00000000  00000000  00008686  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ba0  00000000  00000000  0000b830  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001901  00000000  00000000  0000c3d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005127  00000000  00000000  0000dcd1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000460  00000000  00000000  00012df8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 65 06 	jmp	0xcca	; 0xcca <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e8       	ldi	r30, 0x86	; 134
      68:	fc e1       	ldi	r31, 0x1C	; 28
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 3c       	cpi	r26, 0xCA	; 202
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	aa ec       	ldi	r26, 0xCA	; 202
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 33       	cpi	r26, 0x31	; 49
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 8d 02 	call	0x51a	; 0x51a <main>
      8a:	0c 94 41 0e 	jmp	0x1c82	; 0x1c82 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <System_Init>:
/***********************PROTOTYPE_IMPLEMENTATION*******************************/
void System_Init (void *Pv_Parameter)                        /**     No  Periodicity         -- Priority is 4**//**Execution time range micro    **/
{
    uinteg8_t gu8_LCD_Status=0;
	
	vTaskSuspend(Switches_Handler);
      92:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <Switches_Handler>
      96:	90 91 d5 00 	lds	r25, 0x00D5	; 0x8000d5 <Switches_Handler+0x1>
      9a:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <vTaskSuspend>
	vTaskSuspend(Lcd_Display_Count_Handler);
      9e:	80 91 d2 00 	lds	r24, 0x00D2	; 0x8000d2 <Lcd_Display_Count_Handler>
      a2:	90 91 d3 00 	lds	r25, 0x00D3	; 0x8000d3 <Lcd_Display_Count_Handler+0x1>
      a6:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <vTaskSuspend>
	vTaskSuspend(Lcd_Display_Congratulation_Handler);
      aa:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <Lcd_Display_Congratulation_Handler>
      ae:	90 91 d1 00 	lds	r25, 0x00D1	; 0x8000d1 <Lcd_Display_Congratulation_Handler+0x1>
      b2:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <vTaskSuspend>
		
	while(1)
	{
	    LCD_init();
      b6:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_init>
		Switch_init(switch0);
      ba:	60 e0       	ldi	r22, 0x00	; 0
      bc:	88 e0       	ldi	r24, 0x08	; 8
      be:	0e 94 9c 03 	call	0x738	; 0x738 <DIO_Init_Pin>
		Switch_init(switch1);	
      c2:	60 e0       	ldi	r22, 0x00	; 0
      c4:	89 e0       	ldi	r24, 0x09	; 9
      c6:	0e 94 9c 03 	call	0x738	; 0x738 <DIO_Init_Pin>
		vTaskResume(Switches_Handler);
      ca:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <Switches_Handler>
      ce:	90 91 d5 00 	lds	r25, 0x00D5	; 0x8000d5 <Switches_Handler+0x1>
      d2:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskResume>
		vTaskResume(Lcd_Display_Count_Handler);	
      d6:	80 91 d2 00 	lds	r24, 0x00D2	; 0x8000d2 <Lcd_Display_Count_Handler>
      da:	90 91 d3 00 	lds	r25, 0x00D3	; 0x8000d3 <Lcd_Display_Count_Handler+0x1>
      de:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskResume>
		vTaskSuspend(SYS_Handler);
      e2:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <SYS_Handler>
      e6:	90 91 d7 00 	lds	r25, 0x00D7	; 0x8000d7 <SYS_Handler+0x1>
      ea:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <vTaskSuspend>
      ee:	e3 cf       	rjmp	.-58     	; 0xb6 <System_Init+0x24>

000000f0 <Check_Switches>:
	}
}

void Check_Switches(void*Pv_Parameter)                      /** Periodicity 50 milisecond   -- Priority is 3**//**Execution time range micro    **/
{
      f0:	cf 93       	push	r28
      f2:	df 93       	push	r29
      f4:	00 d0       	rcall	.+0      	; 0xf6 <Check_Switches+0x6>
      f6:	1f 92       	push	r1
      f8:	cd b7       	in	r28, 0x3d	; 61
      fa:	de b7       	in	r29, 0x3e	; 62

	/*local variable for reading the value of switch now*/
	uinteg8_t u8_value_of_switch;

	uinteg8_t u8_switch_high_count;
	Switch0_Couting_Semaphore=xSemaphoreCreateCounting(3,0);
      fc:	60 e0       	ldi	r22, 0x00	; 0
      fe:	83 e0       	ldi	r24, 0x03	; 3
     100:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueCreateCountingSemaphore>
     104:	90 93 2e 07 	sts	0x072E, r25	; 0x80072e <Switch0_Couting_Semaphore+0x1>
     108:	80 93 2d 07 	sts	0x072D, r24	; 0x80072d <Switch0_Couting_Semaphore>
	Switch1_Couting_Semaphore=xSemaphoreCreateCounting(3,0);
     10c:	60 e0       	ldi	r22, 0x00	; 0
     10e:	83 e0       	ldi	r24, 0x03	; 3
     110:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueCreateCountingSemaphore>
     114:	90 93 2a 07 	sts	0x072A, r25	; 0x80072a <Switch1_Couting_Semaphore+0x1>
     118:	80 93 29 07 	sts	0x0729, r24	; 0x800729 <Switch1_Couting_Semaphore>
	while(1)
	{
		
		xLastWakeTime=xTaskGetTickCount();
     11c:	0e 94 2e 0b 	call	0x165c	; 0x165c <xTaskGetTickCount>
     120:	9a 83       	std	Y+2, r25	; 0x02
     122:	89 83       	std	Y+1, r24	; 0x01
		Debug_By_Toggle(22);
     124:	86 e1       	ldi	r24, 0x16	; 22
     126:	90 e0       	ldi	r25, 0x00	; 0
     128:	0e 94 d6 04 	call	0x9ac	; 0x9ac <Debug_By_Toggle>
		/*Read switch 0 */
		Read_Switch(switch0,&u8_value_of_switch);
     12c:	be 01       	movw	r22, r28
     12e:	6d 5f       	subi	r22, 0xFD	; 253
     130:	7f 4f       	sbci	r23, 0xFF	; 255
     132:	88 e0       	ldi	r24, 0x08	; 8
     134:	0e 94 32 04 	call	0x864	; 0x864 <DIO_Read_Pin>
		/*if it is high increment the global variable */

		if(u8_value_of_switch==HIGH)
     138:	8b 81       	ldd	r24, Y+3	; 0x03
     13a:	81 30       	cpi	r24, 0x01	; 1
     13c:	99 f4       	brne	.+38     	; 0x164 <Check_Switches+0x74>
		{

			if(uxSemaphoreGetCount(Switch0_Couting_Semaphore)<3)
     13e:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <Switch0_Couting_Semaphore>
     142:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <Switch0_Couting_Semaphore+0x1>
     146:	0e 94 fe 08 	call	0x11fc	; 0x11fc <uxQueueMessagesWaiting>
     14a:	83 30       	cpi	r24, 0x03	; 3
     14c:	58 f4       	brcc	.+22     	; 0x164 <Check_Switches+0x74>
			{
				/*Increment counting semaphore*/
				xSemaphoreGive(Switch0_Couting_Semaphore);
     14e:	20 e0       	ldi	r18, 0x00	; 0
     150:	40 e0       	ldi	r20, 0x00	; 0
     152:	50 e0       	ldi	r21, 0x00	; 0
     154:	60 e0       	ldi	r22, 0x00	; 0
     156:	70 e0       	ldi	r23, 0x00	; 0
     158:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <Switch0_Couting_Semaphore>
     15c:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <Switch0_Couting_Semaphore+0x1>
     160:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xQueueGenericSend>
		else
		{
			/*Do nothing*/
		}
		/*Read switch 1*/
		Read_Switch(switch1,&u8_value_of_switch);
     164:	be 01       	movw	r22, r28
     166:	6d 5f       	subi	r22, 0xFD	; 253
     168:	7f 4f       	sbci	r23, 0xFF	; 255
     16a:	89 e0       	ldi	r24, 0x09	; 9
     16c:	0e 94 32 04 	call	0x864	; 0x864 <DIO_Read_Pin>
		/*if it is high increment the global variable */
		if(u8_value_of_switch==HIGH)
     170:	8b 81       	ldd	r24, Y+3	; 0x03
     172:	81 30       	cpi	r24, 0x01	; 1
     174:	99 f4       	brne	.+38     	; 0x19c <Check_Switches+0xac>
		{
			if(uxSemaphoreGetCount(Switch1_Couting_Semaphore)<3)
     176:	80 91 29 07 	lds	r24, 0x0729	; 0x800729 <Switch1_Couting_Semaphore>
     17a:	90 91 2a 07 	lds	r25, 0x072A	; 0x80072a <Switch1_Couting_Semaphore+0x1>
     17e:	0e 94 fe 08 	call	0x11fc	; 0x11fc <uxQueueMessagesWaiting>
     182:	83 30       	cpi	r24, 0x03	; 3
     184:	58 f4       	brcc	.+22     	; 0x19c <Check_Switches+0xac>
			{
				/*Increment counting semaphore*/
				xSemaphoreGive(Switch1_Couting_Semaphore);
     186:	20 e0       	ldi	r18, 0x00	; 0
     188:	40 e0       	ldi	r20, 0x00	; 0
     18a:	50 e0       	ldi	r21, 0x00	; 0
     18c:	60 e0       	ldi	r22, 0x00	; 0
     18e:	70 e0       	ldi	r23, 0x00	; 0
     190:	80 91 29 07 	lds	r24, 0x0729	; 0x800729 <Switch1_Couting_Semaphore>
     194:	90 91 2a 07 	lds	r25, 0x072A	; 0x80072a <Switch1_Couting_Semaphore+0x1>
     198:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xQueueGenericSend>
		}
		else
		{
			/*Do nothing*/
		}
		Debug_By_Toggle(22);
     19c:	86 e1       	ldi	r24, 0x16	; 22
     19e:	90 e0       	ldi	r25, 0x00	; 0
     1a0:	0e 94 d6 04 	call	0x9ac	; 0x9ac <Debug_By_Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
     1a4:	62 e3       	ldi	r22, 0x32	; 50
     1a6:	70 e0       	ldi	r23, 0x00	; 0
     1a8:	ce 01       	movw	r24, r28
     1aa:	01 96       	adiw	r24, 0x01	; 1
     1ac:	0e 94 4f 0c 	call	0x189e	; 0x189e <vTaskDelayUntil>
	}
     1b0:	b5 cf       	rjmp	.-150    	; 0x11c <Check_Switches+0x2c>

000001b2 <Lcd_Display_Count>:
}

void Lcd_Display_Count(void *Pv_Parameter)                   /** Periodicity 150 milisecond  -- Priority is 2**//**Execution time range micro    **/
{
     1b2:	cf 93       	push	r28
     1b4:	df 93       	push	r29
     1b6:	00 d0       	rcall	.+0      	; 0x1b8 <Lcd_Display_Count+0x6>
     1b8:	cd b7       	in	r28, 0x3d	; 61
     1ba:	de b7       	in	r29, 0x3e	; 62
			   }
	           ss8_player2_count++;
           }
           /*Here is the problem*/
		   	su8_Latched_State_Of_Switch0=LOW;
		   	su8_Latched_State_Of_Switch1=HIGH;
     1bc:	ff 24       	eor	r15, r15
     1be:	f3 94       	inc	r15
	static uinteg8_t su8_Latched_State_Of_Switch1=LOW;
	uinteg8_t u8_index_array=0;
	
	while(1)
	{
		xLastWakeTime=xTaskGetTickCount();
     1c0:	0e 94 2e 0b 	call	0x165c	; 0x165c <xTaskGetTickCount>
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
		Debug_By_Toggle(23);
     1c8:	87 e1       	ldi	r24, 0x17	; 23
     1ca:	90 e0       	ldi	r25, 0x00	; 0
     1cc:	0e 94 d6 04 	call	0x9ac	; 0x9ac <Debug_By_Toggle>
		
		u8_Switch0_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch0_Couting_Semaphore);
     1d0:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <Switch0_Couting_Semaphore>
     1d4:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <Switch0_Couting_Semaphore+0x1>
     1d8:	0e 94 fe 08 	call	0x11fc	; 0x11fc <uxQueueMessagesWaiting>
     1dc:	18 2f       	mov	r17, r24
		u8_Switch1_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch1_Couting_Semaphore);
     1de:	80 91 29 07 	lds	r24, 0x0729	; 0x800729 <Switch1_Couting_Semaphore>
     1e2:	90 91 2a 07 	lds	r25, 0x072A	; 0x80072a <Switch1_Couting_Semaphore+0x1>
     1e6:	0e 94 fe 08 	call	0x11fc	; 0x11fc <uxQueueMessagesWaiting>
     1ea:	08 2f       	mov	r16, r24
		
		while(uxSemaphoreGetCount(Switch0_Couting_Semaphore)!=0)
     1ec:	08 c0       	rjmp	.+16     	; 0x1fe <Lcd_Display_Count+0x4c>
		{
			xSemaphoreTake(Switch0_Couting_Semaphore,0);
     1ee:	60 e0       	ldi	r22, 0x00	; 0
     1f0:	70 e0       	ldi	r23, 0x00	; 0
     1f2:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <Switch0_Couting_Semaphore>
     1f6:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <Switch0_Couting_Semaphore+0x1>
     1fa:	0e 94 74 08 	call	0x10e8	; 0x10e8 <xQueueSemaphoreTake>
		Debug_By_Toggle(23);
		
		u8_Switch0_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch0_Couting_Semaphore);
		u8_Switch1_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch1_Couting_Semaphore);
		
		while(uxSemaphoreGetCount(Switch0_Couting_Semaphore)!=0)
     1fe:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <Switch0_Couting_Semaphore>
     202:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <Switch0_Couting_Semaphore+0x1>
     206:	0e 94 fe 08 	call	0x11fc	; 0x11fc <uxQueueMessagesWaiting>
     20a:	81 11       	cpse	r24, r1
     20c:	f0 cf       	rjmp	.-32     	; 0x1ee <Lcd_Display_Count+0x3c>
     20e:	08 c0       	rjmp	.+16     	; 0x220 <Lcd_Display_Count+0x6e>
		{
			xSemaphoreTake(Switch0_Couting_Semaphore,0);
		}
		while(uxSemaphoreGetCount(Switch1_Couting_Semaphore)!=0)
		{
			xSemaphoreTake(Switch1_Couting_Semaphore,0);
     210:	60 e0       	ldi	r22, 0x00	; 0
     212:	70 e0       	ldi	r23, 0x00	; 0
     214:	80 91 29 07 	lds	r24, 0x0729	; 0x800729 <Switch1_Couting_Semaphore>
     218:	90 91 2a 07 	lds	r25, 0x072A	; 0x80072a <Switch1_Couting_Semaphore+0x1>
     21c:	0e 94 74 08 	call	0x10e8	; 0x10e8 <xQueueSemaphoreTake>
		
		while(uxSemaphoreGetCount(Switch0_Couting_Semaphore)!=0)
		{
			xSemaphoreTake(Switch0_Couting_Semaphore,0);
		}
		while(uxSemaphoreGetCount(Switch1_Couting_Semaphore)!=0)
     220:	80 91 29 07 	lds	r24, 0x0729	; 0x800729 <Switch1_Couting_Semaphore>
     224:	90 91 2a 07 	lds	r25, 0x072A	; 0x80072a <Switch1_Couting_Semaphore+0x1>
     228:	0e 94 fe 08 	call	0x11fc	; 0x11fc <uxQueueMessagesWaiting>
     22c:	81 11       	cpse	r24, r1
     22e:	f0 cf       	rjmp	.-32     	; 0x210 <Lcd_Display_Count+0x5e>
		{
			xSemaphoreTake(Switch1_Couting_Semaphore,0);
		}
		
		if((u8_Switch0_Sempahore_Count_Buffer>=2)&&(u8_Switch1_Sempahore_Count_Buffer>=2))
     230:	12 30       	cpi	r17, 0x02	; 2
     232:	08 f4       	brcc	.+2      	; 0x236 <Lcd_Display_Count+0x84>
     234:	4e c0       	rjmp	.+156    	; 0x2d2 <Lcd_Display_Count+0x120>
     236:	02 30       	cpi	r16, 0x02	; 2
     238:	b8 f1       	brcs	.+110    	; 0x2a8 <Lcd_Display_Count+0xf6>
		{
           if((su8_Latched_State_Of_Switch0==LOW)&&(su8_Latched_State_Of_Switch1==LOW))
     23a:	80 91 cf 00 	lds	r24, 0x00CF	; 0x8000cf <su8_Latched_State_Of_Switch0.2136>
     23e:	81 11       	cpse	r24, r1
     240:	11 c1       	rjmp	.+546    	; 0x464 <__LOCK_REGION_LENGTH__+0x64>
     242:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <su8_Latched_State_Of_Switch1.2137>
     246:	81 11       	cpse	r24, r1
     248:	1c c0       	rjmp	.+56     	; 0x282 <Lcd_Display_Count+0xd0>
		   {
			   ss8_player1_count++;
     24a:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <ss8_player1_count.2134>
     24e:	8f 5f       	subi	r24, 0xFF	; 255
     250:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <ss8_player1_count.2134>
			   ss8_player2_count++;	
     254:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <ss8_player2_count.2135>
     258:	8f 5f       	subi	r24, 0xFF	; 255
     25a:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <ss8_player2_count.2135>
     25e:	1f c0       	rjmp	.+62     	; 0x29e <Lcd_Display_Count+0xec>

		   }
           else if((su8_Latched_State_Of_Switch0==HIGH)&&(su8_Latched_State_Of_Switch1==LOW))
     260:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <su8_Latched_State_Of_Switch1.2137>
     264:	81 11       	cpse	r24, r1
     266:	1b c0       	rjmp	.+54     	; 0x29e <Lcd_Display_Count+0xec>
           {
			   if(ss8_player1_count>0)
     268:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <ss8_player1_count.2134>
     26c:	18 16       	cp	r1, r24
     26e:	1c f4       	brge	.+6      	; 0x276 <Lcd_Display_Count+0xc4>
			   {
		           ss8_player1_count--;				   
     270:	81 50       	subi	r24, 0x01	; 1
     272:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <ss8_player1_count.2134>
			   }
	           ss8_player2_count++;
     276:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <ss8_player2_count.2135>
     27a:	8f 5f       	subi	r24, 0xFF	; 255
     27c:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <ss8_player2_count.2135>
     280:	0e c0       	rjmp	.+28     	; 0x29e <Lcd_Display_Count+0xec>
           }
           else if((su8_Latched_State_Of_Switch0==LOW)&&(su8_Latched_State_Of_Switch1==HIGH))
     282:	81 30       	cpi	r24, 0x01	; 1
     284:	61 f4       	brne	.+24     	; 0x29e <Lcd_Display_Count+0xec>
           {
	           ss8_player1_count++;
     286:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <ss8_player1_count.2134>
     28a:	8f 5f       	subi	r24, 0xFF	; 255
     28c:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <ss8_player1_count.2134>
			   if(ss8_player2_count>0)
     290:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <ss8_player2_count.2135>
     294:	18 16       	cp	r1, r24
     296:	1c f4       	brge	.+6      	; 0x29e <Lcd_Display_Count+0xec>
			   {
				   ss8_player2_count--;
     298:	81 50       	subi	r24, 0x01	; 1
     29a:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <ss8_player2_count.2135>
			   }
           }		
		   su8_Latched_State_Of_Switch0=HIGH;
     29e:	f0 92 cf 00 	sts	0x00CF, r15	; 0x8000cf <su8_Latched_State_Of_Switch0.2136>
		   su8_Latched_State_Of_Switch1=HIGH;   		   
     2a2:	f0 92 ce 00 	sts	0x00CE, r15	; 0x8000ce <su8_Latched_State_Of_Switch1.2137>
     2a6:	30 c0       	rjmp	.+96     	; 0x308 <Lcd_Display_Count+0x156>
		}
		else if((u8_Switch0_Sempahore_Count_Buffer>=2)&&(!(u8_Switch1_Sempahore_Count_Buffer>=2)))
		{
           if((su8_Latched_State_Of_Switch0==LOW))
     2a8:	80 91 cf 00 	lds	r24, 0x00CF	; 0x8000cf <su8_Latched_State_Of_Switch0.2136>
     2ac:	81 11       	cpse	r24, r1
     2ae:	0c c0       	rjmp	.+24     	; 0x2c8 <Lcd_Display_Count+0x116>
           {
	           ss8_player1_count++;
     2b0:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <ss8_player1_count.2134>
     2b4:	8f 5f       	subi	r24, 0xFF	; 255
     2b6:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <ss8_player1_count.2134>
			   if(ss8_player2_count>0)
     2ba:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <ss8_player2_count.2135>
     2be:	18 16       	cp	r1, r24
     2c0:	1c f4       	brge	.+6      	; 0x2c8 <Lcd_Display_Count+0x116>
			   {
				   ss8_player2_count--;
     2c2:	81 50       	subi	r24, 0x01	; 1
     2c4:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <ss8_player2_count.2135>
			   }
           }
			su8_Latched_State_Of_Switch0=HIGH;
     2c8:	f0 92 cf 00 	sts	0x00CF, r15	; 0x8000cf <su8_Latched_State_Of_Switch0.2136>
			su8_Latched_State_Of_Switch1=LOW;
     2cc:	10 92 ce 00 	sts	0x00CE, r1	; 0x8000ce <su8_Latched_State_Of_Switch1.2137>
     2d0:	1b c0       	rjmp	.+54     	; 0x308 <Lcd_Display_Count+0x156>
		}
		else if((!(u8_Switch0_Sempahore_Count_Buffer>=2))&&(u8_Switch1_Sempahore_Count_Buffer>=2))
     2d2:	02 30       	cpi	r16, 0x02	; 2
     2d4:	a8 f0       	brcs	.+42     	; 0x300 <Lcd_Display_Count+0x14e>
		{
           if((su8_Latched_State_Of_Switch1==LOW))
     2d6:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <su8_Latched_State_Of_Switch1.2137>
     2da:	81 11       	cpse	r24, r1
     2dc:	0c c0       	rjmp	.+24     	; 0x2f6 <Lcd_Display_Count+0x144>
           {
			   if(ss8_player1_count>0)
     2de:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <ss8_player1_count.2134>
     2e2:	18 16       	cp	r1, r24
     2e4:	1c f4       	brge	.+6      	; 0x2ec <Lcd_Display_Count+0x13a>
			   {
				   ss8_player1_count--;
     2e6:	81 50       	subi	r24, 0x01	; 1
     2e8:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <ss8_player1_count.2134>
			   }
	           ss8_player2_count++;
     2ec:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <ss8_player2_count.2135>
     2f0:	8f 5f       	subi	r24, 0xFF	; 255
     2f2:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <ss8_player2_count.2135>
           }
           /*Here is the problem*/
		   	su8_Latched_State_Of_Switch0=LOW;
     2f6:	10 92 cf 00 	sts	0x00CF, r1	; 0x8000cf <su8_Latched_State_Of_Switch0.2136>
		   	su8_Latched_State_Of_Switch1=HIGH;
     2fa:	f0 92 ce 00 	sts	0x00CE, r15	; 0x8000ce <su8_Latched_State_Of_Switch1.2137>
     2fe:	04 c0       	rjmp	.+8      	; 0x308 <Lcd_Display_Count+0x156>
		}
		else if((!(u8_Switch0_Sempahore_Count_Buffer>=2))&&(!(u8_Switch1_Sempahore_Count_Buffer>=2)))
		{
	        su8_Latched_State_Of_Switch0=LOW;		
     300:	10 92 cf 00 	sts	0x00CF, r1	; 0x8000cf <su8_Latched_State_Of_Switch0.2136>
	        su8_Latched_State_Of_Switch1=LOW;			   	
     304:	10 92 ce 00 	sts	0x00CE, r1	; 0x8000ce <su8_Latched_State_Of_Switch1.2137>
		}

		
		LCD_displayStringRowColumn(1,1,"Player1=");
     308:	40 e9       	ldi	r20, 0x90	; 144
     30a:	50 e0       	ldi	r21, 0x00	; 0
     30c:	61 e0       	ldi	r22, 0x01	; 1
     30e:	70 e0       	ldi	r23, 0x00	; 0
     310:	81 e0       	ldi	r24, 0x01	; 1
     312:	90 e0       	ldi	r25, 0x00	; 0
     314:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <LCD_displayStringRowColumn>
		LCD_integerToString(ss8_player1_count,1,9);
     318:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <ss8_player1_count.2134>
     31c:	49 e0       	ldi	r20, 0x09	; 9
     31e:	50 e0       	ldi	r21, 0x00	; 0
     320:	61 e0       	ldi	r22, 0x01	; 1
     322:	70 e0       	ldi	r23, 0x00	; 0
     324:	08 2e       	mov	r0, r24
     326:	00 0c       	add	r0, r0
     328:	99 0b       	sbc	r25, r25
     32a:	0e 94 75 03 	call	0x6ea	; 0x6ea <LCD_integerToString>
		LCD_displayString(" ");
     32e:	82 ec       	ldi	r24, 0xC2	; 194
     330:	90 e0       	ldi	r25, 0x00	; 0
     332:	0e 94 42 03 	call	0x684	; 0x684 <LCD_displayString>
		LCD_displayStringRowColumn(2,1,"Player2=");		
     336:	49 e9       	ldi	r20, 0x99	; 153
     338:	50 e0       	ldi	r21, 0x00	; 0
     33a:	61 e0       	ldi	r22, 0x01	; 1
     33c:	70 e0       	ldi	r23, 0x00	; 0
     33e:	82 e0       	ldi	r24, 0x02	; 2
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <LCD_displayStringRowColumn>
		LCD_integerToString(ss8_player2_count,2,9);
     346:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <ss8_player2_count.2135>
     34a:	49 e0       	ldi	r20, 0x09	; 9
     34c:	50 e0       	ldi	r21, 0x00	; 0
     34e:	62 e0       	ldi	r22, 0x02	; 2
     350:	70 e0       	ldi	r23, 0x00	; 0
     352:	08 2e       	mov	r0, r24
     354:	00 0c       	add	r0, r0
     356:	99 0b       	sbc	r25, r25
     358:	0e 94 75 03 	call	0x6ea	; 0x6ea <LCD_integerToString>
		LCD_displayString(" ");		
     35c:	82 ec       	ldi	r24, 0xC2	; 194
     35e:	90 e0       	ldi	r25, 0x00	; 0
     360:	0e 94 42 03 	call	0x684	; 0x684 <LCD_displayString>
		
		if((ss8_player1_count==50)&&(ss8_player2_count==50))
     364:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <ss8_player1_count.2134>
     368:	82 33       	cpi	r24, 0x32	; 50
     36a:	09 f0       	breq	.+2      	; 0x36e <Lcd_Display_Count+0x1bc>
     36c:	7f c0       	rjmp	.+254    	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
     36e:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <ss8_player2_count.2135>
     372:	82 33       	cpi	r24, 0x32	; 50
     374:	09 f0       	breq	.+2      	; 0x378 <Lcd_Display_Count+0x1c6>
     376:	47 c0       	rjmp	.+142    	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
		{
			/*Display string of we are equal*/
			ss8_player1_count=0;
     378:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <ss8_player1_count.2134>
			ss8_player2_count=0;
     37c:	10 92 cc 00 	sts	0x00CC, r1	; 0x8000cc <ss8_player2_count.2135>
			LCD_clearScreen();
     380:	0e 94 58 03 	call	0x6b0	; 0x6b0 <LCD_clearScreen>
            LCD_displayStringRowColumn(1,1,Equal_players_Array);
     384:	40 e6       	ldi	r20, 0x60	; 96
     386:	50 e0       	ldi	r21, 0x00	; 0
     388:	61 e0       	ldi	r22, 0x01	; 1
     38a:	70 e0       	ldi	r23, 0x00	; 0
     38c:	81 e0       	ldi	r24, 0x01	; 1
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <LCD_displayStringRowColumn>
			vTaskResume(Lcd_Display_Congratulation_Handler);	
     394:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <Lcd_Display_Congratulation_Handler>
     398:	90 91 d1 00 	lds	r25, 0x00D1	; 0x8000d1 <Lcd_Display_Congratulation_Handler+0x1>
     39c:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskResume>
			vTaskSuspend(Switches_Handler);
     3a0:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <Switches_Handler>
     3a4:	90 91 d5 00 	lds	r25, 0x00D5	; 0x8000d5 <Switches_Handler+0x1>
     3a8:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <vTaskSuspend>
			vTaskSuspend(Lcd_Display_Count_Handler);
     3ac:	80 91 d2 00 	lds	r24, 0x00D2	; 0x8000d2 <Lcd_Display_Count_Handler>
     3b0:	90 91 d3 00 	lds	r25, 0x00D3	; 0x8000d3 <Lcd_Display_Count_Handler+0x1>
     3b4:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <vTaskSuspend>
		LCD_displayStringRowColumn(2,1,"Player2=");		
		LCD_integerToString(ss8_player2_count,2,9);
		LCD_displayString(" ");		
		
		if((ss8_player1_count==50)&&(ss8_player2_count==50))
		{
     3b8:	4a c0       	rjmp	.+148    	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
            LCD_displayStringRowColumn(1,1,Equal_players_Array);
			vTaskResume(Lcd_Display_Congratulation_Handler);	
			vTaskSuspend(Switches_Handler);
			vTaskSuspend(Lcd_Display_Count_Handler);
		}
		else if((ss8_player1_count<50)&&(ss8_player2_count==50))
     3ba:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <ss8_player2_count.2135>
     3be:	82 33       	cpi	r24, 0x32	; 50
     3c0:	09 f0       	breq	.+2      	; 0x3c4 <Lcd_Display_Count+0x212>
     3c2:	45 c0       	rjmp	.+138    	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
		{
			ss8_player1_count=0;
     3c4:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <ss8_player1_count.2134>
			ss8_player2_count=0;
     3c8:	10 92 cc 00 	sts	0x00CC, r1	; 0x8000cc <ss8_player2_count.2135>
			LCD_clearScreen();			
     3cc:	0e 94 58 03 	call	0x6b0	; 0x6b0 <LCD_clearScreen>
            LCD_displayStringRowColumn(1,1,Congratulation_player2_Array);
     3d0:	40 e7       	ldi	r20, 0x70	; 112
     3d2:	50 e0       	ldi	r21, 0x00	; 0
     3d4:	61 e0       	ldi	r22, 0x01	; 1
     3d6:	70 e0       	ldi	r23, 0x00	; 0
     3d8:	81 e0       	ldi	r24, 0x01	; 1
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <LCD_displayStringRowColumn>
			vTaskResume(Lcd_Display_Congratulation_Handler);
     3e0:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <Lcd_Display_Congratulation_Handler>
     3e4:	90 91 d1 00 	lds	r25, 0x00D1	; 0x8000d1 <Lcd_Display_Congratulation_Handler+0x1>
     3e8:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskResume>
			vTaskSuspend(Switches_Handler);
     3ec:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <Switches_Handler>
     3f0:	90 91 d5 00 	lds	r25, 0x00D5	; 0x8000d5 <Switches_Handler+0x1>
     3f4:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <vTaskSuspend>
			vTaskSuspend(Lcd_Display_Count_Handler);
     3f8:	80 91 d2 00 	lds	r24, 0x00D2	; 0x8000d2 <Lcd_Display_Count_Handler>
     3fc:	90 91 d3 00 	lds	r25, 0x00D3	; 0x8000d3 <Lcd_Display_Count_Handler+0x1>
     400:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <vTaskSuspend>
			vTaskResume(Lcd_Display_Congratulation_Handler);	
			vTaskSuspend(Switches_Handler);
			vTaskSuspend(Lcd_Display_Count_Handler);
		}
		else if((ss8_player1_count<50)&&(ss8_player2_count==50))
		{
     404:	24 c0       	rjmp	.+72     	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
            LCD_displayStringRowColumn(1,1,Congratulation_player2_Array);
			vTaskResume(Lcd_Display_Congratulation_Handler);
			vTaskSuspend(Switches_Handler);
			vTaskSuspend(Lcd_Display_Count_Handler);
		}
		else if((ss8_player1_count==50)&&(ss8_player2_count<50))
     406:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <ss8_player2_count.2135>
     40a:	82 33       	cpi	r24, 0x32	; 50
     40c:	04 f5       	brge	.+64     	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
		{
			ss8_player1_count=0;
     40e:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <ss8_player1_count.2134>
			ss8_player2_count=0;
     412:	10 92 cc 00 	sts	0x00CC, r1	; 0x8000cc <ss8_player2_count.2135>
			LCD_clearScreen();			
     416:	0e 94 58 03 	call	0x6b0	; 0x6b0 <LCD_clearScreen>
            LCD_displayStringRowColumn(1,1,Congratulation_player1_Array);
     41a:	40 e8       	ldi	r20, 0x80	; 128
     41c:	50 e0       	ldi	r21, 0x00	; 0
     41e:	61 e0       	ldi	r22, 0x01	; 1
     420:	70 e0       	ldi	r23, 0x00	; 0
     422:	81 e0       	ldi	r24, 0x01	; 1
     424:	90 e0       	ldi	r25, 0x00	; 0
     426:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <LCD_displayStringRowColumn>
			vTaskResume(Lcd_Display_Congratulation_Handler);
     42a:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <Lcd_Display_Congratulation_Handler>
     42e:	90 91 d1 00 	lds	r25, 0x00D1	; 0x8000d1 <Lcd_Display_Congratulation_Handler+0x1>
     432:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskResume>
			vTaskSuspend(Switches_Handler);
     436:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <Switches_Handler>
     43a:	90 91 d5 00 	lds	r25, 0x00D5	; 0x8000d5 <Switches_Handler+0x1>
     43e:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <vTaskSuspend>
			vTaskSuspend(Lcd_Display_Count_Handler);		
     442:	80 91 d2 00 	lds	r24, 0x00D2	; 0x8000d2 <Lcd_Display_Count_Handler>
     446:	90 91 d3 00 	lds	r25, 0x00D3	; 0x8000d3 <Lcd_Display_Count_Handler+0x1>
     44a:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <vTaskSuspend>
		else
		{
			/*Do nothing*/
		}		
    
		Debug_By_Toggle(23);
     44e:	87 e1       	ldi	r24, 0x17	; 23
     450:	90 e0       	ldi	r25, 0x00	; 0
     452:	0e 94 d6 04 	call	0x9ac	; 0x9ac <Debug_By_Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
     456:	66 e9       	ldi	r22, 0x96	; 150
     458:	70 e0       	ldi	r23, 0x00	; 0
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	0e 94 4f 0c 	call	0x189e	; 0x189e <vTaskDelayUntil>
	}
     462:	ae ce       	rjmp	.-676    	; 0x1c0 <Lcd_Display_Count+0xe>
		   {
			   ss8_player1_count++;
			   ss8_player2_count++;	

		   }
           else if((su8_Latched_State_Of_Switch0==HIGH)&&(su8_Latched_State_Of_Switch1==LOW))
     464:	81 30       	cpi	r24, 0x01	; 1
     466:	09 f0       	breq	.+2      	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
     468:	1a cf       	rjmp	.-460    	; 0x29e <Lcd_Display_Count+0xec>
     46a:	fa ce       	rjmp	.-524    	; 0x260 <Lcd_Display_Count+0xae>
            LCD_displayStringRowColumn(1,1,Equal_players_Array);
			vTaskResume(Lcd_Display_Congratulation_Handler);	
			vTaskSuspend(Switches_Handler);
			vTaskSuspend(Lcd_Display_Count_Handler);
		}
		else if((ss8_player1_count<50)&&(ss8_player2_count==50))
     46c:	82 33       	cpi	r24, 0x32	; 50
     46e:	0c f4       	brge	.+2      	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
     470:	a4 cf       	rjmp	.-184    	; 0x3ba <Lcd_Display_Count+0x208>
     472:	ed cf       	rjmp	.-38     	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>

00000474 <Lcd_Display_Congratulation>:
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
	}
}

void Lcd_Display_Congratulation(void *Pv_Paramaeter)         /** Periodicity 200 milisecond  -- Priority is 1**//**Execution time 104 milisecond **/
{
     474:	cf 93       	push	r28
     476:	df 93       	push	r29
     478:	00 d0       	rcall	.+0      	; 0x47a <Lcd_Display_Congratulation+0x6>
     47a:	cd b7       	in	r28, 0x3d	; 61
     47c:	de b7       	in	r29, 0x3e	; 62
			{
				case Display_Congratulation :
				{

					LCD_displayStringRowColumn(2,1," Congratulation!!");					
					su8_Cogratulation_state=Clear_Display;
     47e:	11 e0       	ldi	r17, 0x01	; 1
	static uinteg8_t su8_Lcd_Display_Congratulation_Count=0;
    
	while(1)
	{
		
		xLastWakeTime=xTaskGetTickCount();		
     480:	0e 94 2e 0b 	call	0x165c	; 0x165c <xTaskGetTickCount>
     484:	9a 83       	std	Y+2, r25	; 0x02
     486:	89 83       	std	Y+1, r24	; 0x01
		Debug_By_Toggle(24);    
     488:	88 e1       	ldi	r24, 0x18	; 24
     48a:	90 e0       	ldi	r25, 0x00	; 0
     48c:	0e 94 d6 04 	call	0x9ac	; 0x9ac <Debug_By_Toggle>

        su8_Lcd_Display_Congratulation_Count++;		
     490:	80 91 cb 00 	lds	r24, 0x00CB	; 0x8000cb <su8_Lcd_Display_Congratulation_Count.2163>
     494:	8f 5f       	subi	r24, 0xFF	; 255
     496:	80 93 cb 00 	sts	0x00CB, r24	; 0x8000cb <su8_Lcd_Display_Congratulation_Count.2163>

		if(su8_Lcd_Display_Congratulation_Count<25)	
     49a:	89 31       	cpi	r24, 0x19	; 25
     49c:	e8 f4       	brcc	.+58     	; 0x4d8 <Lcd_Display_Congratulation+0x64>
		{	
			switch(su8_Cogratulation_state)
     49e:	80 91 ca 00 	lds	r24, 0x00CA	; 0x8000ca <__data_end>
     4a2:	88 23       	and	r24, r24
     4a4:	19 f0       	breq	.+6      	; 0x4ac <Lcd_Display_Congratulation+0x38>
     4a6:	81 30       	cpi	r24, 0x01	; 1
     4a8:	61 f0       	breq	.+24     	; 0x4c2 <Lcd_Display_Congratulation+0x4e>
     4aa:	2c c0       	rjmp	.+88     	; 0x504 <Lcd_Display_Congratulation+0x90>
			{
				case Display_Congratulation :
				{

					LCD_displayStringRowColumn(2,1," Congratulation!!");					
     4ac:	42 ea       	ldi	r20, 0xA2	; 162
     4ae:	50 e0       	ldi	r21, 0x00	; 0
     4b0:	61 e0       	ldi	r22, 0x01	; 1
     4b2:	70 e0       	ldi	r23, 0x00	; 0
     4b4:	82 e0       	ldi	r24, 0x02	; 2
     4b6:	90 e0       	ldi	r25, 0x00	; 0
     4b8:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <LCD_displayStringRowColumn>
					su8_Cogratulation_state=Clear_Display;
     4bc:	10 93 ca 00 	sts	0x00CA, r17	; 0x8000ca <__data_end>
				}
				break;
     4c0:	21 c0       	rjmp	.+66     	; 0x504 <Lcd_Display_Congratulation+0x90>
				case Clear_Display:
				{
					LCD_displayStringRowColumn(2,1,"               ");
     4c2:	44 eb       	ldi	r20, 0xB4	; 180
     4c4:	50 e0       	ldi	r21, 0x00	; 0
     4c6:	61 e0       	ldi	r22, 0x01	; 1
     4c8:	70 e0       	ldi	r23, 0x00	; 0
     4ca:	82 e0       	ldi	r24, 0x02	; 2
     4cc:	90 e0       	ldi	r25, 0x00	; 0
     4ce:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <LCD_displayStringRowColumn>
					su8_Cogratulation_state=Display_Congratulation;				
     4d2:	10 92 ca 00 	sts	0x00CA, r1	; 0x8000ca <__data_end>
				}
				break;			
     4d6:	16 c0       	rjmp	.+44     	; 0x504 <Lcd_Display_Congratulation+0x90>
			}
		}
		else
		{
			LCD_clearScreen();				
     4d8:	0e 94 58 03 	call	0x6b0	; 0x6b0 <LCD_clearScreen>
			su8_Lcd_Display_Congratulation_Count=0;
     4dc:	10 92 cb 00 	sts	0x00CB, r1	; 0x8000cb <su8_Lcd_Display_Congratulation_Count.2163>
			vTaskResume(Switches_Handler);	
     4e0:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <Switches_Handler>
     4e4:	90 91 d5 00 	lds	r25, 0x00D5	; 0x8000d5 <Switches_Handler+0x1>
     4e8:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskResume>
			vTaskResume(Lcd_Display_Count_Handler);			
     4ec:	80 91 d2 00 	lds	r24, 0x00D2	; 0x8000d2 <Lcd_Display_Count_Handler>
     4f0:	90 91 d3 00 	lds	r25, 0x00D3	; 0x8000d3 <Lcd_Display_Count_Handler+0x1>
     4f4:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskResume>
			vTaskSuspend(Lcd_Display_Congratulation_Handler);
     4f8:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <Lcd_Display_Congratulation_Handler>
     4fc:	90 91 d1 00 	lds	r25, 0x00D1	; 0x8000d1 <Lcd_Display_Congratulation_Handler+0x1>
     500:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <vTaskSuspend>
		}
		Debug_By_Toggle(24);
     504:	88 e1       	ldi	r24, 0x18	; 24
     506:	90 e0       	ldi	r25, 0x00	; 0
     508:	0e 94 d6 04 	call	0x9ac	; 0x9ac <Debug_By_Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );			
     50c:	68 ec       	ldi	r22, 0xC8	; 200
     50e:	70 e0       	ldi	r23, 0x00	; 0
     510:	ce 01       	movw	r24, r28
     512:	01 96       	adiw	r24, 0x01	; 1
     514:	0e 94 4f 0c 	call	0x189e	; 0x189e <vTaskDelayUntil>
	}
     518:	b3 cf       	rjmp	.-154    	; 0x480 <Lcd_Display_Congratulation+0xc>

0000051a <main>:
}

int main(void)
{
     51a:	ef 92       	push	r14
     51c:	ff 92       	push	r15
     51e:	0f 93       	push	r16
    /**Create the task of System_Init where it uses 100 word from stack and has priority 4*/
    xTaskCreate(System_Init,NULL,100,NULL,4,&SYS_Handler);		
     520:	0f 2e       	mov	r0, r31
     522:	f6 ed       	ldi	r31, 0xD6	; 214
     524:	ef 2e       	mov	r14, r31
     526:	f0 e0       	ldi	r31, 0x00	; 0
     528:	ff 2e       	mov	r15, r31
     52a:	f0 2d       	mov	r31, r0
     52c:	04 e0       	ldi	r16, 0x04	; 4
     52e:	20 e0       	ldi	r18, 0x00	; 0
     530:	30 e0       	ldi	r19, 0x00	; 0
     532:	44 e6       	ldi	r20, 0x64	; 100
     534:	50 e0       	ldi	r21, 0x00	; 0
     536:	60 e0       	ldi	r22, 0x00	; 0
     538:	70 e0       	ldi	r23, 0x00	; 0
     53a:	89 e4       	ldi	r24, 0x49	; 73
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	0e 94 ab 09 	call	0x1356	; 0x1356 <xTaskCreate>
    /**Create the task of Check_Switches where it uses 100 word from stack and has priority 3*/
    xTaskCreate(Check_Switches,NULL,100,NULL,3,&Switches_Handler);	
     542:	0f 2e       	mov	r0, r31
     544:	f4 ed       	ldi	r31, 0xD4	; 212
     546:	ef 2e       	mov	r14, r31
     548:	f0 e0       	ldi	r31, 0x00	; 0
     54a:	ff 2e       	mov	r15, r31
     54c:	f0 2d       	mov	r31, r0
     54e:	03 e0       	ldi	r16, 0x03	; 3
     550:	20 e0       	ldi	r18, 0x00	; 0
     552:	30 e0       	ldi	r19, 0x00	; 0
     554:	44 e6       	ldi	r20, 0x64	; 100
     556:	50 e0       	ldi	r21, 0x00	; 0
     558:	60 e0       	ldi	r22, 0x00	; 0
     55a:	70 e0       	ldi	r23, 0x00	; 0
     55c:	88 e7       	ldi	r24, 0x78	; 120
     55e:	90 e0       	ldi	r25, 0x00	; 0
     560:	0e 94 ab 09 	call	0x1356	; 0x1356 <xTaskCreate>
    /**Create the task of Lcd_Display_Count where it uses 100 word from stack and has priority 2*/
    xTaskCreate(Lcd_Display_Count,NULL,100,NULL,2,&Lcd_Display_Count_Handler);	
     564:	0f 2e       	mov	r0, r31
     566:	f2 ed       	ldi	r31, 0xD2	; 210
     568:	ef 2e       	mov	r14, r31
     56a:	f0 e0       	ldi	r31, 0x00	; 0
     56c:	ff 2e       	mov	r15, r31
     56e:	f0 2d       	mov	r31, r0
     570:	02 e0       	ldi	r16, 0x02	; 2
     572:	20 e0       	ldi	r18, 0x00	; 0
     574:	30 e0       	ldi	r19, 0x00	; 0
     576:	44 e6       	ldi	r20, 0x64	; 100
     578:	50 e0       	ldi	r21, 0x00	; 0
     57a:	60 e0       	ldi	r22, 0x00	; 0
     57c:	70 e0       	ldi	r23, 0x00	; 0
     57e:	89 ed       	ldi	r24, 0xD9	; 217
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	0e 94 ab 09 	call	0x1356	; 0x1356 <xTaskCreate>
	/*Create the task of Lcd_Display_Congratulation where it uses 100 word from stack and has priority 1*/
	xTaskCreate(Lcd_Display_Congratulation,NULL,100,NULL,1,&Lcd_Display_Congratulation_Handler);
     586:	0f 2e       	mov	r0, r31
     588:	f0 ed       	ldi	r31, 0xD0	; 208
     58a:	ef 2e       	mov	r14, r31
     58c:	f0 e0       	ldi	r31, 0x00	; 0
     58e:	ff 2e       	mov	r15, r31
     590:	f0 2d       	mov	r31, r0
     592:	01 e0       	ldi	r16, 0x01	; 1
     594:	20 e0       	ldi	r18, 0x00	; 0
     596:	30 e0       	ldi	r19, 0x00	; 0
     598:	44 e6       	ldi	r20, 0x64	; 100
     59a:	50 e0       	ldi	r21, 0x00	; 0
     59c:	60 e0       	ldi	r22, 0x00	; 0
     59e:	70 e0       	ldi	r23, 0x00	; 0
     5a0:	8a e3       	ldi	r24, 0x3A	; 58
     5a2:	92 e0       	ldi	r25, 0x02	; 2
     5a4:	0e 94 ab 09 	call	0x1356	; 0x1356 <xTaskCreate>

	/*Os start  */
	vTaskStartScheduler();
     5a8:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <vTaskStartScheduler>
}
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	90 e0       	ldi	r25, 0x00	; 0
     5b0:	0f 91       	pop	r16
     5b2:	ff 90       	pop	r15
     5b4:	ef 90       	pop	r14
     5b6:	08 95       	ret

000005b8 <LCD_sendCommand>:
		

}

ERROR_TYPE_t LCD_sendCommand(uinteg8_t u8_command)
{
     5b8:	cf 93       	push	r28
     5ba:	c8 2f       	mov	r28, r24
	uinteg8_t au8_error;

		CLR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
     5bc:	d9 98       	cbi	0x1b, 1	; 27
		CLR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
     5be:	da 98       	cbi	0x1b, 2	; 27
/*		Debug_By_Toggle(22);	*/	
		SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
     5c0:	db 9a       	sbi	0x1b, 3	; 27
        vTaskDelay(2);
     5c2:	82 e0       	ldi	r24, 0x02	; 2
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	0e 94 8d 0c 	call	0x191a	; 0x191a <vTaskDelay>
/*		Debug_By_Toggle(22);*/
#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
		LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (u8_command & 0xF0);
     5ca:	8b b3       	in	r24, 0x1b	; 27
     5cc:	8f 70       	andi	r24, 0x0F	; 15
     5ce:	9c 2f       	mov	r25, r28
     5d0:	90 7f       	andi	r25, 0xF0	; 240
     5d2:	89 2b       	or	r24, r25
     5d4:	8b bb       	out	0x1b, r24	; 27
#endif
#elif (DATA_BITS_MODE == 8)
		LCD_DATA_PORT = u8_command; /* out the required command to the data bus D0 --> D7 */
#endif
/*		Debug_By_Toggle(22);	*/	
		CLR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
     5d6:	db 98       	cbi	0x1b, 3	; 27
	    vTaskDelay(2);
     5d8:	82 e0       	ldi	r24, 0x02	; 2
     5da:	90 e0       	ldi	r25, 0x00	; 0
     5dc:	0e 94 8d 0c 	call	0x191a	; 0x191a <vTaskDelay>
/*		Debug_By_Toggle(22);*/		
		SET_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
     5e0:	db 9a       	sbi	0x1b, 3	; 27
        vTaskDelay(2);
     5e2:	82 e0       	ldi	r24, 0x02	; 2
     5e4:	90 e0       	ldi	r25, 0x00	; 0
     5e6:	0e 94 8d 0c 	call	0x191a	; 0x191a <vTaskDelay>
/*		Debug_By_Toggle(22);*/		
#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
		LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((u8_command & 0x0F) << 4);
     5ea:	8b b3       	in	r24, 0x1b	; 27
     5ec:	28 2f       	mov	r18, r24
     5ee:	2f 70       	andi	r18, 0x0F	; 15
     5f0:	30 e1       	ldi	r19, 0x10	; 16
     5f2:	c3 9f       	mul	r28, r19
     5f4:	c0 01       	movw	r24, r0
     5f6:	11 24       	eor	r1, r1
     5f8:	82 2b       	or	r24, r18
     5fa:	8b bb       	out	0x1b, r24	; 27
#else
		LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (u8_command & 0x0F);
#endif
#endif
/*		Debug_By_Toggle(22);	*/	
		CLR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
     5fc:	db 98       	cbi	0x1b, 3	; 27
        vTaskDelay(2);
     5fe:	82 e0       	ldi	r24, 0x02	; 2
     600:	90 e0       	ldi	r25, 0x00	; 0
     602:	0e 94 8d 0c 	call	0x191a	; 0x191a <vTaskDelay>
/*		Debug_By_Toggle(22);*/
}
     606:	cf 91       	pop	r28
     608:	08 95       	ret

0000060a <LCD_init>:
static uinteg8_t gu8_display_row_col=NULL;
ERROR_TYPE_t LCD_init(void)
{
	uinteg8_t au8_error=8;

		LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW);
     60a:	8a b3       	in	r24, 0x1a	; 26
     60c:	8e 60       	ori	r24, 0x0E	; 14
     60e:	8a bb       	out	0x1a, r24	; 26
#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
		LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
     610:	8a b3       	in	r24, 0x1a	; 26
     612:	80 6f       	ori	r24, 0xF0	; 240
     614:	8a bb       	out	0x1a, r24	; 26
		LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
     616:	82 e0       	ldi	r24, 0x02	; 2
     618:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
		LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
		LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

		LCD_sendCommand(0x28); /* cursor off */
     61c:	88 e2       	ldi	r24, 0x28	; 40
     61e:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <LCD_sendCommand>

		LCD_sendCommand(CURSOR_OFF);
     622:	8c e0       	ldi	r24, 0x0C	; 12
     624:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <LCD_sendCommand>
		LCD_sendCommand(0x01);
     628:	81 e0       	ldi	r24, 0x01	; 1
     62a:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <LCD_sendCommand>
		
		

}
     62e:	08 95       	ret

00000630 <LCD_displayCharacter>:
        vTaskDelay(2);
/*		Debug_By_Toggle(22);*/
}

ERROR_TYPE_t LCD_displayCharacter(uinteg8_t u8_data)
{
     630:	cf 93       	push	r28
     632:	c8 2f       	mov	r28, r24
	uinteg8_t au8_error=NULL;

			SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
     634:	d9 9a       	sbi	0x1b, 1	; 27
			CLR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
     636:	da 98       	cbi	0x1b, 2	; 27
			SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
     638:	db 9a       	sbi	0x1b, 3	; 27
			vTaskDelay(1/portTICK_PERIOD_MS);
     63a:	81 e0       	ldi	r24, 0x01	; 1
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	0e 94 8d 0c 	call	0x191a	; 0x191a <vTaskDelay>
			#if (DATA_BITS_MODE == 4) /* out the highest 4 bits of the required data to the data bus D4 --> D7 */
			#ifdef UPPER_PORT_PINS
			LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (u8_data & 0xF0);
     642:	8b b3       	in	r24, 0x1b	; 27
     644:	8f 70       	andi	r24, 0x0F	; 15
     646:	9c 2f       	mov	r25, r28
     648:	90 7f       	andi	r25, 0xF0	; 240
     64a:	89 2b       	or	r24, r25
     64c:	8b bb       	out	0x1b, r24	; 27
			LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((u8_data & 0xF0) >> 4);
			#endif
			#elif (DATA_BITS_MODE == 8)
			LCD_DATA_PORT = u8_data; /* out the required command to the data bus D0 --> D7 */
			#endif	
			CLR_BIT(LCD_CTRL_PORT,E); /* DISABLE LCD E=1 */
     64e:	db 98       	cbi	0x1b, 3	; 27
			vTaskDelay(1/portTICK_PERIOD_MS);
     650:	81 e0       	ldi	r24, 0x01	; 1
     652:	90 e0       	ldi	r25, 0x00	; 0
     654:	0e 94 8d 0c 	call	0x191a	; 0x191a <vTaskDelay>
			SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
     658:	db 9a       	sbi	0x1b, 3	; 27
			vTaskDelay(1/portTICK_PERIOD_MS);		
     65a:	81 e0       	ldi	r24, 0x01	; 1
     65c:	90 e0       	ldi	r25, 0x00	; 0
     65e:	0e 94 8d 0c 	call	0x191a	; 0x191a <vTaskDelay>
			#ifdef UPPER_PORT_PINS
			LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((u8_data & 0x0F) << 4);
     662:	8b b3       	in	r24, 0x1b	; 27
     664:	28 2f       	mov	r18, r24
     666:	2f 70       	andi	r18, 0x0F	; 15
     668:	30 e1       	ldi	r19, 0x10	; 16
     66a:	c3 9f       	mul	r28, r19
     66c:	c0 01       	movw	r24, r0
     66e:	11 24       	eor	r1, r1
     670:	82 2b       	or	r24, r18
     672:	8b bb       	out	0x1b, r24	; 27
			#else
			LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (u8_data & 0x0F);
			#endif
			CLR_BIT(LCD_CTRL_PORT,E); /* DISABLE LCD E=1 */
     674:	db 98       	cbi	0x1b, 3	; 27
			vTaskDelay(1/portTICK_PERIOD_MS);			
     676:	81 e0       	ldi	r24, 0x01	; 1
     678:	90 e0       	ldi	r25, 0x00	; 0
     67a:	0e 94 8d 0c 	call	0x191a	; 0x191a <vTaskDelay>


	return au8_error;
}
     67e:	80 e0       	ldi	r24, 0x00	; 0
     680:	cf 91       	pop	r28
     682:	08 95       	ret

00000684 <LCD_displayString>:

ERROR_TYPE_t LCD_displayString(const uinteg8_t * ptr_String)
{
     684:	0f 93       	push	r16
     686:	1f 93       	push	r17
     688:	cf 93       	push	r28
     68a:	fc 01       	movw	r30, r24
  uinteg8_t u8_string_index=0;
  while(ptr_String[u8_string_index])
     68c:	80 81       	ld	r24, Z
     68e:	88 23       	and	r24, r24
     690:	59 f0       	breq	.+22     	; 0x6a8 <LCD_displayString+0x24>
     692:	8f 01       	movw	r16, r30
     694:	c0 e0       	ldi	r28, 0x00	; 0
  {

	  LCD_displayCharacter(ptr_String[u8_string_index]);
     696:	0e 94 18 03 	call	0x630	; 0x630 <LCD_displayCharacter>
	  u8_string_index++;
     69a:	cf 5f       	subi	r28, 0xFF	; 255
}

ERROR_TYPE_t LCD_displayString(const uinteg8_t * ptr_String)
{
  uinteg8_t u8_string_index=0;
  while(ptr_String[u8_string_index])
     69c:	f8 01       	movw	r30, r16
     69e:	ec 0f       	add	r30, r28
     6a0:	f1 1d       	adc	r31, r1
     6a2:	80 81       	ld	r24, Z
     6a4:	81 11       	cpse	r24, r1
     6a6:	f7 cf       	rjmp	.-18     	; 0x696 <LCD_displayString+0x12>
  {

	  LCD_displayCharacter(ptr_String[u8_string_index]);
	  u8_string_index++;
  }
}
     6a8:	cf 91       	pop	r28
     6aa:	1f 91       	pop	r17
     6ac:	0f 91       	pop	r16
     6ae:	08 95       	ret

000006b0 <LCD_clearScreen>:

void LCD_clearScreen(void)
{
	LCD_sendCommand(CLEAR_COMMAND); //clear display
     6b0:	81 e0       	ldi	r24, 0x01	; 1
     6b2:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <LCD_sendCommand>
     6b6:	08 95       	ret

000006b8 <LCD_goToRowColumn>:
}

void LCD_goToRowColumn(uinteg8_t row, uinteg8_t col)
{
	uinteg8_t address;
	switch(row)
     6b8:	81 30       	cpi	r24, 0x01	; 1
     6ba:	19 f0       	breq	.+6      	; 0x6c2 <LCD_goToRowColumn+0xa>
     6bc:	82 30       	cpi	r24, 0x02	; 2
     6be:	21 f0       	breq	.+8      	; 0x6c8 <LCD_goToRowColumn+0x10>
     6c0:	05 c0       	rjmp	.+10     	; 0x6cc <LCD_goToRowColumn+0x14>
	{
		case 1:
			address = 0x80 + col-1;
     6c2:	9f e7       	ldi	r25, 0x7F	; 127
     6c4:	96 0f       	add	r25, r22
			//OR LCD_sendCommand(0x80).
			break;
     6c6:	02 c0       	rjmp	.+4      	; 0x6cc <LCD_goToRowColumn+0x14>
		case 2:
			address = 0xC0 + col-1;
     6c8:	9f eb       	ldi	r25, 0xBF	; 191
     6ca:	96 0f       	add	r25, r22
		default:
			break;
			//Nothing.
	}

    LCD_sendCommand(address | 0b100000000);
     6cc:	89 2f       	mov	r24, r25
     6ce:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <LCD_sendCommand>
     6d2:	08 95       	ret

000006d4 <LCD_displayStringRowColumn>:

}

void LCD_displayStringRowColumn(uinteg8_t row,uinteg8_t col,const uinteg8_t *Str)
{
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	ea 01       	movw	r28, r20
	
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
     6da:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <LCD_goToRowColumn>
	LCD_displayString(Str);
     6de:	ce 01       	movw	r24, r28
     6e0:	0e 94 42 03 	call	0x684	; 0x684 <LCD_displayString>

}
     6e4:	df 91       	pop	r29
     6e6:	cf 91       	pop	r28
     6e8:	08 95       	ret

000006ea <LCD_integerToString>:
void LCD_integerToString(uinteg32_t value,uinteg8_t row,uinteg8_t col)
{
     6ea:	0f 93       	push	r16
     6ec:	1f 93       	push	r17
     6ee:	cf 93       	push	r28
     6f0:	df 93       	push	r29
     6f2:	cd b7       	in	r28, 0x3d	; 61
     6f4:	de b7       	in	r29, 0x3e	; 62
     6f6:	a8 97       	sbiw	r28, 0x28	; 40
     6f8:	0f b6       	in	r0, 0x3f	; 63
     6fa:	f8 94       	cli
     6fc:	de bf       	out	0x3e, r29	; 62
     6fe:	0f be       	out	0x3f, r0	; 63
     700:	cd bf       	out	0x3d, r28	; 61
     702:	16 2f       	mov	r17, r22
     704:	04 2f       	mov	r16, r20
	static uinteg8_t u8_LCD_integerToString_FLAG=1;
	uinteg32_t buffer[20];
	itoa(value, buffer , 10);
     706:	4a e0       	ldi	r20, 0x0A	; 10
     708:	50 e0       	ldi	r21, 0x00	; 0
     70a:	be 01       	movw	r22, r28
     70c:	6f 5f       	subi	r22, 0xFF	; 255
     70e:	7f 4f       	sbci	r23, 0xFF	; 255
     710:	0e 94 01 0e 	call	0x1c02	; 0x1c02 <itoa>
	LCD_displayStringRowColumn(row,col,buffer);
     714:	ae 01       	movw	r20, r28
     716:	4f 5f       	subi	r20, 0xFF	; 255
     718:	5f 4f       	sbci	r21, 0xFF	; 255
     71a:	60 2f       	mov	r22, r16
     71c:	81 2f       	mov	r24, r17
     71e:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <LCD_displayStringRowColumn>

     722:	a8 96       	adiw	r28, 0x28	; 40
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	de bf       	out	0x3e, r29	; 62
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	df 91       	pop	r29
     730:	cf 91       	pop	r28
     732:	1f 91       	pop	r17
     734:	0f 91       	pop	r16
     736:	08 95       	ret

00000738 <DIO_Init_Pin>:
		default :
		return DIO_ERROR_NOK;
		break;
		}
return DIO_ERROR_OK;
}
     738:	80 32       	cpi	r24, 0x20	; 32
     73a:	08 f0       	brcs	.+2      	; 0x73e <DIO_Init_Pin+0x6>
     73c:	8f c0       	rjmp	.+286    	; 0x85c <DIO_Init_Pin+0x124>
     73e:	98 2f       	mov	r25, r24
     740:	97 70       	andi	r25, 0x07	; 7
     742:	86 95       	lsr	r24
     744:	86 95       	lsr	r24
     746:	86 95       	lsr	r24
     748:	8f 5b       	subi	r24, 0xBF	; 191
     74a:	82 34       	cpi	r24, 0x42	; 66
     74c:	51 f1       	breq	.+84     	; 0x7a2 <DIO_Init_Pin+0x6a>
     74e:	18 f4       	brcc	.+6      	; 0x756 <DIO_Init_Pin+0x1e>
     750:	81 34       	cpi	r24, 0x41	; 65
     752:	41 f0       	breq	.+16     	; 0x764 <DIO_Init_Pin+0x2c>
     754:	85 c0       	rjmp	.+266    	; 0x860 <__stack+0x1>
     756:	83 34       	cpi	r24, 0x43	; 67
     758:	09 f4       	brne	.+2      	; 0x75c <DIO_Init_Pin+0x24>
     75a:	42 c0       	rjmp	.+132    	; 0x7e0 <DIO_Init_Pin+0xa8>
     75c:	84 34       	cpi	r24, 0x44	; 68
     75e:	09 f4       	brne	.+2      	; 0x762 <DIO_Init_Pin+0x2a>
     760:	5e c0       	rjmp	.+188    	; 0x81e <DIO_Init_Pin+0xe6>
     762:	7e c0       	rjmp	.+252    	; 0x860 <__stack+0x1>
     764:	61 11       	cpse	r22, r1
     766:	0f c0       	rjmp	.+30     	; 0x786 <DIO_Init_Pin+0x4e>
     768:	4a b3       	in	r20, 0x1a	; 26
     76a:	21 e0       	ldi	r18, 0x01	; 1
     76c:	30 e0       	ldi	r19, 0x00	; 0
     76e:	b9 01       	movw	r22, r18
     770:	02 c0       	rjmp	.+4      	; 0x776 <DIO_Init_Pin+0x3e>
     772:	66 0f       	add	r22, r22
     774:	77 1f       	adc	r23, r23
     776:	9a 95       	dec	r25
     778:	e2 f7       	brpl	.-8      	; 0x772 <DIO_Init_Pin+0x3a>
     77a:	cb 01       	movw	r24, r22
     77c:	80 95       	com	r24
     77e:	84 23       	and	r24, r20
     780:	8a bb       	out	0x1a, r24	; 26
     782:	80 e0       	ldi	r24, 0x00	; 0
     784:	08 95       	ret
     786:	4a b3       	in	r20, 0x1a	; 26
     788:	21 e0       	ldi	r18, 0x01	; 1
     78a:	30 e0       	ldi	r19, 0x00	; 0
     78c:	b9 01       	movw	r22, r18
     78e:	02 c0       	rjmp	.+4      	; 0x794 <DIO_Init_Pin+0x5c>
     790:	66 0f       	add	r22, r22
     792:	77 1f       	adc	r23, r23
     794:	9a 95       	dec	r25
     796:	e2 f7       	brpl	.-8      	; 0x790 <DIO_Init_Pin+0x58>
     798:	cb 01       	movw	r24, r22
     79a:	84 2b       	or	r24, r20
     79c:	8a bb       	out	0x1a, r24	; 26
     79e:	80 e0       	ldi	r24, 0x00	; 0
     7a0:	08 95       	ret
     7a2:	61 11       	cpse	r22, r1
     7a4:	0f c0       	rjmp	.+30     	; 0x7c4 <DIO_Init_Pin+0x8c>
     7a6:	47 b3       	in	r20, 0x17	; 23
     7a8:	21 e0       	ldi	r18, 0x01	; 1
     7aa:	30 e0       	ldi	r19, 0x00	; 0
     7ac:	b9 01       	movw	r22, r18
     7ae:	02 c0       	rjmp	.+4      	; 0x7b4 <DIO_Init_Pin+0x7c>
     7b0:	66 0f       	add	r22, r22
     7b2:	77 1f       	adc	r23, r23
     7b4:	9a 95       	dec	r25
     7b6:	e2 f7       	brpl	.-8      	; 0x7b0 <DIO_Init_Pin+0x78>
     7b8:	cb 01       	movw	r24, r22
     7ba:	80 95       	com	r24
     7bc:	84 23       	and	r24, r20
     7be:	87 bb       	out	0x17, r24	; 23
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	08 95       	ret
     7c4:	47 b3       	in	r20, 0x17	; 23
     7c6:	21 e0       	ldi	r18, 0x01	; 1
     7c8:	30 e0       	ldi	r19, 0x00	; 0
     7ca:	b9 01       	movw	r22, r18
     7cc:	02 c0       	rjmp	.+4      	; 0x7d2 <DIO_Init_Pin+0x9a>
     7ce:	66 0f       	add	r22, r22
     7d0:	77 1f       	adc	r23, r23
     7d2:	9a 95       	dec	r25
     7d4:	e2 f7       	brpl	.-8      	; 0x7ce <DIO_Init_Pin+0x96>
     7d6:	cb 01       	movw	r24, r22
     7d8:	84 2b       	or	r24, r20
     7da:	87 bb       	out	0x17, r24	; 23
     7dc:	80 e0       	ldi	r24, 0x00	; 0
     7de:	08 95       	ret
     7e0:	61 11       	cpse	r22, r1
     7e2:	0f c0       	rjmp	.+30     	; 0x802 <DIO_Init_Pin+0xca>
     7e4:	44 b3       	in	r20, 0x14	; 20
     7e6:	21 e0       	ldi	r18, 0x01	; 1
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	b9 01       	movw	r22, r18
     7ec:	02 c0       	rjmp	.+4      	; 0x7f2 <DIO_Init_Pin+0xba>
     7ee:	66 0f       	add	r22, r22
     7f0:	77 1f       	adc	r23, r23
     7f2:	9a 95       	dec	r25
     7f4:	e2 f7       	brpl	.-8      	; 0x7ee <DIO_Init_Pin+0xb6>
     7f6:	cb 01       	movw	r24, r22
     7f8:	80 95       	com	r24
     7fa:	84 23       	and	r24, r20
     7fc:	84 bb       	out	0x14, r24	; 20
     7fe:	80 e0       	ldi	r24, 0x00	; 0
     800:	08 95       	ret
     802:	44 b3       	in	r20, 0x14	; 20
     804:	21 e0       	ldi	r18, 0x01	; 1
     806:	30 e0       	ldi	r19, 0x00	; 0
     808:	b9 01       	movw	r22, r18
     80a:	02 c0       	rjmp	.+4      	; 0x810 <DIO_Init_Pin+0xd8>
     80c:	66 0f       	add	r22, r22
     80e:	77 1f       	adc	r23, r23
     810:	9a 95       	dec	r25
     812:	e2 f7       	brpl	.-8      	; 0x80c <DIO_Init_Pin+0xd4>
     814:	cb 01       	movw	r24, r22
     816:	84 2b       	or	r24, r20
     818:	84 bb       	out	0x14, r24	; 20
     81a:	80 e0       	ldi	r24, 0x00	; 0
     81c:	08 95       	ret
     81e:	61 11       	cpse	r22, r1
     820:	0f c0       	rjmp	.+30     	; 0x840 <DIO_Init_Pin+0x108>
     822:	41 b3       	in	r20, 0x11	; 17
     824:	21 e0       	ldi	r18, 0x01	; 1
     826:	30 e0       	ldi	r19, 0x00	; 0
     828:	b9 01       	movw	r22, r18
     82a:	02 c0       	rjmp	.+4      	; 0x830 <DIO_Init_Pin+0xf8>
     82c:	66 0f       	add	r22, r22
     82e:	77 1f       	adc	r23, r23
     830:	9a 95       	dec	r25
     832:	e2 f7       	brpl	.-8      	; 0x82c <DIO_Init_Pin+0xf4>
     834:	cb 01       	movw	r24, r22
     836:	80 95       	com	r24
     838:	84 23       	and	r24, r20
     83a:	81 bb       	out	0x11, r24	; 17
     83c:	80 e0       	ldi	r24, 0x00	; 0
     83e:	08 95       	ret
     840:	41 b3       	in	r20, 0x11	; 17
     842:	21 e0       	ldi	r18, 0x01	; 1
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	b9 01       	movw	r22, r18
     848:	02 c0       	rjmp	.+4      	; 0x84e <DIO_Init_Pin+0x116>
     84a:	66 0f       	add	r22, r22
     84c:	77 1f       	adc	r23, r23
     84e:	9a 95       	dec	r25
     850:	e2 f7       	brpl	.-8      	; 0x84a <DIO_Init_Pin+0x112>
     852:	cb 01       	movw	r24, r22
     854:	84 2b       	or	r24, r20
     856:	81 bb       	out	0x11, r24	; 17
     858:	80 e0       	ldi	r24, 0x00	; 0
     85a:	08 95       	ret
     85c:	81 e0       	ldi	r24, 0x01	; 1
     85e:	08 95       	ret
     860:	81 e0       	ldi	r24, 0x01	; 1
     862:	08 95       	ret

00000864 <DIO_Read_Pin>:
     864:	80 32       	cpi	r24, 0x20	; 32
     866:	08 f0       	brcs	.+2      	; 0x86a <DIO_Read_Pin+0x6>
     868:	4d c0       	rjmp	.+154    	; 0x904 <DIO_Read_Pin+0xa0>
     86a:	98 2f       	mov	r25, r24
     86c:	97 70       	andi	r25, 0x07	; 7
     86e:	86 95       	lsr	r24
     870:	86 95       	lsr	r24
     872:	86 95       	lsr	r24
     874:	8f 5b       	subi	r24, 0xBF	; 191
     876:	82 34       	cpi	r24, 0x42	; 66
     878:	c1 f0       	breq	.+48     	; 0x8aa <DIO_Read_Pin+0x46>
     87a:	18 f4       	brcc	.+6      	; 0x882 <DIO_Read_Pin+0x1e>
     87c:	81 34       	cpi	r24, 0x41	; 65
     87e:	31 f0       	breq	.+12     	; 0x88c <DIO_Read_Pin+0x28>
     880:	43 c0       	rjmp	.+134    	; 0x908 <DIO_Read_Pin+0xa4>
     882:	83 34       	cpi	r24, 0x43	; 67
     884:	09 f1       	breq	.+66     	; 0x8c8 <DIO_Read_Pin+0x64>
     886:	84 34       	cpi	r24, 0x44	; 68
     888:	71 f1       	breq	.+92     	; 0x8e6 <DIO_Read_Pin+0x82>
     88a:	3e c0       	rjmp	.+124    	; 0x908 <DIO_Read_Pin+0xa4>
     88c:	89 b3       	in	r24, 0x19	; 25
     88e:	28 2f       	mov	r18, r24
     890:	30 e0       	ldi	r19, 0x00	; 0
     892:	a9 01       	movw	r20, r18
     894:	02 c0       	rjmp	.+4      	; 0x89a <DIO_Read_Pin+0x36>
     896:	55 95       	asr	r21
     898:	47 95       	ror	r20
     89a:	9a 95       	dec	r25
     89c:	e2 f7       	brpl	.-8      	; 0x896 <DIO_Read_Pin+0x32>
     89e:	ca 01       	movw	r24, r20
     8a0:	81 70       	andi	r24, 0x01	; 1
     8a2:	fb 01       	movw	r30, r22
     8a4:	80 83       	st	Z, r24
     8a6:	80 e0       	ldi	r24, 0x00	; 0
     8a8:	08 95       	ret
     8aa:	86 b3       	in	r24, 0x16	; 22
     8ac:	28 2f       	mov	r18, r24
     8ae:	30 e0       	ldi	r19, 0x00	; 0
     8b0:	a9 01       	movw	r20, r18
     8b2:	02 c0       	rjmp	.+4      	; 0x8b8 <DIO_Read_Pin+0x54>
     8b4:	55 95       	asr	r21
     8b6:	47 95       	ror	r20
     8b8:	9a 95       	dec	r25
     8ba:	e2 f7       	brpl	.-8      	; 0x8b4 <DIO_Read_Pin+0x50>
     8bc:	ca 01       	movw	r24, r20
     8be:	81 70       	andi	r24, 0x01	; 1
     8c0:	fb 01       	movw	r30, r22
     8c2:	80 83       	st	Z, r24
     8c4:	80 e0       	ldi	r24, 0x00	; 0
     8c6:	08 95       	ret
     8c8:	83 b3       	in	r24, 0x13	; 19
     8ca:	28 2f       	mov	r18, r24
     8cc:	30 e0       	ldi	r19, 0x00	; 0
     8ce:	a9 01       	movw	r20, r18
     8d0:	02 c0       	rjmp	.+4      	; 0x8d6 <DIO_Read_Pin+0x72>
     8d2:	55 95       	asr	r21
     8d4:	47 95       	ror	r20
     8d6:	9a 95       	dec	r25
     8d8:	e2 f7       	brpl	.-8      	; 0x8d2 <DIO_Read_Pin+0x6e>
     8da:	ca 01       	movw	r24, r20
     8dc:	81 70       	andi	r24, 0x01	; 1
     8de:	fb 01       	movw	r30, r22
     8e0:	80 83       	st	Z, r24
     8e2:	80 e0       	ldi	r24, 0x00	; 0
     8e4:	08 95       	ret
     8e6:	80 b3       	in	r24, 0x10	; 16
     8e8:	28 2f       	mov	r18, r24
     8ea:	30 e0       	ldi	r19, 0x00	; 0
     8ec:	a9 01       	movw	r20, r18
     8ee:	02 c0       	rjmp	.+4      	; 0x8f4 <DIO_Read_Pin+0x90>
     8f0:	55 95       	asr	r21
     8f2:	47 95       	ror	r20
     8f4:	9a 95       	dec	r25
     8f6:	e2 f7       	brpl	.-8      	; 0x8f0 <DIO_Read_Pin+0x8c>
     8f8:	ca 01       	movw	r24, r20
     8fa:	81 70       	andi	r24, 0x01	; 1
     8fc:	fb 01       	movw	r30, r22
     8fe:	80 83       	st	Z, r24
     900:	80 e0       	ldi	r24, 0x00	; 0
     902:	08 95       	ret
     904:	81 e0       	ldi	r24, 0x01	; 1
     906:	08 95       	ret
     908:	81 e0       	ldi	r24, 0x01	; 1
     90a:	08 95       	ret

0000090c <DIO_toggle_Pin>:
uinteg8_t DIO_toggle_Pin(uinteg8_t pin)
{
	uinteg8_t por;
	if(pin>=PinsNeeded || pin>=No_of_pins ) return DIO_ERROR_NOK;
     90c:	80 32       	cpi	r24, 0x20	; 32
     90e:	08 f0       	brcs	.+2      	; 0x912 <DIO_toggle_Pin+0x6>
     910:	49 c0       	rjmp	.+146    	; 0x9a4 <DIO_toggle_Pin+0x98>
	else
	{
		por='A'+pin/PortSize;
		pin=pin%PortSize;
     912:	98 2f       	mov	r25, r24
     914:	97 70       	andi	r25, 0x07	; 7
	}
	
	switch(por)
     916:	86 95       	lsr	r24
     918:	86 95       	lsr	r24
     91a:	86 95       	lsr	r24
     91c:	8f 5b       	subi	r24, 0xBF	; 191
     91e:	82 34       	cpi	r24, 0x42	; 66
     920:	b9 f0       	breq	.+46     	; 0x950 <DIO_toggle_Pin+0x44>
     922:	18 f4       	brcc	.+6      	; 0x92a <DIO_toggle_Pin+0x1e>
     924:	81 34       	cpi	r24, 0x41	; 65
     926:	31 f0       	breq	.+12     	; 0x934 <DIO_toggle_Pin+0x28>
     928:	3f c0       	rjmp	.+126    	; 0x9a8 <DIO_toggle_Pin+0x9c>
     92a:	83 34       	cpi	r24, 0x43	; 67
     92c:	f9 f0       	breq	.+62     	; 0x96c <DIO_toggle_Pin+0x60>
     92e:	84 34       	cpi	r24, 0x44	; 68
     930:	59 f1       	breq	.+86     	; 0x988 <DIO_toggle_Pin+0x7c>
     932:	3a c0       	rjmp	.+116    	; 0x9a8 <DIO_toggle_Pin+0x9c>
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
     934:	4b b3       	in	r20, 0x1b	; 27
     936:	21 e0       	ldi	r18, 0x01	; 1
     938:	30 e0       	ldi	r19, 0x00	; 0
     93a:	b9 01       	movw	r22, r18
     93c:	02 c0       	rjmp	.+4      	; 0x942 <DIO_toggle_Pin+0x36>
     93e:	66 0f       	add	r22, r22
     940:	77 1f       	adc	r23, r23
     942:	9a 95       	dec	r25
     944:	e2 f7       	brpl	.-8      	; 0x93e <DIO_toggle_Pin+0x32>
     946:	cb 01       	movw	r24, r22
     948:	84 27       	eor	r24, r20
     94a:	8b bb       	out	0x1b, r24	; 27
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     94c:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	switch(por)
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
     94e:	08 95       	ret
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
     950:	48 b3       	in	r20, 0x18	; 24
     952:	21 e0       	ldi	r18, 0x01	; 1
     954:	30 e0       	ldi	r19, 0x00	; 0
     956:	b9 01       	movw	r22, r18
     958:	02 c0       	rjmp	.+4      	; 0x95e <DIO_toggle_Pin+0x52>
     95a:	66 0f       	add	r22, r22
     95c:	77 1f       	adc	r23, r23
     95e:	9a 95       	dec	r25
     960:	e2 f7       	brpl	.-8      	; 0x95a <DIO_toggle_Pin+0x4e>
     962:	cb 01       	movw	r24, r22
     964:	84 27       	eor	r24, r20
     966:	88 bb       	out	0x18, r24	; 24
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     968:	80 e0       	ldi	r24, 0x00	; 0
	switch(por)
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
     96a:	08 95       	ret
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
     96c:	45 b3       	in	r20, 0x15	; 21
     96e:	21 e0       	ldi	r18, 0x01	; 1
     970:	30 e0       	ldi	r19, 0x00	; 0
     972:	b9 01       	movw	r22, r18
     974:	02 c0       	rjmp	.+4      	; 0x97a <DIO_toggle_Pin+0x6e>
     976:	66 0f       	add	r22, r22
     978:	77 1f       	adc	r23, r23
     97a:	9a 95       	dec	r25
     97c:	e2 f7       	brpl	.-8      	; 0x976 <DIO_toggle_Pin+0x6a>
     97e:	cb 01       	movw	r24, r22
     980:	84 27       	eor	r24, r20
     982:	85 bb       	out	0x15, r24	; 21
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     984:	80 e0       	ldi	r24, 0x00	; 0
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
			 break;
     986:	08 95       	ret
		case 'D':TOGGLE_BIT(WriteRegisterD,pin);
     988:	42 b3       	in	r20, 0x12	; 18
     98a:	21 e0       	ldi	r18, 0x01	; 1
     98c:	30 e0       	ldi	r19, 0x00	; 0
     98e:	b9 01       	movw	r22, r18
     990:	02 c0       	rjmp	.+4      	; 0x996 <DIO_toggle_Pin+0x8a>
     992:	66 0f       	add	r22, r22
     994:	77 1f       	adc	r23, r23
     996:	9a 95       	dec	r25
     998:	e2 f7       	brpl	.-8      	; 0x992 <DIO_toggle_Pin+0x86>
     99a:	cb 01       	movw	r24, r22
     99c:	84 27       	eor	r24, r20
     99e:	82 bb       	out	0x12, r24	; 18
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     9a0:	80 e0       	ldi	r24, 0x00	; 0
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
			 break;
		case 'D':TOGGLE_BIT(WriteRegisterD,pin);
			 break;
     9a2:	08 95       	ret
return DIO_ERROR_OK;
}
uinteg8_t DIO_toggle_Pin(uinteg8_t pin)
{
	uinteg8_t por;
	if(pin>=PinsNeeded || pin>=No_of_pins ) return DIO_ERROR_NOK;
     9a4:	81 e0       	ldi	r24, 0x01	; 1
     9a6:	08 95       	ret
			 break;
		case 'G':TOGGLE_BIT(PORTG,pin);
			 break;
#endif
		default :
		return DIO_ERROR_NOK;
     9a8:	81 e0       	ldi	r24, 0x01	; 1
		break;
		
	}
	return DIO_ERROR_OK;
}
     9aa:	08 95       	ret

000009ac <Debug_By_Toggle>:
#define Debug_By_Toggle_State_Other_times 1
#define Debug_By_Toggle_State_Nothing     2


void Debug_By_Toggle(uinteg8_t u8_Pin)
{
     9ac:	cf 93       	push	r28
     9ae:	c8 2f       	mov	r28, r24
	DIO_Init_Pin(u8_Pin,1);
     9b0:	61 e0       	ldi	r22, 0x01	; 1
     9b2:	0e 94 9c 03 	call	0x738	; 0x738 <DIO_Init_Pin>
	DIO_toggle_Pin(u8_Pin);
     9b6:	8c 2f       	mov	r24, r28
     9b8:	0e 94 86 04 	call	0x90c	; 0x90c <DIO_toggle_Pin>
     9bc:	cf 91       	pop	r28
     9be:	08 95       	ret

000009c0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     9c0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9c2:	03 96       	adiw	r24, 0x03	; 3
     9c4:	92 83       	std	Z+2, r25	; 0x02
     9c6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     9c8:	2f ef       	ldi	r18, 0xFF	; 255
     9ca:	3f ef       	ldi	r19, 0xFF	; 255
     9cc:	34 83       	std	Z+4, r19	; 0x04
     9ce:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9d0:	96 83       	std	Z+6, r25	; 0x06
     9d2:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9d4:	90 87       	std	Z+8, r25	; 0x08
     9d6:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     9d8:	10 82       	st	Z, r1
     9da:	08 95       	ret

000009dc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     9dc:	fc 01       	movw	r30, r24
     9de:	11 86       	std	Z+9, r1	; 0x09
     9e0:	10 86       	std	Z+8, r1	; 0x08
     9e2:	08 95       	ret

000009e4 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9e4:	cf 93       	push	r28
     9e6:	df 93       	push	r29
     9e8:	9c 01       	movw	r18, r24
     9ea:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     9ec:	dc 01       	movw	r26, r24
     9ee:	11 96       	adiw	r26, 0x01	; 1
     9f0:	cd 91       	ld	r28, X+
     9f2:	dc 91       	ld	r29, X
     9f4:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     9f6:	d3 83       	std	Z+3, r29	; 0x03
     9f8:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9fa:	8c 81       	ldd	r24, Y+4	; 0x04
     9fc:	9d 81       	ldd	r25, Y+5	; 0x05
     9fe:	95 83       	std	Z+5, r25	; 0x05
     a00:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     a02:	8c 81       	ldd	r24, Y+4	; 0x04
     a04:	9d 81       	ldd	r25, Y+5	; 0x05
     a06:	dc 01       	movw	r26, r24
     a08:	13 96       	adiw	r26, 0x03	; 3
     a0a:	7c 93       	st	X, r23
     a0c:	6e 93       	st	-X, r22
     a0e:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     a10:	7d 83       	std	Y+5, r23	; 0x05
     a12:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     a14:	31 87       	std	Z+9, r19	; 0x09
     a16:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     a18:	f9 01       	movw	r30, r18
     a1a:	80 81       	ld	r24, Z
     a1c:	8f 5f       	subi	r24, 0xFF	; 255
     a1e:	80 83       	st	Z, r24
}
     a20:	df 91       	pop	r29
     a22:	cf 91       	pop	r28
     a24:	08 95       	ret

00000a26 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a26:	cf 93       	push	r28
     a28:	df 93       	push	r29
     a2a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     a2c:	48 81       	ld	r20, Y
     a2e:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a30:	4f 3f       	cpi	r20, 0xFF	; 255
     a32:	2f ef       	ldi	r18, 0xFF	; 255
     a34:	52 07       	cpc	r21, r18
     a36:	21 f4       	brne	.+8      	; 0xa40 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a38:	fc 01       	movw	r30, r24
     a3a:	a7 81       	ldd	r26, Z+7	; 0x07
     a3c:	b0 85       	ldd	r27, Z+8	; 0x08
     a3e:	0d c0       	rjmp	.+26     	; 0xa5a <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     a40:	dc 01       	movw	r26, r24
     a42:	13 96       	adiw	r26, 0x03	; 3
     a44:	01 c0       	rjmp	.+2      	; 0xa48 <vListInsert+0x22>
     a46:	df 01       	movw	r26, r30
     a48:	12 96       	adiw	r26, 0x02	; 2
     a4a:	ed 91       	ld	r30, X+
     a4c:	fc 91       	ld	r31, X
     a4e:	13 97       	sbiw	r26, 0x03	; 3
     a50:	20 81       	ld	r18, Z
     a52:	31 81       	ldd	r19, Z+1	; 0x01
     a54:	42 17       	cp	r20, r18
     a56:	53 07       	cpc	r21, r19
     a58:	b0 f7       	brcc	.-20     	; 0xa46 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a5a:	12 96       	adiw	r26, 0x02	; 2
     a5c:	ed 91       	ld	r30, X+
     a5e:	fc 91       	ld	r31, X
     a60:	13 97       	sbiw	r26, 0x03	; 3
     a62:	fb 83       	std	Y+3, r31	; 0x03
     a64:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a66:	d5 83       	std	Z+5, r29	; 0x05
     a68:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a6a:	bd 83       	std	Y+5, r27	; 0x05
     a6c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a6e:	13 96       	adiw	r26, 0x03	; 3
     a70:	dc 93       	st	X, r29
     a72:	ce 93       	st	-X, r28
     a74:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     a76:	99 87       	std	Y+9, r25	; 0x09
     a78:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a7a:	fc 01       	movw	r30, r24
     a7c:	20 81       	ld	r18, Z
     a7e:	2f 5f       	subi	r18, 0xFF	; 255
     a80:	20 83       	st	Z, r18
}
     a82:	df 91       	pop	r29
     a84:	cf 91       	pop	r28
     a86:	08 95       	ret

00000a88 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
     a8c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     a8e:	a0 85       	ldd	r26, Z+8	; 0x08
     a90:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a92:	c2 81       	ldd	r28, Z+2	; 0x02
     a94:	d3 81       	ldd	r29, Z+3	; 0x03
     a96:	84 81       	ldd	r24, Z+4	; 0x04
     a98:	95 81       	ldd	r25, Z+5	; 0x05
     a9a:	9d 83       	std	Y+5, r25	; 0x05
     a9c:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a9e:	c4 81       	ldd	r28, Z+4	; 0x04
     aa0:	d5 81       	ldd	r29, Z+5	; 0x05
     aa2:	82 81       	ldd	r24, Z+2	; 0x02
     aa4:	93 81       	ldd	r25, Z+3	; 0x03
     aa6:	9b 83       	std	Y+3, r25	; 0x03
     aa8:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     aaa:	11 96       	adiw	r26, 0x01	; 1
     aac:	8d 91       	ld	r24, X+
     aae:	9c 91       	ld	r25, X
     ab0:	12 97       	sbiw	r26, 0x02	; 2
     ab2:	e8 17       	cp	r30, r24
     ab4:	f9 07       	cpc	r31, r25
     ab6:	31 f4       	brne	.+12     	; 0xac4 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ab8:	84 81       	ldd	r24, Z+4	; 0x04
     aba:	95 81       	ldd	r25, Z+5	; 0x05
     abc:	12 96       	adiw	r26, 0x02	; 2
     abe:	9c 93       	st	X, r25
     ac0:	8e 93       	st	-X, r24
     ac2:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     ac4:	11 86       	std	Z+9, r1	; 0x09
     ac6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     ac8:	8c 91       	ld	r24, X
     aca:	81 50       	subi	r24, 0x01	; 1
     acc:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     ace:	8c 91       	ld	r24, X
}
     ad0:	df 91       	pop	r29
     ad2:	cf 91       	pop	r28
     ad4:	08 95       	ret

00000ad6 <pxPortInitialiseStack>:
	{
		vTaskSwitchContext();
	}
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
     ad6:	31 e1       	ldi	r19, 0x11	; 17
     ad8:	fc 01       	movw	r30, r24
     ada:	30 83       	st	Z, r19
     adc:	31 97       	sbiw	r30, 0x01	; 1
     ade:	22 e2       	ldi	r18, 0x22	; 34
     ae0:	20 83       	st	Z, r18
     ae2:	31 97       	sbiw	r30, 0x01	; 1
     ae4:	a3 e3       	ldi	r26, 0x33	; 51
     ae6:	a0 83       	st	Z, r26
     ae8:	31 97       	sbiw	r30, 0x01	; 1
     aea:	60 83       	st	Z, r22
     aec:	31 97       	sbiw	r30, 0x01	; 1
     aee:	70 83       	st	Z, r23
     af0:	31 97       	sbiw	r30, 0x01	; 1
     af2:	10 82       	st	Z, r1
     af4:	31 97       	sbiw	r30, 0x01	; 1
     af6:	60 e8       	ldi	r22, 0x80	; 128
     af8:	60 83       	st	Z, r22
     afa:	31 97       	sbiw	r30, 0x01	; 1
     afc:	10 82       	st	Z, r1
     afe:	31 97       	sbiw	r30, 0x01	; 1
     b00:	62 e0       	ldi	r22, 0x02	; 2
     b02:	60 83       	st	Z, r22
     b04:	31 97       	sbiw	r30, 0x01	; 1
     b06:	63 e0       	ldi	r22, 0x03	; 3
     b08:	60 83       	st	Z, r22
     b0a:	31 97       	sbiw	r30, 0x01	; 1
     b0c:	64 e0       	ldi	r22, 0x04	; 4
     b0e:	60 83       	st	Z, r22
     b10:	31 97       	sbiw	r30, 0x01	; 1
     b12:	65 e0       	ldi	r22, 0x05	; 5
     b14:	60 83       	st	Z, r22
     b16:	31 97       	sbiw	r30, 0x01	; 1
     b18:	66 e0       	ldi	r22, 0x06	; 6
     b1a:	60 83       	st	Z, r22
     b1c:	31 97       	sbiw	r30, 0x01	; 1
     b1e:	67 e0       	ldi	r22, 0x07	; 7
     b20:	60 83       	st	Z, r22
     b22:	31 97       	sbiw	r30, 0x01	; 1
     b24:	68 e0       	ldi	r22, 0x08	; 8
     b26:	60 83       	st	Z, r22
     b28:	31 97       	sbiw	r30, 0x01	; 1
     b2a:	69 e0       	ldi	r22, 0x09	; 9
     b2c:	60 83       	st	Z, r22
     b2e:	31 97       	sbiw	r30, 0x01	; 1
     b30:	60 e1       	ldi	r22, 0x10	; 16
     b32:	60 83       	st	Z, r22
     b34:	31 97       	sbiw	r30, 0x01	; 1
     b36:	30 83       	st	Z, r19
     b38:	31 97       	sbiw	r30, 0x01	; 1
     b3a:	32 e1       	ldi	r19, 0x12	; 18
     b3c:	30 83       	st	Z, r19
     b3e:	31 97       	sbiw	r30, 0x01	; 1
     b40:	33 e1       	ldi	r19, 0x13	; 19
     b42:	30 83       	st	Z, r19
     b44:	31 97       	sbiw	r30, 0x01	; 1
     b46:	34 e1       	ldi	r19, 0x14	; 20
     b48:	30 83       	st	Z, r19
     b4a:	31 97       	sbiw	r30, 0x01	; 1
     b4c:	35 e1       	ldi	r19, 0x15	; 21
     b4e:	30 83       	st	Z, r19
     b50:	31 97       	sbiw	r30, 0x01	; 1
     b52:	36 e1       	ldi	r19, 0x16	; 22
     b54:	30 83       	st	Z, r19
     b56:	31 97       	sbiw	r30, 0x01	; 1
     b58:	37 e1       	ldi	r19, 0x17	; 23
     b5a:	30 83       	st	Z, r19
     b5c:	31 97       	sbiw	r30, 0x01	; 1
     b5e:	38 e1       	ldi	r19, 0x18	; 24
     b60:	30 83       	st	Z, r19
     b62:	31 97       	sbiw	r30, 0x01	; 1
     b64:	39 e1       	ldi	r19, 0x19	; 25
     b66:	30 83       	st	Z, r19
     b68:	31 97       	sbiw	r30, 0x01	; 1
     b6a:	30 e2       	ldi	r19, 0x20	; 32
     b6c:	30 83       	st	Z, r19
     b6e:	31 97       	sbiw	r30, 0x01	; 1
     b70:	31 e2       	ldi	r19, 0x21	; 33
     b72:	30 83       	st	Z, r19
     b74:	31 97       	sbiw	r30, 0x01	; 1
     b76:	20 83       	st	Z, r18
     b78:	31 97       	sbiw	r30, 0x01	; 1
     b7a:	23 e2       	ldi	r18, 0x23	; 35
     b7c:	20 83       	st	Z, r18
     b7e:	31 97       	sbiw	r30, 0x01	; 1
     b80:	40 83       	st	Z, r20
     b82:	31 97       	sbiw	r30, 0x01	; 1
     b84:	50 83       	st	Z, r21
     b86:	31 97       	sbiw	r30, 0x01	; 1
     b88:	26 e2       	ldi	r18, 0x26	; 38
     b8a:	20 83       	st	Z, r18
     b8c:	31 97       	sbiw	r30, 0x01	; 1
     b8e:	27 e2       	ldi	r18, 0x27	; 39
     b90:	20 83       	st	Z, r18
     b92:	31 97       	sbiw	r30, 0x01	; 1
     b94:	28 e2       	ldi	r18, 0x28	; 40
     b96:	20 83       	st	Z, r18
     b98:	31 97       	sbiw	r30, 0x01	; 1
     b9a:	29 e2       	ldi	r18, 0x29	; 41
     b9c:	20 83       	st	Z, r18
     b9e:	31 97       	sbiw	r30, 0x01	; 1
     ba0:	20 e3       	ldi	r18, 0x30	; 48
     ba2:	20 83       	st	Z, r18
     ba4:	31 97       	sbiw	r30, 0x01	; 1
     ba6:	21 e3       	ldi	r18, 0x31	; 49
     ba8:	20 83       	st	Z, r18
     baa:	86 97       	sbiw	r24, 0x26	; 38
     bac:	08 95       	ret

00000bae <xPortStartScheduler>:
     bae:	1b bc       	out	0x2b, r1	; 43
     bb0:	8c e7       	ldi	r24, 0x7C	; 124
     bb2:	8a bd       	out	0x2a, r24	; 42
     bb4:	8b e0       	ldi	r24, 0x0B	; 11
     bb6:	8e bd       	out	0x2e, r24	; 46
     bb8:	89 b7       	in	r24, 0x39	; 57
     bba:	80 61       	ori	r24, 0x10	; 16
     bbc:	89 bf       	out	0x39, r24	; 57
     bbe:	a0 91 25 07 	lds	r26, 0x0725	; 0x800725 <pxCurrentTCB>
     bc2:	b0 91 26 07 	lds	r27, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
     bc6:	cd 91       	ld	r28, X+
     bc8:	cd bf       	out	0x3d, r28	; 61
     bca:	dd 91       	ld	r29, X+
     bcc:	de bf       	out	0x3e, r29	; 62
     bce:	ff 91       	pop	r31
     bd0:	ef 91       	pop	r30
     bd2:	df 91       	pop	r29
     bd4:	cf 91       	pop	r28
     bd6:	bf 91       	pop	r27
     bd8:	af 91       	pop	r26
     bda:	9f 91       	pop	r25
     bdc:	8f 91       	pop	r24
     bde:	7f 91       	pop	r23
     be0:	6f 91       	pop	r22
     be2:	5f 91       	pop	r21
     be4:	4f 91       	pop	r20
     be6:	3f 91       	pop	r19
     be8:	2f 91       	pop	r18
     bea:	1f 91       	pop	r17
     bec:	0f 91       	pop	r16
     bee:	ff 90       	pop	r15
     bf0:	ef 90       	pop	r14
     bf2:	df 90       	pop	r13
     bf4:	cf 90       	pop	r12
     bf6:	bf 90       	pop	r11
     bf8:	af 90       	pop	r10
     bfa:	9f 90       	pop	r9
     bfc:	8f 90       	pop	r8
     bfe:	7f 90       	pop	r7
     c00:	6f 90       	pop	r6
     c02:	5f 90       	pop	r5
     c04:	4f 90       	pop	r4
     c06:	3f 90       	pop	r3
     c08:	2f 90       	pop	r2
     c0a:	1f 90       	pop	r1
     c0c:	0f 90       	pop	r0
     c0e:	0f be       	out	0x3f, r0	; 63
     c10:	0f 90       	pop	r0
     c12:	08 95       	ret
     c14:	81 e0       	ldi	r24, 0x01	; 1
     c16:	08 95       	ret

00000c18 <vPortYield>:
     c18:	0f 92       	push	r0
     c1a:	0f b6       	in	r0, 0x3f	; 63
     c1c:	f8 94       	cli
     c1e:	0f 92       	push	r0
     c20:	1f 92       	push	r1
     c22:	11 24       	eor	r1, r1
     c24:	2f 92       	push	r2
     c26:	3f 92       	push	r3
     c28:	4f 92       	push	r4
     c2a:	5f 92       	push	r5
     c2c:	6f 92       	push	r6
     c2e:	7f 92       	push	r7
     c30:	8f 92       	push	r8
     c32:	9f 92       	push	r9
     c34:	af 92       	push	r10
     c36:	bf 92       	push	r11
     c38:	cf 92       	push	r12
     c3a:	df 92       	push	r13
     c3c:	ef 92       	push	r14
     c3e:	ff 92       	push	r15
     c40:	0f 93       	push	r16
     c42:	1f 93       	push	r17
     c44:	2f 93       	push	r18
     c46:	3f 93       	push	r19
     c48:	4f 93       	push	r20
     c4a:	5f 93       	push	r21
     c4c:	6f 93       	push	r22
     c4e:	7f 93       	push	r23
     c50:	8f 93       	push	r24
     c52:	9f 93       	push	r25
     c54:	af 93       	push	r26
     c56:	bf 93       	push	r27
     c58:	cf 93       	push	r28
     c5a:	df 93       	push	r29
     c5c:	ef 93       	push	r30
     c5e:	ff 93       	push	r31
     c60:	a0 91 25 07 	lds	r26, 0x0725	; 0x800725 <pxCurrentTCB>
     c64:	b0 91 26 07 	lds	r27, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
     c68:	0d b6       	in	r0, 0x3d	; 61
     c6a:	0d 92       	st	X+, r0
     c6c:	0e b6       	in	r0, 0x3e	; 62
     c6e:	0d 92       	st	X+, r0
     c70:	0e 94 a1 0c 	call	0x1942	; 0x1942 <vTaskSwitchContext>
     c74:	a0 91 25 07 	lds	r26, 0x0725	; 0x800725 <pxCurrentTCB>
     c78:	b0 91 26 07 	lds	r27, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
     c7c:	cd 91       	ld	r28, X+
     c7e:	cd bf       	out	0x3d, r28	; 61
     c80:	dd 91       	ld	r29, X+
     c82:	de bf       	out	0x3e, r29	; 62
     c84:	ff 91       	pop	r31
     c86:	ef 91       	pop	r30
     c88:	df 91       	pop	r29
     c8a:	cf 91       	pop	r28
     c8c:	bf 91       	pop	r27
     c8e:	af 91       	pop	r26
     c90:	9f 91       	pop	r25
     c92:	8f 91       	pop	r24
     c94:	7f 91       	pop	r23
     c96:	6f 91       	pop	r22
     c98:	5f 91       	pop	r21
     c9a:	4f 91       	pop	r20
     c9c:	3f 91       	pop	r19
     c9e:	2f 91       	pop	r18
     ca0:	1f 91       	pop	r17
     ca2:	0f 91       	pop	r16
     ca4:	ff 90       	pop	r15
     ca6:	ef 90       	pop	r14
     ca8:	df 90       	pop	r13
     caa:	cf 90       	pop	r12
     cac:	bf 90       	pop	r11
     cae:	af 90       	pop	r10
     cb0:	9f 90       	pop	r9
     cb2:	8f 90       	pop	r8
     cb4:	7f 90       	pop	r7
     cb6:	6f 90       	pop	r6
     cb8:	5f 90       	pop	r5
     cba:	4f 90       	pop	r4
     cbc:	3f 90       	pop	r3
     cbe:	2f 90       	pop	r2
     cc0:	1f 90       	pop	r1
     cc2:	0f 90       	pop	r0
     cc4:	0f be       	out	0x3f, r0	; 63
     cc6:	0f 90       	pop	r0
     cc8:	08 95       	ret

00000cca <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
     cca:	1f 92       	push	r1
     ccc:	0f 92       	push	r0
     cce:	0f b6       	in	r0, 0x3f	; 63
     cd0:	0f 92       	push	r0
     cd2:	11 24       	eor	r1, r1
     cd4:	2f 93       	push	r18
     cd6:	3f 93       	push	r19
     cd8:	4f 93       	push	r20
     cda:	5f 93       	push	r21
     cdc:	6f 93       	push	r22
     cde:	7f 93       	push	r23
     ce0:	8f 93       	push	r24
     ce2:	9f 93       	push	r25
     ce4:	af 93       	push	r26
     ce6:	bf 93       	push	r27
     ce8:	ef 93       	push	r30
     cea:	ff 93       	push	r31
		xTaskIncrementTick();
     cec:	0e 94 38 0b 	call	0x1670	; 0x1670 <xTaskIncrementTick>
	}
     cf0:	ff 91       	pop	r31
     cf2:	ef 91       	pop	r30
     cf4:	bf 91       	pop	r27
     cf6:	af 91       	pop	r26
     cf8:	9f 91       	pop	r25
     cfa:	8f 91       	pop	r24
     cfc:	7f 91       	pop	r23
     cfe:	6f 91       	pop	r22
     d00:	5f 91       	pop	r21
     d02:	4f 91       	pop	r20
     d04:	3f 91       	pop	r19
     d06:	2f 91       	pop	r18
     d08:	0f 90       	pop	r0
     d0a:	0f be       	out	0x3f, r0	; 63
     d0c:	0f 90       	pop	r0
     d0e:	1f 90       	pop	r1
     d10:	18 95       	reti

00000d12 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     d12:	cf 93       	push	r28
     d14:	df 93       	push	r29
     d16:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     d18:	0e 94 28 0b 	call	0x1650	; 0x1650 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     d1c:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <pucAlignedHeap.2084>
     d20:	90 91 d9 00 	lds	r25, 0x00D9	; 0x8000d9 <pucAlignedHeap.2084+0x1>
     d24:	89 2b       	or	r24, r25
     d26:	31 f4       	brne	.+12     	; 0xd34 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     d28:	8d ed       	ldi	r24, 0xDD	; 221
     d2a:	90 e0       	ldi	r25, 0x00	; 0
     d2c:	90 93 d9 00 	sts	0x00D9, r25	; 0x8000d9 <pucAlignedHeap.2084+0x1>
     d30:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     d34:	20 91 da 00 	lds	r18, 0x00DA	; 0x8000da <xNextFreeByte>
     d38:	30 91 db 00 	lds	r19, 0x00DB	; 0x8000db <xNextFreeByte+0x1>
     d3c:	c9 01       	movw	r24, r18
     d3e:	8c 0f       	add	r24, r28
     d40:	9d 1f       	adc	r25, r29
     d42:	8b 3d       	cpi	r24, 0xDB	; 219
     d44:	45 e0       	ldi	r20, 0x05	; 5
     d46:	94 07       	cpc	r25, r20
     d48:	70 f4       	brcc	.+28     	; 0xd66 <pvPortMalloc+0x54>
     d4a:	28 17       	cp	r18, r24
     d4c:	39 07       	cpc	r19, r25
     d4e:	70 f4       	brcc	.+28     	; 0xd6c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     d50:	c0 91 d8 00 	lds	r28, 0x00D8	; 0x8000d8 <pucAlignedHeap.2084>
     d54:	d0 91 d9 00 	lds	r29, 0x00D9	; 0x8000d9 <pucAlignedHeap.2084+0x1>
     d58:	c2 0f       	add	r28, r18
     d5a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     d5c:	90 93 db 00 	sts	0x00DB, r25	; 0x8000db <xNextFreeByte+0x1>
     d60:	80 93 da 00 	sts	0x00DA, r24	; 0x8000da <xNextFreeByte>
     d64:	05 c0       	rjmp	.+10     	; 0xd70 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     d66:	c0 e0       	ldi	r28, 0x00	; 0
     d68:	d0 e0       	ldi	r29, 0x00	; 0
     d6a:	02 c0       	rjmp	.+4      	; 0xd70 <pvPortMalloc+0x5e>
     d6c:	c0 e0       	ldi	r28, 0x00	; 0
     d6e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     d70:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     d74:	ce 01       	movw	r24, r28
     d76:	df 91       	pop	r29
     d78:	cf 91       	pop	r28
     d7a:	08 95       	ret

00000d7c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     d7c:	08 95       	ret

00000d7e <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     d7e:	0f b6       	in	r0, 0x3f	; 63
     d80:	f8 94       	cli
     d82:	0f 92       	push	r0
     d84:	fc 01       	movw	r30, r24
     d86:	92 8d       	ldd	r25, Z+26	; 0x1a
     d88:	0f 90       	pop	r0
     d8a:	0f be       	out	0x3f, r0	; 63
     d8c:	81 e0       	ldi	r24, 0x01	; 1
     d8e:	91 11       	cpse	r25, r1
     d90:	80 e0       	ldi	r24, 0x00	; 0
     d92:	08 95       	ret

00000d94 <prvCopyDataToQueue>:
     d94:	0f 93       	push	r16
     d96:	1f 93       	push	r17
     d98:	cf 93       	push	r28
     d9a:	df 93       	push	r29
     d9c:	ec 01       	movw	r28, r24
     d9e:	04 2f       	mov	r16, r20
     da0:	1a 8d       	ldd	r17, Y+26	; 0x1a
     da2:	4c 8d       	ldd	r20, Y+28	; 0x1c
     da4:	44 23       	and	r20, r20
     da6:	b9 f1       	breq	.+110    	; 0xe16 <prvCopyDataToQueue+0x82>
     da8:	01 11       	cpse	r16, r1
     daa:	16 c0       	rjmp	.+44     	; 0xdd8 <prvCopyDataToQueue+0x44>
     dac:	50 e0       	ldi	r21, 0x00	; 0
     dae:	8a 81       	ldd	r24, Y+2	; 0x02
     db0:	9b 81       	ldd	r25, Y+3	; 0x03
     db2:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <memcpy>
     db6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     db8:	8a 81       	ldd	r24, Y+2	; 0x02
     dba:	9b 81       	ldd	r25, Y+3	; 0x03
     dbc:	82 0f       	add	r24, r18
     dbe:	91 1d       	adc	r25, r1
     dc0:	9b 83       	std	Y+3, r25	; 0x03
     dc2:	8a 83       	std	Y+2, r24	; 0x02
     dc4:	2c 81       	ldd	r18, Y+4	; 0x04
     dc6:	3d 81       	ldd	r19, Y+5	; 0x05
     dc8:	82 17       	cp	r24, r18
     dca:	93 07       	cpc	r25, r19
     dcc:	20 f1       	brcs	.+72     	; 0xe16 <prvCopyDataToQueue+0x82>
     dce:	88 81       	ld	r24, Y
     dd0:	99 81       	ldd	r25, Y+1	; 0x01
     dd2:	9b 83       	std	Y+3, r25	; 0x03
     dd4:	8a 83       	std	Y+2, r24	; 0x02
     dd6:	1f c0       	rjmp	.+62     	; 0xe16 <prvCopyDataToQueue+0x82>
     dd8:	50 e0       	ldi	r21, 0x00	; 0
     dda:	8e 81       	ldd	r24, Y+6	; 0x06
     ddc:	9f 81       	ldd	r25, Y+7	; 0x07
     dde:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <memcpy>
     de2:	8c 8d       	ldd	r24, Y+28	; 0x1c
     de4:	90 e0       	ldi	r25, 0x00	; 0
     de6:	91 95       	neg	r25
     de8:	81 95       	neg	r24
     dea:	91 09       	sbc	r25, r1
     dec:	2e 81       	ldd	r18, Y+6	; 0x06
     dee:	3f 81       	ldd	r19, Y+7	; 0x07
     df0:	28 0f       	add	r18, r24
     df2:	39 1f       	adc	r19, r25
     df4:	3f 83       	std	Y+7, r19	; 0x07
     df6:	2e 83       	std	Y+6, r18	; 0x06
     df8:	48 81       	ld	r20, Y
     dfa:	59 81       	ldd	r21, Y+1	; 0x01
     dfc:	24 17       	cp	r18, r20
     dfe:	35 07       	cpc	r19, r21
     e00:	30 f4       	brcc	.+12     	; 0xe0e <prvCopyDataToQueue+0x7a>
     e02:	2c 81       	ldd	r18, Y+4	; 0x04
     e04:	3d 81       	ldd	r19, Y+5	; 0x05
     e06:	82 0f       	add	r24, r18
     e08:	93 1f       	adc	r25, r19
     e0a:	9f 83       	std	Y+7, r25	; 0x07
     e0c:	8e 83       	std	Y+6, r24	; 0x06
     e0e:	02 30       	cpi	r16, 0x02	; 2
     e10:	11 f4       	brne	.+4      	; 0xe16 <prvCopyDataToQueue+0x82>
     e12:	11 11       	cpse	r17, r1
     e14:	11 50       	subi	r17, 0x01	; 1
     e16:	1f 5f       	subi	r17, 0xFF	; 255
     e18:	1a 8f       	std	Y+26, r17	; 0x1a
     e1a:	80 e0       	ldi	r24, 0x00	; 0
     e1c:	df 91       	pop	r29
     e1e:	cf 91       	pop	r28
     e20:	1f 91       	pop	r17
     e22:	0f 91       	pop	r16
     e24:	08 95       	ret

00000e26 <prvUnlockQueue>:
     e26:	ef 92       	push	r14
     e28:	ff 92       	push	r15
     e2a:	0f 93       	push	r16
     e2c:	1f 93       	push	r17
     e2e:	cf 93       	push	r28
     e30:	8c 01       	movw	r16, r24
     e32:	0f b6       	in	r0, 0x3f	; 63
     e34:	f8 94       	cli
     e36:	0f 92       	push	r0
     e38:	fc 01       	movw	r30, r24
     e3a:	c6 8d       	ldd	r28, Z+30	; 0x1e
     e3c:	1c 16       	cp	r1, r28
     e3e:	ac f4       	brge	.+42     	; 0xe6a <prvUnlockQueue+0x44>
     e40:	81 89       	ldd	r24, Z+17	; 0x11
     e42:	81 11       	cpse	r24, r1
     e44:	06 c0       	rjmp	.+12     	; 0xe52 <prvUnlockQueue+0x2c>
     e46:	11 c0       	rjmp	.+34     	; 0xe6a <prvUnlockQueue+0x44>
     e48:	f8 01       	movw	r30, r16
     e4a:	81 89       	ldd	r24, Z+17	; 0x11
     e4c:	81 11       	cpse	r24, r1
     e4e:	05 c0       	rjmp	.+10     	; 0xe5a <prvUnlockQueue+0x34>
     e50:	0c c0       	rjmp	.+24     	; 0xe6a <prvUnlockQueue+0x44>
     e52:	78 01       	movw	r14, r16
     e54:	f1 e1       	ldi	r31, 0x11	; 17
     e56:	ef 0e       	add	r14, r31
     e58:	f1 1c       	adc	r15, r1
     e5a:	c7 01       	movw	r24, r14
     e5c:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <xTaskRemoveFromEventList>
     e60:	81 11       	cpse	r24, r1
     e62:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vTaskMissedYield>
     e66:	c1 50       	subi	r28, 0x01	; 1
     e68:	79 f7       	brne	.-34     	; 0xe48 <prvUnlockQueue+0x22>
     e6a:	8f ef       	ldi	r24, 0xFF	; 255
     e6c:	f8 01       	movw	r30, r16
     e6e:	86 8f       	std	Z+30, r24	; 0x1e
     e70:	0f 90       	pop	r0
     e72:	0f be       	out	0x3f, r0	; 63
     e74:	0f b6       	in	r0, 0x3f	; 63
     e76:	f8 94       	cli
     e78:	0f 92       	push	r0
     e7a:	c5 8d       	ldd	r28, Z+29	; 0x1d
     e7c:	1c 16       	cp	r1, r28
     e7e:	ac f4       	brge	.+42     	; 0xeaa <prvUnlockQueue+0x84>
     e80:	80 85       	ldd	r24, Z+8	; 0x08
     e82:	81 11       	cpse	r24, r1
     e84:	06 c0       	rjmp	.+12     	; 0xe92 <prvUnlockQueue+0x6c>
     e86:	11 c0       	rjmp	.+34     	; 0xeaa <prvUnlockQueue+0x84>
     e88:	f8 01       	movw	r30, r16
     e8a:	80 85       	ldd	r24, Z+8	; 0x08
     e8c:	81 11       	cpse	r24, r1
     e8e:	05 c0       	rjmp	.+10     	; 0xe9a <prvUnlockQueue+0x74>
     e90:	0c c0       	rjmp	.+24     	; 0xeaa <prvUnlockQueue+0x84>
     e92:	78 01       	movw	r14, r16
     e94:	f8 e0       	ldi	r31, 0x08	; 8
     e96:	ef 0e       	add	r14, r31
     e98:	f1 1c       	adc	r15, r1
     e9a:	c7 01       	movw	r24, r14
     e9c:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <xTaskRemoveFromEventList>
     ea0:	81 11       	cpse	r24, r1
     ea2:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vTaskMissedYield>
     ea6:	c1 50       	subi	r28, 0x01	; 1
     ea8:	79 f7       	brne	.-34     	; 0xe88 <prvUnlockQueue+0x62>
     eaa:	8f ef       	ldi	r24, 0xFF	; 255
     eac:	f8 01       	movw	r30, r16
     eae:	85 8f       	std	Z+29, r24	; 0x1d
     eb0:	0f 90       	pop	r0
     eb2:	0f be       	out	0x3f, r0	; 63
     eb4:	cf 91       	pop	r28
     eb6:	1f 91       	pop	r17
     eb8:	0f 91       	pop	r16
     eba:	ff 90       	pop	r15
     ebc:	ef 90       	pop	r14
     ebe:	08 95       	ret

00000ec0 <xQueueGenericReset>:
     ec0:	cf 93       	push	r28
     ec2:	df 93       	push	r29
     ec4:	ec 01       	movw	r28, r24
     ec6:	0f b6       	in	r0, 0x3f	; 63
     ec8:	f8 94       	cli
     eca:	0f 92       	push	r0
     ecc:	e8 81       	ld	r30, Y
     ece:	f9 81       	ldd	r31, Y+1	; 0x01
     ed0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     ed2:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ed4:	90 e0       	ldi	r25, 0x00	; 0
     ed6:	30 e0       	ldi	r19, 0x00	; 0
     ed8:	82 9f       	mul	r24, r18
     eda:	a0 01       	movw	r20, r0
     edc:	83 9f       	mul	r24, r19
     ede:	50 0d       	add	r21, r0
     ee0:	92 9f       	mul	r25, r18
     ee2:	50 0d       	add	r21, r0
     ee4:	11 24       	eor	r1, r1
     ee6:	4e 0f       	add	r20, r30
     ee8:	5f 1f       	adc	r21, r31
     eea:	5d 83       	std	Y+5, r21	; 0x05
     eec:	4c 83       	std	Y+4, r20	; 0x04
     eee:	1a 8e       	std	Y+26, r1	; 0x1a
     ef0:	fb 83       	std	Y+3, r31	; 0x03
     ef2:	ea 83       	std	Y+2, r30	; 0x02
     ef4:	01 97       	sbiw	r24, 0x01	; 1
     ef6:	82 9f       	mul	r24, r18
     ef8:	a0 01       	movw	r20, r0
     efa:	83 9f       	mul	r24, r19
     efc:	50 0d       	add	r21, r0
     efe:	92 9f       	mul	r25, r18
     f00:	50 0d       	add	r21, r0
     f02:	11 24       	eor	r1, r1
     f04:	cf 01       	movw	r24, r30
     f06:	84 0f       	add	r24, r20
     f08:	95 1f       	adc	r25, r21
     f0a:	9f 83       	std	Y+7, r25	; 0x07
     f0c:	8e 83       	std	Y+6, r24	; 0x06
     f0e:	8f ef       	ldi	r24, 0xFF	; 255
     f10:	8d 8f       	std	Y+29, r24	; 0x1d
     f12:	8e 8f       	std	Y+30, r24	; 0x1e
     f14:	61 11       	cpse	r22, r1
     f16:	08 c0       	rjmp	.+16     	; 0xf28 <xQueueGenericReset+0x68>
     f18:	88 85       	ldd	r24, Y+8	; 0x08
     f1a:	88 23       	and	r24, r24
     f1c:	69 f0       	breq	.+26     	; 0xf38 <xQueueGenericReset+0x78>
     f1e:	ce 01       	movw	r24, r28
     f20:	08 96       	adiw	r24, 0x08	; 8
     f22:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <xTaskRemoveFromEventList>
     f26:	08 c0       	rjmp	.+16     	; 0xf38 <xQueueGenericReset+0x78>
     f28:	ce 01       	movw	r24, r28
     f2a:	08 96       	adiw	r24, 0x08	; 8
     f2c:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <vListInitialise>
     f30:	ce 01       	movw	r24, r28
     f32:	41 96       	adiw	r24, 0x11	; 17
     f34:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <vListInitialise>
     f38:	0f 90       	pop	r0
     f3a:	0f be       	out	0x3f, r0	; 63
     f3c:	81 e0       	ldi	r24, 0x01	; 1
     f3e:	df 91       	pop	r29
     f40:	cf 91       	pop	r28
     f42:	08 95       	ret

00000f44 <xQueueGenericCreate>:
     f44:	0f 93       	push	r16
     f46:	1f 93       	push	r17
     f48:	cf 93       	push	r28
     f4a:	df 93       	push	r29
     f4c:	08 2f       	mov	r16, r24
     f4e:	16 2f       	mov	r17, r22
     f50:	66 23       	and	r22, r22
     f52:	c1 f0       	breq	.+48     	; 0xf84 <xQueueGenericCreate+0x40>
     f54:	86 9f       	mul	r24, r22
     f56:	c0 01       	movw	r24, r0
     f58:	11 24       	eor	r1, r1
     f5a:	4f 96       	adiw	r24, 0x1f	; 31
     f5c:	0e 94 89 06 	call	0xd12	; 0xd12 <pvPortMalloc>
     f60:	ec 01       	movw	r28, r24
     f62:	00 97       	sbiw	r24, 0x00	; 0
     f64:	41 f4       	brne	.+16     	; 0xf76 <xQueueGenericCreate+0x32>
     f66:	15 c0       	rjmp	.+42     	; 0xf92 <xQueueGenericCreate+0x4e>
     f68:	0b 8f       	std	Y+27, r16	; 0x1b
     f6a:	1c 8f       	std	Y+28, r17	; 0x1c
     f6c:	61 e0       	ldi	r22, 0x01	; 1
     f6e:	ce 01       	movw	r24, r28
     f70:	0e 94 60 07 	call	0xec0	; 0xec0 <xQueueGenericReset>
     f74:	0e c0       	rjmp	.+28     	; 0xf92 <xQueueGenericCreate+0x4e>
     f76:	4f 96       	adiw	r24, 0x1f	; 31
     f78:	99 83       	std	Y+1, r25	; 0x01
     f7a:	88 83       	st	Y, r24
     f7c:	f5 cf       	rjmp	.-22     	; 0xf68 <xQueueGenericCreate+0x24>
     f7e:	d9 83       	std	Y+1, r29	; 0x01
     f80:	c8 83       	st	Y, r28
     f82:	f2 cf       	rjmp	.-28     	; 0xf68 <xQueueGenericCreate+0x24>
     f84:	8f e1       	ldi	r24, 0x1F	; 31
     f86:	90 e0       	ldi	r25, 0x00	; 0
     f88:	0e 94 89 06 	call	0xd12	; 0xd12 <pvPortMalloc>
     f8c:	ec 01       	movw	r28, r24
     f8e:	89 2b       	or	r24, r25
     f90:	b1 f7       	brne	.-20     	; 0xf7e <xQueueGenericCreate+0x3a>
     f92:	ce 01       	movw	r24, r28
     f94:	df 91       	pop	r29
     f96:	cf 91       	pop	r28
     f98:	1f 91       	pop	r17
     f9a:	0f 91       	pop	r16
     f9c:	08 95       	ret

00000f9e <xQueueCreateCountingSemaphore>:
     f9e:	cf 93       	push	r28
     fa0:	c6 2f       	mov	r28, r22
     fa2:	42 e0       	ldi	r20, 0x02	; 2
     fa4:	60 e0       	ldi	r22, 0x00	; 0
     fa6:	0e 94 a2 07 	call	0xf44	; 0xf44 <xQueueGenericCreate>
     faa:	00 97       	sbiw	r24, 0x00	; 0
     fac:	11 f0       	breq	.+4      	; 0xfb2 <xQueueCreateCountingSemaphore+0x14>
     fae:	fc 01       	movw	r30, r24
     fb0:	c2 8f       	std	Z+26, r28	; 0x1a
     fb2:	cf 91       	pop	r28
     fb4:	08 95       	ret

00000fb6 <xQueueGenericSend>:
     fb6:	9f 92       	push	r9
     fb8:	af 92       	push	r10
     fba:	bf 92       	push	r11
     fbc:	cf 92       	push	r12
     fbe:	df 92       	push	r13
     fc0:	ef 92       	push	r14
     fc2:	ff 92       	push	r15
     fc4:	0f 93       	push	r16
     fc6:	1f 93       	push	r17
     fc8:	cf 93       	push	r28
     fca:	df 93       	push	r29
     fcc:	00 d0       	rcall	.+0      	; 0xfce <xQueueGenericSend+0x18>
     fce:	00 d0       	rcall	.+0      	; 0xfd0 <xQueueGenericSend+0x1a>
     fd0:	1f 92       	push	r1
     fd2:	cd b7       	in	r28, 0x3d	; 61
     fd4:	de b7       	in	r29, 0x3e	; 62
     fd6:	8c 01       	movw	r16, r24
     fd8:	6b 01       	movw	r12, r22
     fda:	5d 83       	std	Y+5, r21	; 0x05
     fdc:	4c 83       	std	Y+4, r20	; 0x04
     fde:	a2 2e       	mov	r10, r18
     fe0:	b1 2c       	mov	r11, r1
     fe2:	99 24       	eor	r9, r9
     fe4:	93 94       	inc	r9
     fe6:	7c 01       	movw	r14, r24
     fe8:	88 e0       	ldi	r24, 0x08	; 8
     fea:	e8 0e       	add	r14, r24
     fec:	f1 1c       	adc	r15, r1
     fee:	0f b6       	in	r0, 0x3f	; 63
     ff0:	f8 94       	cli
     ff2:	0f 92       	push	r0
     ff4:	f8 01       	movw	r30, r16
     ff6:	92 8d       	ldd	r25, Z+26	; 0x1a
     ff8:	83 8d       	ldd	r24, Z+27	; 0x1b
     ffa:	98 17       	cp	r25, r24
     ffc:	18 f0       	brcs	.+6      	; 0x1004 <xQueueGenericSend+0x4e>
     ffe:	f2 e0       	ldi	r31, 0x02	; 2
    1000:	af 12       	cpse	r10, r31
    1002:	11 c0       	rjmp	.+34     	; 0x1026 <xQueueGenericSend+0x70>
    1004:	4a 2d       	mov	r20, r10
    1006:	b6 01       	movw	r22, r12
    1008:	c8 01       	movw	r24, r16
    100a:	0e 94 ca 06 	call	0xd94	; 0xd94 <prvCopyDataToQueue>
    100e:	f8 01       	movw	r30, r16
    1010:	81 89       	ldd	r24, Z+17	; 0x11
    1012:	88 23       	and	r24, r24
    1014:	21 f0       	breq	.+8      	; 0x101e <xQueueGenericSend+0x68>
    1016:	c8 01       	movw	r24, r16
    1018:	41 96       	adiw	r24, 0x11	; 17
    101a:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <xTaskRemoveFromEventList>
    101e:	0f 90       	pop	r0
    1020:	0f be       	out	0x3f, r0	; 63
    1022:	81 e0       	ldi	r24, 0x01	; 1
    1024:	50 c0       	rjmp	.+160    	; 0x10c6 <xQueueGenericSend+0x110>
    1026:	8c 81       	ldd	r24, Y+4	; 0x04
    1028:	9d 81       	ldd	r25, Y+5	; 0x05
    102a:	89 2b       	or	r24, r25
    102c:	21 f4       	brne	.+8      	; 0x1036 <xQueueGenericSend+0x80>
    102e:	0f 90       	pop	r0
    1030:	0f be       	out	0x3f, r0	; 63
    1032:	80 e0       	ldi	r24, 0x00	; 0
    1034:	48 c0       	rjmp	.+144    	; 0x10c6 <xQueueGenericSend+0x110>
    1036:	b1 10       	cpse	r11, r1
    1038:	05 c0       	rjmp	.+10     	; 0x1044 <xQueueGenericSend+0x8e>
    103a:	ce 01       	movw	r24, r28
    103c:	01 96       	adiw	r24, 0x01	; 1
    103e:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <vTaskInternalSetTimeOutState>
    1042:	b9 2c       	mov	r11, r9
    1044:	0f 90       	pop	r0
    1046:	0f be       	out	0x3f, r0	; 63
    1048:	0e 94 28 0b 	call	0x1650	; 0x1650 <vTaskSuspendAll>
    104c:	0f b6       	in	r0, 0x3f	; 63
    104e:	f8 94       	cli
    1050:	0f 92       	push	r0
    1052:	f8 01       	movw	r30, r16
    1054:	85 8d       	ldd	r24, Z+29	; 0x1d
    1056:	8f 3f       	cpi	r24, 0xFF	; 255
    1058:	09 f4       	brne	.+2      	; 0x105c <xQueueGenericSend+0xa6>
    105a:	15 8e       	std	Z+29, r1	; 0x1d
    105c:	f8 01       	movw	r30, r16
    105e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1060:	8f 3f       	cpi	r24, 0xFF	; 255
    1062:	09 f4       	brne	.+2      	; 0x1066 <xQueueGenericSend+0xb0>
    1064:	16 8e       	std	Z+30, r1	; 0x1e
    1066:	0f 90       	pop	r0
    1068:	0f be       	out	0x3f, r0	; 63
    106a:	be 01       	movw	r22, r28
    106c:	6c 5f       	subi	r22, 0xFC	; 252
    106e:	7f 4f       	sbci	r23, 0xFF	; 255
    1070:	ce 01       	movw	r24, r28
    1072:	01 96       	adiw	r24, 0x01	; 1
    1074:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <xTaskCheckForTimeOut>
    1078:	81 11       	cpse	r24, r1
    107a:	1f c0       	rjmp	.+62     	; 0x10ba <xQueueGenericSend+0x104>
    107c:	0f b6       	in	r0, 0x3f	; 63
    107e:	f8 94       	cli
    1080:	0f 92       	push	r0
    1082:	f8 01       	movw	r30, r16
    1084:	92 8d       	ldd	r25, Z+26	; 0x1a
    1086:	0f 90       	pop	r0
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	83 8d       	ldd	r24, Z+27	; 0x1b
    108c:	98 13       	cpse	r25, r24
    108e:	0f c0       	rjmp	.+30     	; 0x10ae <xQueueGenericSend+0xf8>
    1090:	6c 81       	ldd	r22, Y+4	; 0x04
    1092:	7d 81       	ldd	r23, Y+5	; 0x05
    1094:	c7 01       	movw	r24, r14
    1096:	0e 94 59 0d 	call	0x1ab2	; 0x1ab2 <vTaskPlaceOnEventList>
    109a:	c8 01       	movw	r24, r16
    109c:	0e 94 13 07 	call	0xe26	; 0xe26 <prvUnlockQueue>
    10a0:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xTaskResumeAll>
    10a4:	81 11       	cpse	r24, r1
    10a6:	a3 cf       	rjmp	.-186    	; 0xfee <xQueueGenericSend+0x38>
    10a8:	0e 94 0c 06 	call	0xc18	; 0xc18 <vPortYield>
    10ac:	a0 cf       	rjmp	.-192    	; 0xfee <xQueueGenericSend+0x38>
    10ae:	c8 01       	movw	r24, r16
    10b0:	0e 94 13 07 	call	0xe26	; 0xe26 <prvUnlockQueue>
    10b4:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xTaskResumeAll>
    10b8:	9a cf       	rjmp	.-204    	; 0xfee <xQueueGenericSend+0x38>
    10ba:	c8 01       	movw	r24, r16
    10bc:	0e 94 13 07 	call	0xe26	; 0xe26 <prvUnlockQueue>
    10c0:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xTaskResumeAll>
    10c4:	80 e0       	ldi	r24, 0x00	; 0
    10c6:	0f 90       	pop	r0
    10c8:	0f 90       	pop	r0
    10ca:	0f 90       	pop	r0
    10cc:	0f 90       	pop	r0
    10ce:	0f 90       	pop	r0
    10d0:	df 91       	pop	r29
    10d2:	cf 91       	pop	r28
    10d4:	1f 91       	pop	r17
    10d6:	0f 91       	pop	r16
    10d8:	ff 90       	pop	r15
    10da:	ef 90       	pop	r14
    10dc:	df 90       	pop	r13
    10de:	cf 90       	pop	r12
    10e0:	bf 90       	pop	r11
    10e2:	af 90       	pop	r10
    10e4:	9f 90       	pop	r9
    10e6:	08 95       	ret

000010e8 <xQueueSemaphoreTake>:
    10e8:	cf 92       	push	r12
    10ea:	df 92       	push	r13
    10ec:	ef 92       	push	r14
    10ee:	ff 92       	push	r15
    10f0:	0f 93       	push	r16
    10f2:	1f 93       	push	r17
    10f4:	cf 93       	push	r28
    10f6:	df 93       	push	r29
    10f8:	00 d0       	rcall	.+0      	; 0x10fa <xQueueSemaphoreTake+0x12>
    10fa:	00 d0       	rcall	.+0      	; 0x10fc <xQueueSemaphoreTake+0x14>
    10fc:	1f 92       	push	r1
    10fe:	cd b7       	in	r28, 0x3d	; 61
    1100:	de b7       	in	r29, 0x3e	; 62
    1102:	8c 01       	movw	r16, r24
    1104:	7d 83       	std	Y+5, r23	; 0x05
    1106:	6c 83       	std	Y+4, r22	; 0x04
    1108:	d1 2c       	mov	r13, r1
    110a:	cc 24       	eor	r12, r12
    110c:	c3 94       	inc	r12
    110e:	7c 01       	movw	r14, r24
    1110:	81 e1       	ldi	r24, 0x11	; 17
    1112:	e8 0e       	add	r14, r24
    1114:	f1 1c       	adc	r15, r1
    1116:	0f b6       	in	r0, 0x3f	; 63
    1118:	f8 94       	cli
    111a:	0f 92       	push	r0
    111c:	f8 01       	movw	r30, r16
    111e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1120:	88 23       	and	r24, r24
    1122:	69 f0       	breq	.+26     	; 0x113e <xQueueSemaphoreTake+0x56>
    1124:	81 50       	subi	r24, 0x01	; 1
    1126:	82 8f       	std	Z+26, r24	; 0x1a
    1128:	80 85       	ldd	r24, Z+8	; 0x08
    112a:	88 23       	and	r24, r24
    112c:	21 f0       	breq	.+8      	; 0x1136 <xQueueSemaphoreTake+0x4e>
    112e:	c8 01       	movw	r24, r16
    1130:	08 96       	adiw	r24, 0x08	; 8
    1132:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <xTaskRemoveFromEventList>
    1136:	0f 90       	pop	r0
    1138:	0f be       	out	0x3f, r0	; 63
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	51 c0       	rjmp	.+162    	; 0x11e0 <xQueueSemaphoreTake+0xf8>
    113e:	8c 81       	ldd	r24, Y+4	; 0x04
    1140:	9d 81       	ldd	r25, Y+5	; 0x05
    1142:	89 2b       	or	r24, r25
    1144:	21 f4       	brne	.+8      	; 0x114e <xQueueSemaphoreTake+0x66>
    1146:	0f 90       	pop	r0
    1148:	0f be       	out	0x3f, r0	; 63
    114a:	80 e0       	ldi	r24, 0x00	; 0
    114c:	49 c0       	rjmp	.+146    	; 0x11e0 <xQueueSemaphoreTake+0xf8>
    114e:	d1 10       	cpse	r13, r1
    1150:	05 c0       	rjmp	.+10     	; 0x115c <xQueueSemaphoreTake+0x74>
    1152:	ce 01       	movw	r24, r28
    1154:	01 96       	adiw	r24, 0x01	; 1
    1156:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <vTaskInternalSetTimeOutState>
    115a:	dc 2c       	mov	r13, r12
    115c:	0f 90       	pop	r0
    115e:	0f be       	out	0x3f, r0	; 63
    1160:	0e 94 28 0b 	call	0x1650	; 0x1650 <vTaskSuspendAll>
    1164:	0f b6       	in	r0, 0x3f	; 63
    1166:	f8 94       	cli
    1168:	0f 92       	push	r0
    116a:	f8 01       	movw	r30, r16
    116c:	85 8d       	ldd	r24, Z+29	; 0x1d
    116e:	8f 3f       	cpi	r24, 0xFF	; 255
    1170:	09 f4       	brne	.+2      	; 0x1174 <xQueueSemaphoreTake+0x8c>
    1172:	15 8e       	std	Z+29, r1	; 0x1d
    1174:	f8 01       	movw	r30, r16
    1176:	86 8d       	ldd	r24, Z+30	; 0x1e
    1178:	8f 3f       	cpi	r24, 0xFF	; 255
    117a:	09 f4       	brne	.+2      	; 0x117e <xQueueSemaphoreTake+0x96>
    117c:	16 8e       	std	Z+30, r1	; 0x1e
    117e:	0f 90       	pop	r0
    1180:	0f be       	out	0x3f, r0	; 63
    1182:	be 01       	movw	r22, r28
    1184:	6c 5f       	subi	r22, 0xFC	; 252
    1186:	7f 4f       	sbci	r23, 0xFF	; 255
    1188:	ce 01       	movw	r24, r28
    118a:	01 96       	adiw	r24, 0x01	; 1
    118c:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <xTaskCheckForTimeOut>
    1190:	81 11       	cpse	r24, r1
    1192:	1a c0       	rjmp	.+52     	; 0x11c8 <xQueueSemaphoreTake+0xe0>
    1194:	c8 01       	movw	r24, r16
    1196:	0e 94 bf 06 	call	0xd7e	; 0xd7e <prvIsQueueEmpty>
    119a:	88 23       	and	r24, r24
    119c:	79 f0       	breq	.+30     	; 0x11bc <xQueueSemaphoreTake+0xd4>
    119e:	6c 81       	ldd	r22, Y+4	; 0x04
    11a0:	7d 81       	ldd	r23, Y+5	; 0x05
    11a2:	c7 01       	movw	r24, r14
    11a4:	0e 94 59 0d 	call	0x1ab2	; 0x1ab2 <vTaskPlaceOnEventList>
    11a8:	c8 01       	movw	r24, r16
    11aa:	0e 94 13 07 	call	0xe26	; 0xe26 <prvUnlockQueue>
    11ae:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xTaskResumeAll>
    11b2:	81 11       	cpse	r24, r1
    11b4:	b0 cf       	rjmp	.-160    	; 0x1116 <xQueueSemaphoreTake+0x2e>
    11b6:	0e 94 0c 06 	call	0xc18	; 0xc18 <vPortYield>
    11ba:	ad cf       	rjmp	.-166    	; 0x1116 <xQueueSemaphoreTake+0x2e>
    11bc:	c8 01       	movw	r24, r16
    11be:	0e 94 13 07 	call	0xe26	; 0xe26 <prvUnlockQueue>
    11c2:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xTaskResumeAll>
    11c6:	a7 cf       	rjmp	.-178    	; 0x1116 <xQueueSemaphoreTake+0x2e>
    11c8:	c8 01       	movw	r24, r16
    11ca:	0e 94 13 07 	call	0xe26	; 0xe26 <prvUnlockQueue>
    11ce:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xTaskResumeAll>
    11d2:	c8 01       	movw	r24, r16
    11d4:	0e 94 bf 06 	call	0xd7e	; 0xd7e <prvIsQueueEmpty>
    11d8:	88 23       	and	r24, r24
    11da:	09 f4       	brne	.+2      	; 0x11de <xQueueSemaphoreTake+0xf6>
    11dc:	9c cf       	rjmp	.-200    	; 0x1116 <xQueueSemaphoreTake+0x2e>
    11de:	80 e0       	ldi	r24, 0x00	; 0
    11e0:	0f 90       	pop	r0
    11e2:	0f 90       	pop	r0
    11e4:	0f 90       	pop	r0
    11e6:	0f 90       	pop	r0
    11e8:	0f 90       	pop	r0
    11ea:	df 91       	pop	r29
    11ec:	cf 91       	pop	r28
    11ee:	1f 91       	pop	r17
    11f0:	0f 91       	pop	r16
    11f2:	ff 90       	pop	r15
    11f4:	ef 90       	pop	r14
    11f6:	df 90       	pop	r13
    11f8:	cf 90       	pop	r12
    11fa:	08 95       	ret

000011fc <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    11fc:	0f b6       	in	r0, 0x3f	; 63
    11fe:	f8 94       	cli
    1200:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1202:	fc 01       	movw	r30, r24
    1204:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1206:	0f 90       	pop	r0
    1208:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    120a:	08 95       	ret

0000120c <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    120c:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxDelayedTaskList>
    1210:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxDelayedTaskList+0x1>
    1214:	80 81       	ld	r24, Z
    1216:	81 11       	cpse	r24, r1
    1218:	07 c0       	rjmp	.+14     	; 0x1228 <prvResetNextTaskUnblockTime+0x1c>
    121a:	8f ef       	ldi	r24, 0xFF	; 255
    121c:	9f ef       	ldi	r25, 0xFF	; 255
    121e:	90 93 bc 06 	sts	0x06BC, r25	; 0x8006bc <xNextTaskUnblockTime+0x1>
    1222:	80 93 bb 06 	sts	0x06BB, r24	; 0x8006bb <xNextTaskUnblockTime>
    1226:	08 95       	ret
    1228:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxDelayedTaskList>
    122c:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxDelayedTaskList+0x1>
    1230:	05 80       	ldd	r0, Z+5	; 0x05
    1232:	f6 81       	ldd	r31, Z+6	; 0x06
    1234:	e0 2d       	mov	r30, r0
    1236:	06 80       	ldd	r0, Z+6	; 0x06
    1238:	f7 81       	ldd	r31, Z+7	; 0x07
    123a:	e0 2d       	mov	r30, r0
    123c:	82 81       	ldd	r24, Z+2	; 0x02
    123e:	93 81       	ldd	r25, Z+3	; 0x03
    1240:	90 93 bc 06 	sts	0x06BC, r25	; 0x8006bc <xNextTaskUnblockTime+0x1>
    1244:	80 93 bb 06 	sts	0x06BB, r24	; 0x8006bb <xNextTaskUnblockTime>
    1248:	08 95       	ret

0000124a <prvIdleTask>:
    124a:	00 ed       	ldi	r16, 0xD0	; 208
    124c:	16 e0       	ldi	r17, 0x06	; 6
    124e:	80 91 cf 06 	lds	r24, 0x06CF	; 0x8006cf <uxDeletedTasksWaitingCleanUp>
    1252:	88 23       	and	r24, r24
    1254:	29 f1       	breq	.+74     	; 0x12a0 <prvIdleTask+0x56>
    1256:	0f b6       	in	r0, 0x3f	; 63
    1258:	f8 94       	cli
    125a:	0f 92       	push	r0
    125c:	d8 01       	movw	r26, r16
    125e:	15 96       	adiw	r26, 0x05	; 5
    1260:	ed 91       	ld	r30, X+
    1262:	fc 91       	ld	r31, X
    1264:	16 97       	sbiw	r26, 0x06	; 6
    1266:	c6 81       	ldd	r28, Z+6	; 0x06
    1268:	d7 81       	ldd	r29, Z+7	; 0x07
    126a:	ce 01       	movw	r24, r28
    126c:	02 96       	adiw	r24, 0x02	; 2
    126e:	0e 94 44 05 	call	0xa88	; 0xa88 <uxListRemove>
    1272:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <uxCurrentNumberOfTasks>
    1276:	81 50       	subi	r24, 0x01	; 1
    1278:	80 93 c5 06 	sts	0x06C5, r24	; 0x8006c5 <uxCurrentNumberOfTasks>
    127c:	80 91 cf 06 	lds	r24, 0x06CF	; 0x8006cf <uxDeletedTasksWaitingCleanUp>
    1280:	81 50       	subi	r24, 0x01	; 1
    1282:	80 93 cf 06 	sts	0x06CF, r24	; 0x8006cf <uxDeletedTasksWaitingCleanUp>
    1286:	0f 90       	pop	r0
    1288:	0f be       	out	0x3f, r0	; 63
    128a:	8f 89       	ldd	r24, Y+23	; 0x17
    128c:	98 8d       	ldd	r25, Y+24	; 0x18
    128e:	0e 94 be 06 	call	0xd7c	; 0xd7c <vPortFree>
    1292:	ce 01       	movw	r24, r28
    1294:	0e 94 be 06 	call	0xd7c	; 0xd7c <vPortFree>
    1298:	80 91 cf 06 	lds	r24, 0x06CF	; 0x8006cf <uxDeletedTasksWaitingCleanUp>
    129c:	81 11       	cpse	r24, r1
    129e:	db cf       	rjmp	.-74     	; 0x1256 <prvIdleTask+0xc>
    12a0:	0e 94 0c 06 	call	0xc18	; 0xc18 <vPortYield>
    12a4:	d4 cf       	rjmp	.-88     	; 0x124e <prvIdleTask+0x4>

000012a6 <prvAddCurrentTaskToDelayedList>:
    12a6:	ff 92       	push	r15
    12a8:	0f 93       	push	r16
    12aa:	1f 93       	push	r17
    12ac:	cf 93       	push	r28
    12ae:	df 93       	push	r29
    12b0:	ec 01       	movw	r28, r24
    12b2:	f6 2e       	mov	r15, r22
    12b4:	00 91 c3 06 	lds	r16, 0x06C3	; 0x8006c3 <xTickCount>
    12b8:	10 91 c4 06 	lds	r17, 0x06C4	; 0x8006c4 <xTickCount+0x1>
    12bc:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <pxCurrentTCB>
    12c0:	90 91 26 07 	lds	r25, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    12c4:	02 96       	adiw	r24, 0x02	; 2
    12c6:	0e 94 44 05 	call	0xa88	; 0xa88 <uxListRemove>
    12ca:	cf 3f       	cpi	r28, 0xFF	; 255
    12cc:	8f ef       	ldi	r24, 0xFF	; 255
    12ce:	d8 07       	cpc	r29, r24
    12d0:	69 f4       	brne	.+26     	; 0x12ec <prvAddCurrentTaskToDelayedList+0x46>
    12d2:	ff 20       	and	r15, r15
    12d4:	59 f0       	breq	.+22     	; 0x12ec <prvAddCurrentTaskToDelayedList+0x46>
    12d6:	60 91 25 07 	lds	r22, 0x0725	; 0x800725 <pxCurrentTCB>
    12da:	70 91 26 07 	lds	r23, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    12de:	6e 5f       	subi	r22, 0xFE	; 254
    12e0:	7f 4f       	sbci	r23, 0xFF	; 255
    12e2:	86 ec       	ldi	r24, 0xC6	; 198
    12e4:	96 e0       	ldi	r25, 0x06	; 6
    12e6:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <vListInsertEnd>
    12ea:	2f c0       	rjmp	.+94     	; 0x134a <prvAddCurrentTaskToDelayedList+0xa4>
    12ec:	c0 0f       	add	r28, r16
    12ee:	d1 1f       	adc	r29, r17
    12f0:	e0 91 25 07 	lds	r30, 0x0725	; 0x800725 <pxCurrentTCB>
    12f4:	f0 91 26 07 	lds	r31, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    12f8:	d3 83       	std	Z+3, r29	; 0x03
    12fa:	c2 83       	std	Z+2, r28	; 0x02
    12fc:	c0 17       	cp	r28, r16
    12fe:	d1 07       	cpc	r29, r17
    1300:	68 f4       	brcc	.+26     	; 0x131c <prvAddCurrentTaskToDelayedList+0x76>
    1302:	60 91 25 07 	lds	r22, 0x0725	; 0x800725 <pxCurrentTCB>
    1306:	70 91 26 07 	lds	r23, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    130a:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <pxOverflowDelayedTaskList>
    130e:	90 91 e3 06 	lds	r25, 0x06E3	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    1312:	6e 5f       	subi	r22, 0xFE	; 254
    1314:	7f 4f       	sbci	r23, 0xFF	; 255
    1316:	0e 94 13 05 	call	0xa26	; 0xa26 <vListInsert>
    131a:	17 c0       	rjmp	.+46     	; 0x134a <prvAddCurrentTaskToDelayedList+0xa4>
    131c:	60 91 25 07 	lds	r22, 0x0725	; 0x800725 <pxCurrentTCB>
    1320:	70 91 26 07 	lds	r23, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    1324:	80 91 e4 06 	lds	r24, 0x06E4	; 0x8006e4 <pxDelayedTaskList>
    1328:	90 91 e5 06 	lds	r25, 0x06E5	; 0x8006e5 <pxDelayedTaskList+0x1>
    132c:	6e 5f       	subi	r22, 0xFE	; 254
    132e:	7f 4f       	sbci	r23, 0xFF	; 255
    1330:	0e 94 13 05 	call	0xa26	; 0xa26 <vListInsert>
    1334:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <xNextTaskUnblockTime>
    1338:	90 91 bc 06 	lds	r25, 0x06BC	; 0x8006bc <xNextTaskUnblockTime+0x1>
    133c:	c8 17       	cp	r28, r24
    133e:	d9 07       	cpc	r29, r25
    1340:	20 f4       	brcc	.+8      	; 0x134a <prvAddCurrentTaskToDelayedList+0xa4>
    1342:	d0 93 bc 06 	sts	0x06BC, r29	; 0x8006bc <xNextTaskUnblockTime+0x1>
    1346:	c0 93 bb 06 	sts	0x06BB, r28	; 0x8006bb <xNextTaskUnblockTime>
    134a:	df 91       	pop	r29
    134c:	cf 91       	pop	r28
    134e:	1f 91       	pop	r17
    1350:	0f 91       	pop	r16
    1352:	ff 90       	pop	r15
    1354:	08 95       	ret

00001356 <xTaskCreate>:
    1356:	4f 92       	push	r4
    1358:	5f 92       	push	r5
    135a:	6f 92       	push	r6
    135c:	7f 92       	push	r7
    135e:	8f 92       	push	r8
    1360:	9f 92       	push	r9
    1362:	af 92       	push	r10
    1364:	bf 92       	push	r11
    1366:	cf 92       	push	r12
    1368:	df 92       	push	r13
    136a:	ef 92       	push	r14
    136c:	ff 92       	push	r15
    136e:	0f 93       	push	r16
    1370:	1f 93       	push	r17
    1372:	cf 93       	push	r28
    1374:	df 93       	push	r29
    1376:	4c 01       	movw	r8, r24
    1378:	6b 01       	movw	r12, r22
    137a:	5a 01       	movw	r10, r20
    137c:	29 01       	movw	r4, r18
    137e:	ca 01       	movw	r24, r20
    1380:	0e 94 89 06 	call	0xd12	; 0xd12 <pvPortMalloc>
    1384:	3c 01       	movw	r6, r24
    1386:	89 2b       	or	r24, r25
    1388:	09 f4       	brne	.+2      	; 0x138c <xTaskCreate+0x36>
    138a:	df c0       	rjmp	.+446    	; 0x154a <xTaskCreate+0x1f4>
    138c:	86 e2       	ldi	r24, 0x26	; 38
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	0e 94 89 06 	call	0xd12	; 0xd12 <pvPortMalloc>
    1394:	ec 01       	movw	r28, r24
    1396:	89 2b       	or	r24, r25
    1398:	59 f0       	breq	.+22     	; 0x13b0 <xTaskCreate+0x5a>
    139a:	78 8e       	std	Y+24, r7	; 0x18
    139c:	6f 8a       	std	Y+23, r6	; 0x17
    139e:	81 e0       	ldi	r24, 0x01	; 1
    13a0:	a8 1a       	sub	r10, r24
    13a2:	b1 08       	sbc	r11, r1
    13a4:	a6 0c       	add	r10, r6
    13a6:	b7 1c       	adc	r11, r7
    13a8:	c1 14       	cp	r12, r1
    13aa:	d1 04       	cpc	r13, r1
    13ac:	29 f4       	brne	.+10     	; 0x13b8 <xTaskCreate+0x62>
    13ae:	20 c0       	rjmp	.+64     	; 0x13f0 <xTaskCreate+0x9a>
    13b0:	c3 01       	movw	r24, r6
    13b2:	0e 94 be 06 	call	0xd7c	; 0xd7c <vPortFree>
    13b6:	c9 c0       	rjmp	.+402    	; 0x154a <xTaskCreate+0x1f4>
    13b8:	d6 01       	movw	r26, r12
    13ba:	8c 91       	ld	r24, X
    13bc:	89 8f       	std	Y+25, r24	; 0x19
    13be:	8c 91       	ld	r24, X
    13c0:	88 23       	and	r24, r24
    13c2:	a1 f0       	breq	.+40     	; 0x13ec <xTaskCreate+0x96>
    13c4:	ae 01       	movw	r20, r28
    13c6:	46 5e       	subi	r20, 0xE6	; 230
    13c8:	5f 4f       	sbci	r21, 0xFF	; 255
    13ca:	f6 01       	movw	r30, r12
    13cc:	31 96       	adiw	r30, 0x01	; 1
    13ce:	b8 e0       	ldi	r27, 0x08	; 8
    13d0:	cb 0e       	add	r12, r27
    13d2:	d1 1c       	adc	r13, r1
    13d4:	cf 01       	movw	r24, r30
    13d6:	21 91       	ld	r18, Z+
    13d8:	da 01       	movw	r26, r20
    13da:	2d 93       	st	X+, r18
    13dc:	ad 01       	movw	r20, r26
    13de:	dc 01       	movw	r26, r24
    13e0:	8c 91       	ld	r24, X
    13e2:	88 23       	and	r24, r24
    13e4:	19 f0       	breq	.+6      	; 0x13ec <xTaskCreate+0x96>
    13e6:	ce 16       	cp	r12, r30
    13e8:	df 06       	cpc	r13, r31
    13ea:	a1 f7       	brne	.-24     	; 0x13d4 <xTaskCreate+0x7e>
    13ec:	18 a2       	std	Y+32, r1	; 0x20
    13ee:	01 c0       	rjmp	.+2      	; 0x13f2 <xTaskCreate+0x9c>
    13f0:	19 8e       	std	Y+25, r1	; 0x19
    13f2:	05 30       	cpi	r16, 0x05	; 5
    13f4:	08 f0       	brcs	.+2      	; 0x13f8 <xTaskCreate+0xa2>
    13f6:	04 e0       	ldi	r16, 0x04	; 4
    13f8:	0e 8b       	std	Y+22, r16	; 0x16
    13fa:	6e 01       	movw	r12, r28
    13fc:	b2 e0       	ldi	r27, 0x02	; 2
    13fe:	cb 0e       	add	r12, r27
    1400:	d1 1c       	adc	r13, r1
    1402:	c6 01       	movw	r24, r12
    1404:	0e 94 ee 04 	call	0x9dc	; 0x9dc <vListInitialiseItem>
    1408:	ce 01       	movw	r24, r28
    140a:	0c 96       	adiw	r24, 0x0c	; 12
    140c:	0e 94 ee 04 	call	0x9dc	; 0x9dc <vListInitialiseItem>
    1410:	d9 87       	std	Y+9, r29	; 0x09
    1412:	c8 87       	std	Y+8, r28	; 0x08
    1414:	85 e0       	ldi	r24, 0x05	; 5
    1416:	90 e0       	ldi	r25, 0x00	; 0
    1418:	80 1b       	sub	r24, r16
    141a:	91 09       	sbc	r25, r1
    141c:	9d 87       	std	Y+13, r25	; 0x0d
    141e:	8c 87       	std	Y+12, r24	; 0x0c
    1420:	db 8b       	std	Y+19, r29	; 0x13
    1422:	ca 8b       	std	Y+18, r28	; 0x12
    1424:	19 a2       	std	Y+33, r1	; 0x21
    1426:	1a a2       	std	Y+34, r1	; 0x22
    1428:	1b a2       	std	Y+35, r1	; 0x23
    142a:	1c a2       	std	Y+36, r1	; 0x24
    142c:	1d a2       	std	Y+37, r1	; 0x25
    142e:	a2 01       	movw	r20, r4
    1430:	b4 01       	movw	r22, r8
    1432:	c5 01       	movw	r24, r10
    1434:	0e 94 6b 05 	call	0xad6	; 0xad6 <pxPortInitialiseStack>
    1438:	99 83       	std	Y+1, r25	; 0x01
    143a:	88 83       	st	Y, r24
    143c:	e1 14       	cp	r14, r1
    143e:	f1 04       	cpc	r15, r1
    1440:	19 f0       	breq	.+6      	; 0x1448 <xTaskCreate+0xf2>
    1442:	f7 01       	movw	r30, r14
    1444:	d1 83       	std	Z+1, r29	; 0x01
    1446:	c0 83       	st	Z, r28
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	f8 94       	cli
    144c:	0f 92       	push	r0
    144e:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <uxCurrentNumberOfTasks>
    1452:	8f 5f       	subi	r24, 0xFF	; 255
    1454:	80 93 c5 06 	sts	0x06C5, r24	; 0x8006c5 <uxCurrentNumberOfTasks>
    1458:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <pxCurrentTCB>
    145c:	90 91 26 07 	lds	r25, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    1460:	89 2b       	or	r24, r25
    1462:	d1 f5       	brne	.+116    	; 0x14d8 <xTaskCreate+0x182>
    1464:	d0 93 26 07 	sts	0x0726, r29	; 0x800726 <pxCurrentTCB+0x1>
    1468:	c0 93 25 07 	sts	0x0725, r28	; 0x800725 <pxCurrentTCB>
    146c:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <uxCurrentNumberOfTasks>
    1470:	81 30       	cpi	r24, 0x01	; 1
    1472:	09 f0       	breq	.+2      	; 0x1476 <xTaskCreate+0x120>
    1474:	41 c0       	rjmp	.+130    	; 0x14f8 <xTaskCreate+0x1a2>
    1476:	08 ef       	ldi	r16, 0xF8	; 248
    1478:	16 e0       	ldi	r17, 0x06	; 6
    147a:	0f 2e       	mov	r0, r31
    147c:	f5 e2       	ldi	r31, 0x25	; 37
    147e:	ef 2e       	mov	r14, r31
    1480:	f7 e0       	ldi	r31, 0x07	; 7
    1482:	ff 2e       	mov	r15, r31
    1484:	f0 2d       	mov	r31, r0
    1486:	c8 01       	movw	r24, r16
    1488:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <vListInitialise>
    148c:	07 5f       	subi	r16, 0xF7	; 247
    148e:	1f 4f       	sbci	r17, 0xFF	; 255
    1490:	0e 15       	cp	r16, r14
    1492:	1f 05       	cpc	r17, r15
    1494:	c1 f7       	brne	.-16     	; 0x1486 <xTaskCreate+0x130>
    1496:	8f ee       	ldi	r24, 0xEF	; 239
    1498:	96 e0       	ldi	r25, 0x06	; 6
    149a:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <vListInitialise>
    149e:	86 ee       	ldi	r24, 0xE6	; 230
    14a0:	96 e0       	ldi	r25, 0x06	; 6
    14a2:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <vListInitialise>
    14a6:	89 ed       	ldi	r24, 0xD9	; 217
    14a8:	96 e0       	ldi	r25, 0x06	; 6
    14aa:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <vListInitialise>
    14ae:	80 ed       	ldi	r24, 0xD0	; 208
    14b0:	96 e0       	ldi	r25, 0x06	; 6
    14b2:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <vListInitialise>
    14b6:	86 ec       	ldi	r24, 0xC6	; 198
    14b8:	96 e0       	ldi	r25, 0x06	; 6
    14ba:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <vListInitialise>
    14be:	8f ee       	ldi	r24, 0xEF	; 239
    14c0:	96 e0       	ldi	r25, 0x06	; 6
    14c2:	90 93 e5 06 	sts	0x06E5, r25	; 0x8006e5 <pxDelayedTaskList+0x1>
    14c6:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <pxDelayedTaskList>
    14ca:	86 ee       	ldi	r24, 0xE6	; 230
    14cc:	96 e0       	ldi	r25, 0x06	; 6
    14ce:	90 93 e3 06 	sts	0x06E3, r25	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    14d2:	80 93 e2 06 	sts	0x06E2, r24	; 0x8006e2 <pxOverflowDelayedTaskList>
    14d6:	10 c0       	rjmp	.+32     	; 0x14f8 <xTaskCreate+0x1a2>
    14d8:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <xSchedulerRunning>
    14dc:	81 11       	cpse	r24, r1
    14de:	0c c0       	rjmp	.+24     	; 0x14f8 <xTaskCreate+0x1a2>
    14e0:	e0 91 25 07 	lds	r30, 0x0725	; 0x800725 <pxCurrentTCB>
    14e4:	f0 91 26 07 	lds	r31, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    14e8:	96 89       	ldd	r25, Z+22	; 0x16
    14ea:	8e 89       	ldd	r24, Y+22	; 0x16
    14ec:	89 17       	cp	r24, r25
    14ee:	20 f0       	brcs	.+8      	; 0x14f8 <xTaskCreate+0x1a2>
    14f0:	d0 93 26 07 	sts	0x0726, r29	; 0x800726 <pxCurrentTCB+0x1>
    14f4:	c0 93 25 07 	sts	0x0725, r28	; 0x800725 <pxCurrentTCB>
    14f8:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <uxTaskNumber>
    14fc:	8f 5f       	subi	r24, 0xFF	; 255
    14fe:	80 93 bd 06 	sts	0x06BD, r24	; 0x8006bd <uxTaskNumber>
    1502:	8e 89       	ldd	r24, Y+22	; 0x16
    1504:	90 91 c2 06 	lds	r25, 0x06C2	; 0x8006c2 <uxTopReadyPriority>
    1508:	98 17       	cp	r25, r24
    150a:	10 f4       	brcc	.+4      	; 0x1510 <xTaskCreate+0x1ba>
    150c:	80 93 c2 06 	sts	0x06C2, r24	; 0x8006c2 <uxTopReadyPriority>
    1510:	90 e0       	ldi	r25, 0x00	; 0
    1512:	9c 01       	movw	r18, r24
    1514:	22 0f       	add	r18, r18
    1516:	33 1f       	adc	r19, r19
    1518:	22 0f       	add	r18, r18
    151a:	33 1f       	adc	r19, r19
    151c:	22 0f       	add	r18, r18
    151e:	33 1f       	adc	r19, r19
    1520:	82 0f       	add	r24, r18
    1522:	93 1f       	adc	r25, r19
    1524:	b6 01       	movw	r22, r12
    1526:	88 50       	subi	r24, 0x08	; 8
    1528:	99 4f       	sbci	r25, 0xF9	; 249
    152a:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <vListInsertEnd>
    152e:	0f 90       	pop	r0
    1530:	0f be       	out	0x3f, r0	; 63
    1532:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <xSchedulerRunning>
    1536:	88 23       	and	r24, r24
    1538:	31 f0       	breq	.+12     	; 0x1546 <xTaskCreate+0x1f0>
    153a:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <pxCurrentTCB>
    153e:	90 91 26 07 	lds	r25, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    1542:	81 e0       	ldi	r24, 0x01	; 1
    1544:	03 c0       	rjmp	.+6      	; 0x154c <xTaskCreate+0x1f6>
    1546:	81 e0       	ldi	r24, 0x01	; 1
    1548:	01 c0       	rjmp	.+2      	; 0x154c <xTaskCreate+0x1f6>
    154a:	8f ef       	ldi	r24, 0xFF	; 255
    154c:	df 91       	pop	r29
    154e:	cf 91       	pop	r28
    1550:	1f 91       	pop	r17
    1552:	0f 91       	pop	r16
    1554:	ff 90       	pop	r15
    1556:	ef 90       	pop	r14
    1558:	df 90       	pop	r13
    155a:	cf 90       	pop	r12
    155c:	bf 90       	pop	r11
    155e:	af 90       	pop	r10
    1560:	9f 90       	pop	r9
    1562:	8f 90       	pop	r8
    1564:	7f 90       	pop	r7
    1566:	6f 90       	pop	r6
    1568:	5f 90       	pop	r5
    156a:	4f 90       	pop	r4
    156c:	08 95       	ret

0000156e <vTaskResume>:
    156e:	0f 93       	push	r16
    1570:	1f 93       	push	r17
    1572:	cf 93       	push	r28
    1574:	df 93       	push	r29
    1576:	20 91 25 07 	lds	r18, 0x0725	; 0x800725 <pxCurrentTCB>
    157a:	30 91 26 07 	lds	r19, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    157e:	82 17       	cp	r24, r18
    1580:	93 07       	cpc	r25, r19
    1582:	b9 f1       	breq	.+110    	; 0x15f2 <vTaskResume+0x84>
    1584:	00 97       	sbiw	r24, 0x00	; 0
    1586:	a9 f1       	breq	.+106    	; 0x15f2 <vTaskResume+0x84>
    1588:	0f b6       	in	r0, 0x3f	; 63
    158a:	f8 94       	cli
    158c:	0f 92       	push	r0
    158e:	fc 01       	movw	r30, r24
    1590:	22 85       	ldd	r18, Z+10	; 0x0a
    1592:	33 85       	ldd	r19, Z+11	; 0x0b
    1594:	26 5c       	subi	r18, 0xC6	; 198
    1596:	36 40       	sbci	r19, 0x06	; 6
    1598:	51 f5       	brne	.+84     	; 0x15ee <vTaskResume+0x80>
    159a:	fc 01       	movw	r30, r24
    159c:	24 89       	ldd	r18, Z+20	; 0x14
    159e:	35 89       	ldd	r19, Z+21	; 0x15
    15a0:	f6 e0       	ldi	r31, 0x06	; 6
    15a2:	29 3d       	cpi	r18, 0xD9	; 217
    15a4:	3f 07       	cpc	r19, r31
    15a6:	19 f1       	breq	.+70     	; 0x15ee <vTaskResume+0x80>
    15a8:	23 2b       	or	r18, r19
    15aa:	09 f5       	brne	.+66     	; 0x15ee <vTaskResume+0x80>
    15ac:	ec 01       	movw	r28, r24
    15ae:	8c 01       	movw	r16, r24
    15b0:	0e 5f       	subi	r16, 0xFE	; 254
    15b2:	1f 4f       	sbci	r17, 0xFF	; 255
    15b4:	c8 01       	movw	r24, r16
    15b6:	0e 94 44 05 	call	0xa88	; 0xa88 <uxListRemove>
    15ba:	8e 89       	ldd	r24, Y+22	; 0x16
    15bc:	90 91 c2 06 	lds	r25, 0x06C2	; 0x8006c2 <uxTopReadyPriority>
    15c0:	98 17       	cp	r25, r24
    15c2:	10 f4       	brcc	.+4      	; 0x15c8 <vTaskResume+0x5a>
    15c4:	80 93 c2 06 	sts	0x06C2, r24	; 0x8006c2 <uxTopReadyPriority>
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	9c 01       	movw	r18, r24
    15cc:	22 0f       	add	r18, r18
    15ce:	33 1f       	adc	r19, r19
    15d0:	22 0f       	add	r18, r18
    15d2:	33 1f       	adc	r19, r19
    15d4:	22 0f       	add	r18, r18
    15d6:	33 1f       	adc	r19, r19
    15d8:	82 0f       	add	r24, r18
    15da:	93 1f       	adc	r25, r19
    15dc:	b8 01       	movw	r22, r16
    15de:	88 50       	subi	r24, 0x08	; 8
    15e0:	99 4f       	sbci	r25, 0xF9	; 249
    15e2:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <vListInsertEnd>
    15e6:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <pxCurrentTCB>
    15ea:	90 91 26 07 	lds	r25, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    15ee:	0f 90       	pop	r0
    15f0:	0f be       	out	0x3f, r0	; 63
    15f2:	df 91       	pop	r29
    15f4:	cf 91       	pop	r28
    15f6:	1f 91       	pop	r17
    15f8:	0f 91       	pop	r16
    15fa:	08 95       	ret

000015fc <vTaskStartScheduler>:
    15fc:	ef 92       	push	r14
    15fe:	ff 92       	push	r15
    1600:	0f 93       	push	r16
    1602:	0f 2e       	mov	r0, r31
    1604:	f9 eb       	ldi	r31, 0xB9	; 185
    1606:	ef 2e       	mov	r14, r31
    1608:	f6 e0       	ldi	r31, 0x06	; 6
    160a:	ff 2e       	mov	r15, r31
    160c:	f0 2d       	mov	r31, r0
    160e:	00 e0       	ldi	r16, 0x00	; 0
    1610:	20 e0       	ldi	r18, 0x00	; 0
    1612:	30 e0       	ldi	r19, 0x00	; 0
    1614:	45 e5       	ldi	r20, 0x55	; 85
    1616:	50 e0       	ldi	r21, 0x00	; 0
    1618:	64 ec       	ldi	r22, 0xC4	; 196
    161a:	70 e0       	ldi	r23, 0x00	; 0
    161c:	85 e2       	ldi	r24, 0x25	; 37
    161e:	99 e0       	ldi	r25, 0x09	; 9
    1620:	0e 94 ab 09 	call	0x1356	; 0x1356 <xTaskCreate>
    1624:	81 30       	cpi	r24, 0x01	; 1
    1626:	81 f4       	brne	.+32     	; 0x1648 <vTaskStartScheduler+0x4c>
    1628:	f8 94       	cli
    162a:	8f ef       	ldi	r24, 0xFF	; 255
    162c:	9f ef       	ldi	r25, 0xFF	; 255
    162e:	90 93 bc 06 	sts	0x06BC, r25	; 0x8006bc <xNextTaskUnblockTime+0x1>
    1632:	80 93 bb 06 	sts	0x06BB, r24	; 0x8006bb <xNextTaskUnblockTime>
    1636:	81 e0       	ldi	r24, 0x01	; 1
    1638:	80 93 c1 06 	sts	0x06C1, r24	; 0x8006c1 <xSchedulerRunning>
    163c:	10 92 c4 06 	sts	0x06C4, r1	; 0x8006c4 <xTickCount+0x1>
    1640:	10 92 c3 06 	sts	0x06C3, r1	; 0x8006c3 <xTickCount>
    1644:	0e 94 d7 05 	call	0xbae	; 0xbae <xPortStartScheduler>
    1648:	0f 91       	pop	r16
    164a:	ff 90       	pop	r15
    164c:	ef 90       	pop	r14
    164e:	08 95       	ret

00001650 <vTaskSuspendAll>:
    1650:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <uxSchedulerSuspended>
    1654:	8f 5f       	subi	r24, 0xFF	; 255
    1656:	80 93 b8 06 	sts	0x06B8, r24	; 0x8006b8 <uxSchedulerSuspended>
    165a:	08 95       	ret

0000165c <xTaskGetTickCount>:
    165c:	0f b6       	in	r0, 0x3f	; 63
    165e:	f8 94       	cli
    1660:	0f 92       	push	r0
    1662:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <xTickCount>
    1666:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <xTickCount+0x1>
    166a:	0f 90       	pop	r0
    166c:	0f be       	out	0x3f, r0	; 63
    166e:	08 95       	ret

00001670 <xTaskIncrementTick>:
    1670:	ef 92       	push	r14
    1672:	ff 92       	push	r15
    1674:	0f 93       	push	r16
    1676:	1f 93       	push	r17
    1678:	cf 93       	push	r28
    167a:	df 93       	push	r29
    167c:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <uxSchedulerSuspended>
    1680:	81 11       	cpse	r24, r1
    1682:	89 c0       	rjmp	.+274    	; 0x1796 <xTaskIncrementTick+0x126>
    1684:	e0 90 c3 06 	lds	r14, 0x06C3	; 0x8006c3 <xTickCount>
    1688:	f0 90 c4 06 	lds	r15, 0x06C4	; 0x8006c4 <xTickCount+0x1>
    168c:	8f ef       	ldi	r24, 0xFF	; 255
    168e:	e8 1a       	sub	r14, r24
    1690:	f8 0a       	sbc	r15, r24
    1692:	f0 92 c4 06 	sts	0x06C4, r15	; 0x8006c4 <xTickCount+0x1>
    1696:	e0 92 c3 06 	sts	0x06C3, r14	; 0x8006c3 <xTickCount>
    169a:	e1 14       	cp	r14, r1
    169c:	f1 04       	cpc	r15, r1
    169e:	b9 f4       	brne	.+46     	; 0x16ce <xTaskIncrementTick+0x5e>
    16a0:	80 91 e4 06 	lds	r24, 0x06E4	; 0x8006e4 <pxDelayedTaskList>
    16a4:	90 91 e5 06 	lds	r25, 0x06E5	; 0x8006e5 <pxDelayedTaskList+0x1>
    16a8:	20 91 e2 06 	lds	r18, 0x06E2	; 0x8006e2 <pxOverflowDelayedTaskList>
    16ac:	30 91 e3 06 	lds	r19, 0x06E3	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    16b0:	30 93 e5 06 	sts	0x06E5, r19	; 0x8006e5 <pxDelayedTaskList+0x1>
    16b4:	20 93 e4 06 	sts	0x06E4, r18	; 0x8006e4 <pxDelayedTaskList>
    16b8:	90 93 e3 06 	sts	0x06E3, r25	; 0x8006e3 <pxOverflowDelayedTaskList+0x1>
    16bc:	80 93 e2 06 	sts	0x06E2, r24	; 0x8006e2 <pxOverflowDelayedTaskList>
    16c0:	80 91 be 06 	lds	r24, 0x06BE	; 0x8006be <xNumOfOverflows>
    16c4:	8f 5f       	subi	r24, 0xFF	; 255
    16c6:	80 93 be 06 	sts	0x06BE, r24	; 0x8006be <xNumOfOverflows>
    16ca:	0e 94 06 09 	call	0x120c	; 0x120c <prvResetNextTaskUnblockTime>
    16ce:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <xNextTaskUnblockTime>
    16d2:	90 91 bc 06 	lds	r25, 0x06BC	; 0x8006bc <xNextTaskUnblockTime+0x1>
    16d6:	e8 16       	cp	r14, r24
    16d8:	f9 06       	cpc	r15, r25
    16da:	08 f4       	brcc	.+2      	; 0x16de <xTaskIncrementTick+0x6e>
    16dc:	61 c0       	rjmp	.+194    	; 0x17a0 <xTaskIncrementTick+0x130>
    16de:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxDelayedTaskList>
    16e2:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxDelayedTaskList+0x1>
    16e6:	80 81       	ld	r24, Z
    16e8:	88 23       	and	r24, r24
    16ea:	79 f0       	breq	.+30     	; 0x170a <xTaskIncrementTick+0x9a>
    16ec:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxDelayedTaskList>
    16f0:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxDelayedTaskList+0x1>
    16f4:	05 80       	ldd	r0, Z+5	; 0x05
    16f6:	f6 81       	ldd	r31, Z+6	; 0x06
    16f8:	e0 2d       	mov	r30, r0
    16fa:	c6 81       	ldd	r28, Z+6	; 0x06
    16fc:	d7 81       	ldd	r29, Z+7	; 0x07
    16fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1700:	9b 81       	ldd	r25, Y+3	; 0x03
    1702:	e8 16       	cp	r14, r24
    1704:	f9 06       	cpc	r15, r25
    1706:	d8 f4       	brcc	.+54     	; 0x173e <xTaskIncrementTick+0xce>
    1708:	15 c0       	rjmp	.+42     	; 0x1734 <xTaskIncrementTick+0xc4>
    170a:	8f ef       	ldi	r24, 0xFF	; 255
    170c:	9f ef       	ldi	r25, 0xFF	; 255
    170e:	90 93 bc 06 	sts	0x06BC, r25	; 0x8006bc <xNextTaskUnblockTime+0x1>
    1712:	80 93 bb 06 	sts	0x06BB, r24	; 0x8006bb <xNextTaskUnblockTime>
    1716:	44 c0       	rjmp	.+136    	; 0x17a0 <xTaskIncrementTick+0x130>
    1718:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxDelayedTaskList>
    171c:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxDelayedTaskList+0x1>
    1720:	05 80       	ldd	r0, Z+5	; 0x05
    1722:	f6 81       	ldd	r31, Z+6	; 0x06
    1724:	e0 2d       	mov	r30, r0
    1726:	c6 81       	ldd	r28, Z+6	; 0x06
    1728:	d7 81       	ldd	r29, Z+7	; 0x07
    172a:	8a 81       	ldd	r24, Y+2	; 0x02
    172c:	9b 81       	ldd	r25, Y+3	; 0x03
    172e:	e8 16       	cp	r14, r24
    1730:	f9 06       	cpc	r15, r25
    1732:	28 f4       	brcc	.+10     	; 0x173e <xTaskIncrementTick+0xce>
    1734:	90 93 bc 06 	sts	0x06BC, r25	; 0x8006bc <xNextTaskUnblockTime+0x1>
    1738:	80 93 bb 06 	sts	0x06BB, r24	; 0x8006bb <xNextTaskUnblockTime>
    173c:	31 c0       	rjmp	.+98     	; 0x17a0 <xTaskIncrementTick+0x130>
    173e:	8e 01       	movw	r16, r28
    1740:	0e 5f       	subi	r16, 0xFE	; 254
    1742:	1f 4f       	sbci	r17, 0xFF	; 255
    1744:	c8 01       	movw	r24, r16
    1746:	0e 94 44 05 	call	0xa88	; 0xa88 <uxListRemove>
    174a:	8c 89       	ldd	r24, Y+20	; 0x14
    174c:	9d 89       	ldd	r25, Y+21	; 0x15
    174e:	89 2b       	or	r24, r25
    1750:	21 f0       	breq	.+8      	; 0x175a <xTaskIncrementTick+0xea>
    1752:	ce 01       	movw	r24, r28
    1754:	0c 96       	adiw	r24, 0x0c	; 12
    1756:	0e 94 44 05 	call	0xa88	; 0xa88 <uxListRemove>
    175a:	8e 89       	ldd	r24, Y+22	; 0x16
    175c:	90 91 c2 06 	lds	r25, 0x06C2	; 0x8006c2 <uxTopReadyPriority>
    1760:	98 17       	cp	r25, r24
    1762:	10 f4       	brcc	.+4      	; 0x1768 <xTaskIncrementTick+0xf8>
    1764:	80 93 c2 06 	sts	0x06C2, r24	; 0x8006c2 <uxTopReadyPriority>
    1768:	90 e0       	ldi	r25, 0x00	; 0
    176a:	9c 01       	movw	r18, r24
    176c:	22 0f       	add	r18, r18
    176e:	33 1f       	adc	r19, r19
    1770:	22 0f       	add	r18, r18
    1772:	33 1f       	adc	r19, r19
    1774:	22 0f       	add	r18, r18
    1776:	33 1f       	adc	r19, r19
    1778:	82 0f       	add	r24, r18
    177a:	93 1f       	adc	r25, r19
    177c:	b8 01       	movw	r22, r16
    177e:	88 50       	subi	r24, 0x08	; 8
    1780:	99 4f       	sbci	r25, 0xF9	; 249
    1782:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <vListInsertEnd>
    1786:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxDelayedTaskList>
    178a:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxDelayedTaskList+0x1>
    178e:	80 81       	ld	r24, Z
    1790:	81 11       	cpse	r24, r1
    1792:	c2 cf       	rjmp	.-124    	; 0x1718 <xTaskIncrementTick+0xa8>
    1794:	ba cf       	rjmp	.-140    	; 0x170a <xTaskIncrementTick+0x9a>
    1796:	80 91 c0 06 	lds	r24, 0x06C0	; 0x8006c0 <uxPendedTicks>
    179a:	8f 5f       	subi	r24, 0xFF	; 255
    179c:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <uxPendedTicks>
    17a0:	80 e0       	ldi	r24, 0x00	; 0
    17a2:	df 91       	pop	r29
    17a4:	cf 91       	pop	r28
    17a6:	1f 91       	pop	r17
    17a8:	0f 91       	pop	r16
    17aa:	ff 90       	pop	r15
    17ac:	ef 90       	pop	r14
    17ae:	08 95       	ret

000017b0 <xTaskResumeAll>:
    17b0:	df 92       	push	r13
    17b2:	ef 92       	push	r14
    17b4:	ff 92       	push	r15
    17b6:	0f 93       	push	r16
    17b8:	1f 93       	push	r17
    17ba:	cf 93       	push	r28
    17bc:	df 93       	push	r29
    17be:	0f b6       	in	r0, 0x3f	; 63
    17c0:	f8 94       	cli
    17c2:	0f 92       	push	r0
    17c4:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <uxSchedulerSuspended>
    17c8:	81 50       	subi	r24, 0x01	; 1
    17ca:	80 93 b8 06 	sts	0x06B8, r24	; 0x8006b8 <uxSchedulerSuspended>
    17ce:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <uxSchedulerSuspended>
    17d2:	81 11       	cpse	r24, r1
    17d4:	59 c0       	rjmp	.+178    	; 0x1888 <xTaskResumeAll+0xd8>
    17d6:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <uxCurrentNumberOfTasks>
    17da:	81 11       	cpse	r24, r1
    17dc:	33 c0       	rjmp	.+102    	; 0x1844 <xTaskResumeAll+0x94>
    17de:	54 c0       	rjmp	.+168    	; 0x1888 <xTaskResumeAll+0xd8>
    17e0:	d7 01       	movw	r26, r14
    17e2:	15 96       	adiw	r26, 0x05	; 5
    17e4:	ed 91       	ld	r30, X+
    17e6:	fc 91       	ld	r31, X
    17e8:	16 97       	sbiw	r26, 0x06	; 6
    17ea:	c6 81       	ldd	r28, Z+6	; 0x06
    17ec:	d7 81       	ldd	r29, Z+7	; 0x07
    17ee:	ce 01       	movw	r24, r28
    17f0:	0c 96       	adiw	r24, 0x0c	; 12
    17f2:	0e 94 44 05 	call	0xa88	; 0xa88 <uxListRemove>
    17f6:	8e 01       	movw	r16, r28
    17f8:	0e 5f       	subi	r16, 0xFE	; 254
    17fa:	1f 4f       	sbci	r17, 0xFF	; 255
    17fc:	c8 01       	movw	r24, r16
    17fe:	0e 94 44 05 	call	0xa88	; 0xa88 <uxListRemove>
    1802:	8e 89       	ldd	r24, Y+22	; 0x16
    1804:	90 91 c2 06 	lds	r25, 0x06C2	; 0x8006c2 <uxTopReadyPriority>
    1808:	98 17       	cp	r25, r24
    180a:	10 f4       	brcc	.+4      	; 0x1810 <xTaskResumeAll+0x60>
    180c:	80 93 c2 06 	sts	0x06C2, r24	; 0x8006c2 <uxTopReadyPriority>
    1810:	90 e0       	ldi	r25, 0x00	; 0
    1812:	9c 01       	movw	r18, r24
    1814:	22 0f       	add	r18, r18
    1816:	33 1f       	adc	r19, r19
    1818:	22 0f       	add	r18, r18
    181a:	33 1f       	adc	r19, r19
    181c:	22 0f       	add	r18, r18
    181e:	33 1f       	adc	r19, r19
    1820:	82 0f       	add	r24, r18
    1822:	93 1f       	adc	r25, r19
    1824:	b8 01       	movw	r22, r16
    1826:	88 50       	subi	r24, 0x08	; 8
    1828:	99 4f       	sbci	r25, 0xF9	; 249
    182a:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <vListInsertEnd>
    182e:	e0 91 25 07 	lds	r30, 0x0725	; 0x800725 <pxCurrentTCB>
    1832:	f0 91 26 07 	lds	r31, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    1836:	9e 89       	ldd	r25, Y+22	; 0x16
    1838:	86 89       	ldd	r24, Z+22	; 0x16
    183a:	98 17       	cp	r25, r24
    183c:	68 f0       	brcs	.+26     	; 0x1858 <xTaskResumeAll+0xa8>
    183e:	d0 92 bf 06 	sts	0x06BF, r13	; 0x8006bf <xYieldPending>
    1842:	0a c0       	rjmp	.+20     	; 0x1858 <xTaskResumeAll+0xa8>
    1844:	c0 e0       	ldi	r28, 0x00	; 0
    1846:	d0 e0       	ldi	r29, 0x00	; 0
    1848:	0f 2e       	mov	r0, r31
    184a:	f9 ed       	ldi	r31, 0xD9	; 217
    184c:	ef 2e       	mov	r14, r31
    184e:	f6 e0       	ldi	r31, 0x06	; 6
    1850:	ff 2e       	mov	r15, r31
    1852:	f0 2d       	mov	r31, r0
    1854:	dd 24       	eor	r13, r13
    1856:	d3 94       	inc	r13
    1858:	f7 01       	movw	r30, r14
    185a:	80 81       	ld	r24, Z
    185c:	81 11       	cpse	r24, r1
    185e:	c0 cf       	rjmp	.-128    	; 0x17e0 <xTaskResumeAll+0x30>
    1860:	cd 2b       	or	r28, r29
    1862:	11 f0       	breq	.+4      	; 0x1868 <xTaskResumeAll+0xb8>
    1864:	0e 94 06 09 	call	0x120c	; 0x120c <prvResetNextTaskUnblockTime>
    1868:	c0 91 c0 06 	lds	r28, 0x06C0	; 0x8006c0 <uxPendedTicks>
    186c:	cc 23       	and	r28, r28
    186e:	51 f0       	breq	.+20     	; 0x1884 <xTaskResumeAll+0xd4>
    1870:	d1 e0       	ldi	r29, 0x01	; 1
    1872:	0e 94 38 0b 	call	0x1670	; 0x1670 <xTaskIncrementTick>
    1876:	81 11       	cpse	r24, r1
    1878:	d0 93 bf 06 	sts	0x06BF, r29	; 0x8006bf <xYieldPending>
    187c:	c1 50       	subi	r28, 0x01	; 1
    187e:	c9 f7       	brne	.-14     	; 0x1872 <xTaskResumeAll+0xc2>
    1880:	10 92 c0 06 	sts	0x06C0, r1	; 0x8006c0 <uxPendedTicks>
    1884:	80 91 bf 06 	lds	r24, 0x06BF	; 0x8006bf <xYieldPending>
    1888:	0f 90       	pop	r0
    188a:	0f be       	out	0x3f, r0	; 63
    188c:	80 e0       	ldi	r24, 0x00	; 0
    188e:	df 91       	pop	r29
    1890:	cf 91       	pop	r28
    1892:	1f 91       	pop	r17
    1894:	0f 91       	pop	r16
    1896:	ff 90       	pop	r15
    1898:	ef 90       	pop	r14
    189a:	df 90       	pop	r13
    189c:	08 95       	ret

0000189e <vTaskDelayUntil>:
    189e:	0f 93       	push	r16
    18a0:	1f 93       	push	r17
    18a2:	cf 93       	push	r28
    18a4:	df 93       	push	r29
    18a6:	8c 01       	movw	r16, r24
    18a8:	eb 01       	movw	r28, r22
    18aa:	0e 94 28 0b 	call	0x1650	; 0x1650 <vTaskSuspendAll>
    18ae:	40 91 c3 06 	lds	r20, 0x06C3	; 0x8006c3 <xTickCount>
    18b2:	50 91 c4 06 	lds	r21, 0x06C4	; 0x8006c4 <xTickCount+0x1>
    18b6:	f8 01       	movw	r30, r16
    18b8:	20 81       	ld	r18, Z
    18ba:	31 81       	ldd	r19, Z+1	; 0x01
    18bc:	c9 01       	movw	r24, r18
    18be:	8c 0f       	add	r24, r28
    18c0:	9d 1f       	adc	r25, r29
    18c2:	42 17       	cp	r20, r18
    18c4:	53 07       	cpc	r21, r19
    18c6:	48 f4       	brcc	.+18     	; 0x18da <vTaskDelayUntil+0x3c>
    18c8:	82 17       	cp	r24, r18
    18ca:	93 07       	cpc	r25, r19
    18cc:	e8 f4       	brcc	.+58     	; 0x1908 <vTaskDelayUntil+0x6a>
    18ce:	91 83       	std	Z+1, r25	; 0x01
    18d0:	80 83       	st	Z, r24
    18d2:	48 17       	cp	r20, r24
    18d4:	59 07       	cpc	r21, r25
    18d6:	68 f4       	brcc	.+26     	; 0x18f2 <vTaskDelayUntil+0x54>
    18d8:	07 c0       	rjmp	.+14     	; 0x18e8 <vTaskDelayUntil+0x4a>
    18da:	82 17       	cp	r24, r18
    18dc:	93 07       	cpc	r25, r19
    18de:	80 f0       	brcs	.+32     	; 0x1900 <vTaskDelayUntil+0x62>
    18e0:	48 17       	cp	r20, r24
    18e2:	59 07       	cpc	r21, r25
    18e4:	68 f0       	brcs	.+26     	; 0x1900 <vTaskDelayUntil+0x62>
    18e6:	10 c0       	rjmp	.+32     	; 0x1908 <vTaskDelayUntil+0x6a>
    18e8:	60 e0       	ldi	r22, 0x00	; 0
    18ea:	84 1b       	sub	r24, r20
    18ec:	95 0b       	sbc	r25, r21
    18ee:	0e 94 53 09 	call	0x12a6	; 0x12a6 <prvAddCurrentTaskToDelayedList>
    18f2:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xTaskResumeAll>
    18f6:	81 11       	cpse	r24, r1
    18f8:	0b c0       	rjmp	.+22     	; 0x1910 <vTaskDelayUntil+0x72>
    18fa:	0e 94 0c 06 	call	0xc18	; 0xc18 <vPortYield>
    18fe:	08 c0       	rjmp	.+16     	; 0x1910 <vTaskDelayUntil+0x72>
    1900:	f8 01       	movw	r30, r16
    1902:	91 83       	std	Z+1, r25	; 0x01
    1904:	80 83       	st	Z, r24
    1906:	f0 cf       	rjmp	.-32     	; 0x18e8 <vTaskDelayUntil+0x4a>
    1908:	f8 01       	movw	r30, r16
    190a:	91 83       	std	Z+1, r25	; 0x01
    190c:	80 83       	st	Z, r24
    190e:	f1 cf       	rjmp	.-30     	; 0x18f2 <vTaskDelayUntil+0x54>
    1910:	df 91       	pop	r29
    1912:	cf 91       	pop	r28
    1914:	1f 91       	pop	r17
    1916:	0f 91       	pop	r16
    1918:	08 95       	ret

0000191a <vTaskDelay>:
    191a:	cf 93       	push	r28
    191c:	df 93       	push	r29
    191e:	ec 01       	movw	r28, r24
    1920:	89 2b       	or	r24, r25
    1922:	51 f0       	breq	.+20     	; 0x1938 <vTaskDelay+0x1e>
    1924:	0e 94 28 0b 	call	0x1650	; 0x1650 <vTaskSuspendAll>
    1928:	60 e0       	ldi	r22, 0x00	; 0
    192a:	ce 01       	movw	r24, r28
    192c:	0e 94 53 09 	call	0x12a6	; 0x12a6 <prvAddCurrentTaskToDelayedList>
    1930:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <xTaskResumeAll>
    1934:	81 11       	cpse	r24, r1
    1936:	02 c0       	rjmp	.+4      	; 0x193c <vTaskDelay+0x22>
    1938:	0e 94 0c 06 	call	0xc18	; 0xc18 <vPortYield>
    193c:	df 91       	pop	r29
    193e:	cf 91       	pop	r28
    1940:	08 95       	ret

00001942 <vTaskSwitchContext>:
    1942:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <uxSchedulerSuspended>
    1946:	88 23       	and	r24, r24
    1948:	21 f0       	breq	.+8      	; 0x1952 <vTaskSwitchContext+0x10>
    194a:	81 e0       	ldi	r24, 0x01	; 1
    194c:	80 93 bf 06 	sts	0x06BF, r24	; 0x8006bf <xYieldPending>
    1950:	08 95       	ret
    1952:	10 92 bf 06 	sts	0x06BF, r1	; 0x8006bf <xYieldPending>
    1956:	20 91 c2 06 	lds	r18, 0x06C2	; 0x8006c2 <uxTopReadyPriority>
    195a:	82 2f       	mov	r24, r18
    195c:	90 e0       	ldi	r25, 0x00	; 0
    195e:	fc 01       	movw	r30, r24
    1960:	ee 0f       	add	r30, r30
    1962:	ff 1f       	adc	r31, r31
    1964:	ee 0f       	add	r30, r30
    1966:	ff 1f       	adc	r31, r31
    1968:	ee 0f       	add	r30, r30
    196a:	ff 1f       	adc	r31, r31
    196c:	e8 0f       	add	r30, r24
    196e:	f9 1f       	adc	r31, r25
    1970:	e8 50       	subi	r30, 0x08	; 8
    1972:	f9 4f       	sbci	r31, 0xF9	; 249
    1974:	30 81       	ld	r19, Z
    1976:	31 11       	cpse	r19, r1
    1978:	11 c0       	rjmp	.+34     	; 0x199c <vTaskSwitchContext+0x5a>
    197a:	21 50       	subi	r18, 0x01	; 1
    197c:	82 2f       	mov	r24, r18
    197e:	90 e0       	ldi	r25, 0x00	; 0
    1980:	fc 01       	movw	r30, r24
    1982:	ee 0f       	add	r30, r30
    1984:	ff 1f       	adc	r31, r31
    1986:	ee 0f       	add	r30, r30
    1988:	ff 1f       	adc	r31, r31
    198a:	ee 0f       	add	r30, r30
    198c:	ff 1f       	adc	r31, r31
    198e:	e8 0f       	add	r30, r24
    1990:	f9 1f       	adc	r31, r25
    1992:	e8 50       	subi	r30, 0x08	; 8
    1994:	f9 4f       	sbci	r31, 0xF9	; 249
    1996:	30 81       	ld	r19, Z
    1998:	33 23       	and	r19, r19
    199a:	79 f3       	breq	.-34     	; 0x197a <vTaskSwitchContext+0x38>
    199c:	ac 01       	movw	r20, r24
    199e:	44 0f       	add	r20, r20
    19a0:	55 1f       	adc	r21, r21
    19a2:	44 0f       	add	r20, r20
    19a4:	55 1f       	adc	r21, r21
    19a6:	44 0f       	add	r20, r20
    19a8:	55 1f       	adc	r21, r21
    19aa:	48 0f       	add	r20, r24
    19ac:	59 1f       	adc	r21, r25
    19ae:	da 01       	movw	r26, r20
    19b0:	a8 50       	subi	r26, 0x08	; 8
    19b2:	b9 4f       	sbci	r27, 0xF9	; 249
    19b4:	11 96       	adiw	r26, 0x01	; 1
    19b6:	ed 91       	ld	r30, X+
    19b8:	fc 91       	ld	r31, X
    19ba:	12 97       	sbiw	r26, 0x02	; 2
    19bc:	02 80       	ldd	r0, Z+2	; 0x02
    19be:	f3 81       	ldd	r31, Z+3	; 0x03
    19c0:	e0 2d       	mov	r30, r0
    19c2:	12 96       	adiw	r26, 0x02	; 2
    19c4:	fc 93       	st	X, r31
    19c6:	ee 93       	st	-X, r30
    19c8:	11 97       	sbiw	r26, 0x01	; 1
    19ca:	45 50       	subi	r20, 0x05	; 5
    19cc:	59 4f       	sbci	r21, 0xF9	; 249
    19ce:	e4 17       	cp	r30, r20
    19d0:	f5 07       	cpc	r31, r21
    19d2:	29 f4       	brne	.+10     	; 0x19de <vTaskSwitchContext+0x9c>
    19d4:	42 81       	ldd	r20, Z+2	; 0x02
    19d6:	53 81       	ldd	r21, Z+3	; 0x03
    19d8:	fd 01       	movw	r30, r26
    19da:	52 83       	std	Z+2, r21	; 0x02
    19dc:	41 83       	std	Z+1, r20	; 0x01
    19de:	fc 01       	movw	r30, r24
    19e0:	ee 0f       	add	r30, r30
    19e2:	ff 1f       	adc	r31, r31
    19e4:	ee 0f       	add	r30, r30
    19e6:	ff 1f       	adc	r31, r31
    19e8:	ee 0f       	add	r30, r30
    19ea:	ff 1f       	adc	r31, r31
    19ec:	8e 0f       	add	r24, r30
    19ee:	9f 1f       	adc	r25, r31
    19f0:	fc 01       	movw	r30, r24
    19f2:	e8 50       	subi	r30, 0x08	; 8
    19f4:	f9 4f       	sbci	r31, 0xF9	; 249
    19f6:	01 80       	ldd	r0, Z+1	; 0x01
    19f8:	f2 81       	ldd	r31, Z+2	; 0x02
    19fa:	e0 2d       	mov	r30, r0
    19fc:	86 81       	ldd	r24, Z+6	; 0x06
    19fe:	97 81       	ldd	r25, Z+7	; 0x07
    1a00:	90 93 26 07 	sts	0x0726, r25	; 0x800726 <pxCurrentTCB+0x1>
    1a04:	80 93 25 07 	sts	0x0725, r24	; 0x800725 <pxCurrentTCB>
    1a08:	20 93 c2 06 	sts	0x06C2, r18	; 0x8006c2 <uxTopReadyPriority>
    1a0c:	08 95       	ret

00001a0e <vTaskSuspend>:
    1a0e:	0f 93       	push	r16
    1a10:	1f 93       	push	r17
    1a12:	cf 93       	push	r28
    1a14:	df 93       	push	r29
    1a16:	ec 01       	movw	r28, r24
    1a18:	0f b6       	in	r0, 0x3f	; 63
    1a1a:	f8 94       	cli
    1a1c:	0f 92       	push	r0
    1a1e:	89 2b       	or	r24, r25
    1a20:	21 f4       	brne	.+8      	; 0x1a2a <vTaskSuspend+0x1c>
    1a22:	c0 91 25 07 	lds	r28, 0x0725	; 0x800725 <pxCurrentTCB>
    1a26:	d0 91 26 07 	lds	r29, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    1a2a:	8e 01       	movw	r16, r28
    1a2c:	0e 5f       	subi	r16, 0xFE	; 254
    1a2e:	1f 4f       	sbci	r17, 0xFF	; 255
    1a30:	c8 01       	movw	r24, r16
    1a32:	0e 94 44 05 	call	0xa88	; 0xa88 <uxListRemove>
    1a36:	8c 89       	ldd	r24, Y+20	; 0x14
    1a38:	9d 89       	ldd	r25, Y+21	; 0x15
    1a3a:	89 2b       	or	r24, r25
    1a3c:	21 f0       	breq	.+8      	; 0x1a46 <vTaskSuspend+0x38>
    1a3e:	ce 01       	movw	r24, r28
    1a40:	0c 96       	adiw	r24, 0x0c	; 12
    1a42:	0e 94 44 05 	call	0xa88	; 0xa88 <uxListRemove>
    1a46:	b8 01       	movw	r22, r16
    1a48:	86 ec       	ldi	r24, 0xC6	; 198
    1a4a:	96 e0       	ldi	r25, 0x06	; 6
    1a4c:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <vListInsertEnd>
    1a50:	8d a1       	ldd	r24, Y+37	; 0x25
    1a52:	81 30       	cpi	r24, 0x01	; 1
    1a54:	09 f4       	brne	.+2      	; 0x1a58 <vTaskSuspend+0x4a>
    1a56:	1d a2       	std	Y+37, r1	; 0x25
    1a58:	0f 90       	pop	r0
    1a5a:	0f be       	out	0x3f, r0	; 63
    1a5c:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <xSchedulerRunning>
    1a60:	88 23       	and	r24, r24
    1a62:	39 f0       	breq	.+14     	; 0x1a72 <vTaskSuspend+0x64>
    1a64:	0f b6       	in	r0, 0x3f	; 63
    1a66:	f8 94       	cli
    1a68:	0f 92       	push	r0
    1a6a:	0e 94 06 09 	call	0x120c	; 0x120c <prvResetNextTaskUnblockTime>
    1a6e:	0f 90       	pop	r0
    1a70:	0f be       	out	0x3f, r0	; 63
    1a72:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <pxCurrentTCB>
    1a76:	90 91 26 07 	lds	r25, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    1a7a:	c8 17       	cp	r28, r24
    1a7c:	d9 07       	cpc	r29, r25
    1a7e:	a1 f4       	brne	.+40     	; 0x1aa8 <vTaskSuspend+0x9a>
    1a80:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <xSchedulerRunning>
    1a84:	88 23       	and	r24, r24
    1a86:	19 f0       	breq	.+6      	; 0x1a8e <vTaskSuspend+0x80>
    1a88:	0e 94 0c 06 	call	0xc18	; 0xc18 <vPortYield>
    1a8c:	0d c0       	rjmp	.+26     	; 0x1aa8 <vTaskSuspend+0x9a>
    1a8e:	90 91 c6 06 	lds	r25, 0x06C6	; 0x8006c6 <xSuspendedTaskList>
    1a92:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <uxCurrentNumberOfTasks>
    1a96:	98 13       	cpse	r25, r24
    1a98:	05 c0       	rjmp	.+10     	; 0x1aa4 <vTaskSuspend+0x96>
    1a9a:	10 92 26 07 	sts	0x0726, r1	; 0x800726 <pxCurrentTCB+0x1>
    1a9e:	10 92 25 07 	sts	0x0725, r1	; 0x800725 <pxCurrentTCB>
    1aa2:	02 c0       	rjmp	.+4      	; 0x1aa8 <vTaskSuspend+0x9a>
    1aa4:	0e 94 a1 0c 	call	0x1942	; 0x1942 <vTaskSwitchContext>
    1aa8:	df 91       	pop	r29
    1aaa:	cf 91       	pop	r28
    1aac:	1f 91       	pop	r17
    1aae:	0f 91       	pop	r16
    1ab0:	08 95       	ret

00001ab2 <vTaskPlaceOnEventList>:
    1ab2:	cf 93       	push	r28
    1ab4:	df 93       	push	r29
    1ab6:	eb 01       	movw	r28, r22
    1ab8:	60 91 25 07 	lds	r22, 0x0725	; 0x800725 <pxCurrentTCB>
    1abc:	70 91 26 07 	lds	r23, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    1ac0:	64 5f       	subi	r22, 0xF4	; 244
    1ac2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ac4:	0e 94 13 05 	call	0xa26	; 0xa26 <vListInsert>
    1ac8:	61 e0       	ldi	r22, 0x01	; 1
    1aca:	ce 01       	movw	r24, r28
    1acc:	0e 94 53 09 	call	0x12a6	; 0x12a6 <prvAddCurrentTaskToDelayedList>
    1ad0:	df 91       	pop	r29
    1ad2:	cf 91       	pop	r28
    1ad4:	08 95       	ret

00001ad6 <xTaskRemoveFromEventList>:
    1ad6:	0f 93       	push	r16
    1ad8:	1f 93       	push	r17
    1ada:	cf 93       	push	r28
    1adc:	df 93       	push	r29
    1ade:	dc 01       	movw	r26, r24
    1ae0:	15 96       	adiw	r26, 0x05	; 5
    1ae2:	ed 91       	ld	r30, X+
    1ae4:	fc 91       	ld	r31, X
    1ae6:	16 97       	sbiw	r26, 0x06	; 6
    1ae8:	c6 81       	ldd	r28, Z+6	; 0x06
    1aea:	d7 81       	ldd	r29, Z+7	; 0x07
    1aec:	8e 01       	movw	r16, r28
    1aee:	04 5f       	subi	r16, 0xF4	; 244
    1af0:	1f 4f       	sbci	r17, 0xFF	; 255
    1af2:	c8 01       	movw	r24, r16
    1af4:	0e 94 44 05 	call	0xa88	; 0xa88 <uxListRemove>
    1af8:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <uxSchedulerSuspended>
    1afc:	81 11       	cpse	r24, r1
    1afe:	1c c0       	rjmp	.+56     	; 0x1b38 <xTaskRemoveFromEventList+0x62>
    1b00:	0a 50       	subi	r16, 0x0A	; 10
    1b02:	11 09       	sbc	r17, r1
    1b04:	c8 01       	movw	r24, r16
    1b06:	0e 94 44 05 	call	0xa88	; 0xa88 <uxListRemove>
    1b0a:	8e 89       	ldd	r24, Y+22	; 0x16
    1b0c:	90 91 c2 06 	lds	r25, 0x06C2	; 0x8006c2 <uxTopReadyPriority>
    1b10:	98 17       	cp	r25, r24
    1b12:	10 f4       	brcc	.+4      	; 0x1b18 <xTaskRemoveFromEventList+0x42>
    1b14:	80 93 c2 06 	sts	0x06C2, r24	; 0x8006c2 <uxTopReadyPriority>
    1b18:	90 e0       	ldi	r25, 0x00	; 0
    1b1a:	9c 01       	movw	r18, r24
    1b1c:	22 0f       	add	r18, r18
    1b1e:	33 1f       	adc	r19, r19
    1b20:	22 0f       	add	r18, r18
    1b22:	33 1f       	adc	r19, r19
    1b24:	22 0f       	add	r18, r18
    1b26:	33 1f       	adc	r19, r19
    1b28:	82 0f       	add	r24, r18
    1b2a:	93 1f       	adc	r25, r19
    1b2c:	b8 01       	movw	r22, r16
    1b2e:	88 50       	subi	r24, 0x08	; 8
    1b30:	99 4f       	sbci	r25, 0xF9	; 249
    1b32:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <vListInsertEnd>
    1b36:	05 c0       	rjmp	.+10     	; 0x1b42 <xTaskRemoveFromEventList+0x6c>
    1b38:	b8 01       	movw	r22, r16
    1b3a:	89 ed       	ldi	r24, 0xD9	; 217
    1b3c:	96 e0       	ldi	r25, 0x06	; 6
    1b3e:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <vListInsertEnd>
    1b42:	e0 91 25 07 	lds	r30, 0x0725	; 0x800725 <pxCurrentTCB>
    1b46:	f0 91 26 07 	lds	r31, 0x0726	; 0x800726 <pxCurrentTCB+0x1>
    1b4a:	9e 89       	ldd	r25, Y+22	; 0x16
    1b4c:	86 89       	ldd	r24, Z+22	; 0x16
    1b4e:	89 17       	cp	r24, r25
    1b50:	20 f4       	brcc	.+8      	; 0x1b5a <xTaskRemoveFromEventList+0x84>
    1b52:	81 e0       	ldi	r24, 0x01	; 1
    1b54:	80 93 bf 06 	sts	0x06BF, r24	; 0x8006bf <xYieldPending>
    1b58:	01 c0       	rjmp	.+2      	; 0x1b5c <xTaskRemoveFromEventList+0x86>
    1b5a:	80 e0       	ldi	r24, 0x00	; 0
    1b5c:	df 91       	pop	r29
    1b5e:	cf 91       	pop	r28
    1b60:	1f 91       	pop	r17
    1b62:	0f 91       	pop	r16
    1b64:	08 95       	ret

00001b66 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1b66:	20 91 be 06 	lds	r18, 0x06BE	; 0x8006be <xNumOfOverflows>
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1b6e:	20 91 c3 06 	lds	r18, 0x06C3	; 0x8006c3 <xTickCount>
    1b72:	30 91 c4 06 	lds	r19, 0x06C4	; 0x8006c4 <xTickCount+0x1>
    1b76:	32 83       	std	Z+2, r19	; 0x02
    1b78:	21 83       	std	Z+1, r18	; 0x01
    1b7a:	08 95       	ret

00001b7c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1b7c:	cf 93       	push	r28
    1b7e:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1b80:	0f b6       	in	r0, 0x3f	; 63
    1b82:	f8 94       	cli
    1b84:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1b86:	20 91 c3 06 	lds	r18, 0x06C3	; 0x8006c3 <xTickCount>
    1b8a:	30 91 c4 06 	lds	r19, 0x06C4	; 0x8006c4 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    1b8e:	db 01       	movw	r26, r22
    1b90:	4d 91       	ld	r20, X+
    1b92:	5c 91       	ld	r21, X
    1b94:	4f 3f       	cpi	r20, 0xFF	; 255
    1b96:	bf ef       	ldi	r27, 0xFF	; 255
    1b98:	5b 07       	cpc	r21, r27
    1b9a:	f1 f0       	breq	.+60     	; 0x1bd8 <xTaskCheckForTimeOut+0x5c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1b9c:	ec 01       	movw	r28, r24
    1b9e:	e9 81       	ldd	r30, Y+1	; 0x01
    1ba0:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1ba2:	a0 91 be 06 	lds	r26, 0x06BE	; 0x8006be <xNumOfOverflows>
    1ba6:	b8 81       	ld	r27, Y
    1ba8:	ba 17       	cp	r27, r26
    1baa:	19 f0       	breq	.+6      	; 0x1bb2 <xTaskCheckForTimeOut+0x36>
    1bac:	2e 17       	cp	r18, r30
    1bae:	3f 07       	cpc	r19, r31
    1bb0:	a8 f4       	brcc	.+42     	; 0x1bdc <xTaskCheckForTimeOut+0x60>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1bb2:	2e 1b       	sub	r18, r30
    1bb4:	3f 0b       	sbc	r19, r31
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1bb6:	24 17       	cp	r18, r20
    1bb8:	35 07       	cpc	r19, r21
    1bba:	48 f4       	brcc	.+18     	; 0x1bce <xTaskCheckForTimeOut+0x52>
    1bbc:	fb 01       	movw	r30, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    1bbe:	42 1b       	sub	r20, r18
    1bc0:	53 0b       	sbc	r21, r19
    1bc2:	51 83       	std	Z+1, r21	; 0x01
    1bc4:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    1bc6:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    1bca:	80 e0       	ldi	r24, 0x00	; 0
    1bcc:	08 c0       	rjmp	.+16     	; 0x1bde <xTaskCheckForTimeOut+0x62>
		}
		else
		{
			*pxTicksToWait = 0;
    1bce:	fb 01       	movw	r30, r22
    1bd0:	11 82       	std	Z+1, r1	; 0x01
    1bd2:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    1bd4:	81 e0       	ldi	r24, 0x01	; 1
    1bd6:	03 c0       	rjmp	.+6      	; 0x1bde <xTaskCheckForTimeOut+0x62>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    1bd8:	80 e0       	ldi	r24, 0x00	; 0
    1bda:	01 c0       	rjmp	.+2      	; 0x1bde <xTaskCheckForTimeOut+0x62>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1bdc:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1bde:	0f 90       	pop	r0
    1be0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1be2:	df 91       	pop	r29
    1be4:	cf 91       	pop	r28
    1be6:	08 95       	ret

00001be8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1be8:	81 e0       	ldi	r24, 0x01	; 1
    1bea:	80 93 bf 06 	sts	0x06BF, r24	; 0x8006bf <xYieldPending>
    1bee:	08 95       	ret

00001bf0 <memcpy>:
    1bf0:	fb 01       	movw	r30, r22
    1bf2:	dc 01       	movw	r26, r24
    1bf4:	02 c0       	rjmp	.+4      	; 0x1bfa <memcpy+0xa>
    1bf6:	01 90       	ld	r0, Z+
    1bf8:	0d 92       	st	X+, r0
    1bfa:	41 50       	subi	r20, 0x01	; 1
    1bfc:	50 40       	sbci	r21, 0x00	; 0
    1bfe:	d8 f7       	brcc	.-10     	; 0x1bf6 <memcpy+0x6>
    1c00:	08 95       	ret

00001c02 <itoa>:
    1c02:	45 32       	cpi	r20, 0x25	; 37
    1c04:	51 05       	cpc	r21, r1
    1c06:	20 f4       	brcc	.+8      	; 0x1c10 <itoa+0xe>
    1c08:	42 30       	cpi	r20, 0x02	; 2
    1c0a:	10 f0       	brcs	.+4      	; 0x1c10 <itoa+0xe>
    1c0c:	0c 94 0c 0e 	jmp	0x1c18	; 0x1c18 <__itoa_ncheck>
    1c10:	fb 01       	movw	r30, r22
    1c12:	10 82       	st	Z, r1
    1c14:	cb 01       	movw	r24, r22
    1c16:	08 95       	ret

00001c18 <__itoa_ncheck>:
    1c18:	bb 27       	eor	r27, r27
    1c1a:	4a 30       	cpi	r20, 0x0A	; 10
    1c1c:	31 f4       	brne	.+12     	; 0x1c2a <__itoa_ncheck+0x12>
    1c1e:	99 23       	and	r25, r25
    1c20:	22 f4       	brpl	.+8      	; 0x1c2a <__itoa_ncheck+0x12>
    1c22:	bd e2       	ldi	r27, 0x2D	; 45
    1c24:	90 95       	com	r25
    1c26:	81 95       	neg	r24
    1c28:	9f 4f       	sbci	r25, 0xFF	; 255
    1c2a:	0c 94 18 0e 	jmp	0x1c30	; 0x1c30 <__utoa_common>

00001c2e <__utoa_ncheck>:
    1c2e:	bb 27       	eor	r27, r27

00001c30 <__utoa_common>:
    1c30:	fb 01       	movw	r30, r22
    1c32:	55 27       	eor	r21, r21
    1c34:	aa 27       	eor	r26, r26
    1c36:	88 0f       	add	r24, r24
    1c38:	99 1f       	adc	r25, r25
    1c3a:	aa 1f       	adc	r26, r26
    1c3c:	a4 17       	cp	r26, r20
    1c3e:	10 f0       	brcs	.+4      	; 0x1c44 <__utoa_common+0x14>
    1c40:	a4 1b       	sub	r26, r20
    1c42:	83 95       	inc	r24
    1c44:	50 51       	subi	r21, 0x10	; 16
    1c46:	b9 f7       	brne	.-18     	; 0x1c36 <__utoa_common+0x6>
    1c48:	a0 5d       	subi	r26, 0xD0	; 208
    1c4a:	aa 33       	cpi	r26, 0x3A	; 58
    1c4c:	08 f0       	brcs	.+2      	; 0x1c50 <__utoa_common+0x20>
    1c4e:	a9 5d       	subi	r26, 0xD9	; 217
    1c50:	a1 93       	st	Z+, r26
    1c52:	00 97       	sbiw	r24, 0x00	; 0
    1c54:	79 f7       	brne	.-34     	; 0x1c34 <__utoa_common+0x4>
    1c56:	b1 11       	cpse	r27, r1
    1c58:	b1 93       	st	Z+, r27
    1c5a:	11 92       	st	Z+, r1
    1c5c:	cb 01       	movw	r24, r22
    1c5e:	0c 94 31 0e 	jmp	0x1c62	; 0x1c62 <strrev>

00001c62 <strrev>:
    1c62:	dc 01       	movw	r26, r24
    1c64:	fc 01       	movw	r30, r24
    1c66:	67 2f       	mov	r22, r23
    1c68:	71 91       	ld	r23, Z+
    1c6a:	77 23       	and	r23, r23
    1c6c:	e1 f7       	brne	.-8      	; 0x1c66 <strrev+0x4>
    1c6e:	32 97       	sbiw	r30, 0x02	; 2
    1c70:	04 c0       	rjmp	.+8      	; 0x1c7a <strrev+0x18>
    1c72:	7c 91       	ld	r23, X
    1c74:	6d 93       	st	X+, r22
    1c76:	70 83       	st	Z, r23
    1c78:	62 91       	ld	r22, -Z
    1c7a:	ae 17       	cp	r26, r30
    1c7c:	bf 07       	cpc	r27, r31
    1c7e:	c8 f3       	brcs	.-14     	; 0x1c72 <strrev+0x10>
    1c80:	08 95       	ret

00001c82 <_exit>:
    1c82:	f8 94       	cli

00001c84 <__stop_program>:
    1c84:	ff cf       	rjmp	.-2      	; 0x1c84 <__stop_program>
