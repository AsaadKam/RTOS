
Receive_from_Uart_Temp_Sensor_on_Lcd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002338  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000022  00800060  00002338  000023cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000066c  00800082  00800082  000023ee  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000023ee  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002420  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000498  00000000  00000000  0000245c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005b15  00000000  00000000  000028f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000166d  00000000  00000000  00008409  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003716  00000000  00000000  00009a76  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000cf0  00000000  00000000  0000d18c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001cd8  00000000  00000000  0000de7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005652  00000000  00000000  0000fb54  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004c0  00000000  00000000  000151a6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 70 08 	jmp	0x10e0	; 0x10e0 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 97 05 	jmp	0xb2e	; 0xb2e <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 c4 05 	jmp	0xb88	; 0xb88 <__vector_15>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e3       	ldi	r30, 0x38	; 56
      68:	f3 e2       	ldi	r31, 0x23	; 35
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 38       	cpi	r26, 0x82	; 130
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	26 e0       	ldi	r18, 0x06	; 6
      78:	a2 e8       	ldi	r26, 0x82	; 130
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 3e       	cpi	r26, 0xEE	; 238
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 2a 02 	call	0x454	; 0x454 <main>
      8a:	0c 94 9a 11 	jmp	0x2334	; 0x2334 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <System_Init>:
/***********************PROTOTYPE_IMPLEMENTATION*******************************/
void System_Init (void *Pv_Parameter)                        /**     No  Periodicity           -- Priority is 4**//**Execution time range micro    **/
{
    uinteg8_t gu8_LCD_Status=0;
	
	vTaskSuspend(UART_rec_Handler);	
      92:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <UART_rec_Handler>
      96:	90 91 88 00 	lds	r25, 0x0088	; 0x800088 <UART_rec_Handler+0x1>
      9a:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <vTaskSuspend>
	vTaskSuspend(Switches_Handler);
      9e:	80 91 89 00 	lds	r24, 0x0089	; 0x800089 <Switches_Handler>
      a2:	90 91 8a 00 	lds	r25, 0x008A	; 0x80008a <Switches_Handler+0x1>
      a6:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <vTaskSuspend>
	vTaskSuspend(LCD_Display_Update_Handler);
      aa:	80 91 85 00 	lds	r24, 0x0085	; 0x800085 <LCD_Display_Update_Handler>
      ae:	90 91 86 00 	lds	r25, 0x0086	; 0x800086 <LCD_Display_Update_Handler+0x1>
      b2:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <vTaskSuspend>
	vTaskSuspend(Temp_Sensor_Send_Data_Handler);	
      b6:	80 91 83 00 	lds	r24, 0x0083	; 0x800083 <Temp_Sensor_Send_Data_Handler>
      ba:	90 91 84 00 	lds	r25, 0x0084	; 0x800084 <Temp_Sensor_Send_Data_Handler+0x1>
      be:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <vTaskSuspend>

		
	while(1)
	{
	    LCD_init();
      c2:	0e 94 b2 02 	call	0x564	; 0x564 <LCD_init>
		ADC_INIT(&gstr_Temp_sensorConfig);
      c6:	87 e6       	ldi	r24, 0x67	; 103
      c8:	90 e0       	ldi	r25, 0x00	; 0
      ca:	0e 94 49 03 	call	0x692	; 0x692 <ADC_INIT>
		Switch_init(switch0);
      ce:	60 e0       	ldi	r22, 0x00	; 0
      d0:	88 e0       	ldi	r24, 0x08	; 8
      d2:	0e 94 5d 04 	call	0x8ba	; 0x8ba <DIO_Init_Pin>
		UART_Init(&RTOS_UART_CONFIG);
      d6:	85 e7       	ldi	r24, 0x75	; 117
      d8:	90 e0       	ldi	r25, 0x00	; 0
      da:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <UART_Init>
		vTaskResume(UART_rec_Handler);
      de:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <UART_rec_Handler>
      e2:	90 91 88 00 	lds	r25, 0x0088	; 0x800088 <UART_rec_Handler+0x1>
      e6:	0e 94 b6 0c 	call	0x196c	; 0x196c <vTaskResume>
		vTaskResume(Switches_Handler);
      ea:	80 91 89 00 	lds	r24, 0x0089	; 0x800089 <Switches_Handler>
      ee:	90 91 8a 00 	lds	r25, 0x008A	; 0x80008a <Switches_Handler+0x1>
      f2:	0e 94 b6 0c 	call	0x196c	; 0x196c <vTaskResume>
		vTaskResume(Temp_Sensor_Send_Data_Handler);
      f6:	80 91 83 00 	lds	r24, 0x0083	; 0x800083 <Temp_Sensor_Send_Data_Handler>
      fa:	90 91 84 00 	lds	r25, 0x0084	; 0x800084 <Temp_Sensor_Send_Data_Handler+0x1>
      fe:	0e 94 b6 0c 	call	0x196c	; 0x196c <vTaskResume>
		vTaskResume(LCD_Display_Update_Handler);	
     102:	80 91 85 00 	lds	r24, 0x0085	; 0x800085 <LCD_Display_Update_Handler>
     106:	90 91 86 00 	lds	r25, 0x0086	; 0x800086 <LCD_Display_Update_Handler+0x1>
     10a:	0e 94 b6 0c 	call	0x196c	; 0x196c <vTaskResume>
        vTaskSuspend(SYS_Handler);
     10e:	80 91 8b 00 	lds	r24, 0x008B	; 0x80008b <SYS_Handler>
     112:	90 91 8c 00 	lds	r25, 0x008C	; 0x80008c <SYS_Handler+0x1>
     116:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <vTaskSuspend>
     11a:	d3 cf       	rjmp	.-90     	; 0xc2 <System_Init+0x30>

0000011c <Send_Switch_State>:
	}
}

void Send_Switch_State(void*Pv_Parameter)                    /** Periodicity 50 milisecond     -- Priority is 3**//**Execution time range micro    **/
{
     11c:	cf 93       	push	r28
     11e:	df 93       	push	r29
     120:	00 d0       	rcall	.+0      	; 0x122 <Send_Switch_State+0x6>
     122:	1f 92       	push	r1
     124:	cd b7       	in	r28, 0x3d	; 61
     126:	de b7       	in	r29, 0x3e	; 62
	const TickType_t xFrequency = 50;

	/*local variable for reading the value of switch now*/
	uinteg8_t u8_value_of_switch;
	static uinteg8_t su8_switch_high_count;
	Switch0_Couting_Semaphore=xSemaphoreCreateCounting(4,0);
     128:	60 e0       	ldi	r22, 0x00	; 0
     12a:	84 e0       	ldi	r24, 0x04	; 4
     12c:	0e 94 bd 09 	call	0x137a	; 0x137a <xQueueCreateCountingSemaphore>
     130:	90 93 eb 06 	sts	0x06EB, r25	; 0x8006eb <Switch0_Couting_Semaphore+0x1>
     134:	80 93 ea 06 	sts	0x06EA, r24	; 0x8006ea <Switch0_Couting_Semaphore>
	while(1)
	{
		
		xLastWakeTime=xTaskGetTickCount();
     138:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xTaskGetTickCount>
     13c:	9a 83       	std	Y+2, r25	; 0x02
     13e:	89 83       	std	Y+1, r24	; 0x01
		Debug_By_Toggle(27);
     140:	8b e1       	ldi	r24, 0x1B	; 27
     142:	90 e0       	ldi	r25, 0x00	; 0
     144:	0e 94 85 06 	call	0xd0a	; 0xd0a <Debug_By_Toggle>
		/*Read switch 0 */
		Read_Switch(switch0,&u8_value_of_switch);
     148:	be 01       	movw	r22, r28
     14a:	6d 5f       	subi	r22, 0xFD	; 253
     14c:	7f 4f       	sbci	r23, 0xFF	; 255
     14e:	88 e0       	ldi	r24, 0x08	; 8
     150:	0e 94 f3 04 	call	0x9e6	; 0x9e6 <DIO_Read_Pin>
		/*if it is high increment the global variable */
		if(u8_value_of_switch==HIGH)
     154:	8b 81       	ldd	r24, Y+3	; 0x03
     156:	81 30       	cpi	r24, 0x01	; 1
     158:	99 f4       	brne	.+38     	; 0x180 <Send_Switch_State+0x64>
		{
			if(uxSemaphoreGetCount(Switch0_Couting_Semaphore)<4)
     15a:	80 91 ea 06 	lds	r24, 0x06EA	; 0x8006ea <Switch0_Couting_Semaphore>
     15e:	90 91 eb 06 	lds	r25, 0x06EB	; 0x8006eb <Switch0_Couting_Semaphore+0x1>
     162:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <uxQueueMessagesWaiting>
     166:	84 30       	cpi	r24, 0x04	; 4
     168:	58 f4       	brcc	.+22     	; 0x180 <Send_Switch_State+0x64>
			{
				/*Increment counting semaphore*/
				xSemaphoreGive(Switch0_Couting_Semaphore);
     16a:	20 e0       	ldi	r18, 0x00	; 0
     16c:	40 e0       	ldi	r20, 0x00	; 0
     16e:	50 e0       	ldi	r21, 0x00	; 0
     170:	60 e0       	ldi	r22, 0x00	; 0
     172:	70 e0       	ldi	r23, 0x00	; 0
     174:	80 91 ea 06 	lds	r24, 0x06EA	; 0x8006ea <Switch0_Couting_Semaphore>
     178:	90 91 eb 06 	lds	r25, 0x06EB	; 0x8006eb <Switch0_Couting_Semaphore+0x1>
     17c:	0e 94 c9 09 	call	0x1392	; 0x1392 <xQueueGenericSend>
		}
		else
		{
			/*Do nothing*/
		}
		Debug_By_Toggle(27);
     180:	8b e1       	ldi	r24, 0x1B	; 27
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	0e 94 85 06 	call	0xd0a	; 0xd0a <Debug_By_Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
     188:	62 e3       	ldi	r22, 0x32	; 50
     18a:	70 e0       	ldi	r23, 0x00	; 0
     18c:	ce 01       	movw	r24, r28
     18e:	01 96       	adiw	r24, 0x01	; 1
     190:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskDelayUntil>
	}
     194:	d1 cf       	rjmp	.-94     	; 0x138 <Send_Switch_State+0x1c>

00000196 <UART_Send_Data_Received>:
}

void UART_Send_Data_Received(void*Pv_Parameter)					/** Periodicity 200 milisecond     -- Priority is 2**//**Execution time range micro    **/
{
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <UART_Send_Data_Received+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
	
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 200;
    vSemaphoreCreateBinary(Uart_Receive_New_Charachter_Semaphore);
     1a0:	43 e0       	ldi	r20, 0x03	; 3
     1a2:	60 e0       	ldi	r22, 0x00	; 0
     1a4:	81 e0       	ldi	r24, 0x01	; 1
     1a6:	0e 94 90 09 	call	0x1320	; 0x1320 <xQueueGenericCreate>
     1aa:	90 93 e9 06 	sts	0x06E9, r25	; 0x8006e9 <Uart_Receive_New_Charachter_Semaphore+0x1>
     1ae:	80 93 e8 06 	sts	0x06E8, r24	; 0x8006e8 <Uart_Receive_New_Charachter_Semaphore>
     1b2:	00 97       	sbiw	r24, 0x00	; 0
     1b4:	39 f0       	breq	.+14     	; 0x1c4 <UART_Send_Data_Received+0x2e>
     1b6:	20 e0       	ldi	r18, 0x00	; 0
     1b8:	40 e0       	ldi	r20, 0x00	; 0
     1ba:	50 e0       	ldi	r21, 0x00	; 0
     1bc:	60 e0       	ldi	r22, 0x00	; 0
     1be:	70 e0       	ldi	r23, 0x00	; 0
     1c0:	0e 94 c9 09 	call	0x1392	; 0x1392 <xQueueGenericSend>
    vSemaphoreCreateBinary(	UART_RTOS_New_Data_Semaphore);
     1c4:	43 e0       	ldi	r20, 0x03	; 3
     1c6:	60 e0       	ldi	r22, 0x00	; 0
     1c8:	81 e0       	ldi	r24, 0x01	; 1
     1ca:	0e 94 90 09 	call	0x1320	; 0x1320 <xQueueGenericCreate>
     1ce:	90 93 ed 06 	sts	0x06ED, r25	; 0x8006ed <UART_RTOS_New_Data_Semaphore+0x1>
     1d2:	80 93 ec 06 	sts	0x06EC, r24	; 0x8006ec <UART_RTOS_New_Data_Semaphore>
     1d6:	00 97       	sbiw	r24, 0x00	; 0
     1d8:	39 f0       	breq	.+14     	; 0x1e8 <UART_Send_Data_Received+0x52>
     1da:	20 e0       	ldi	r18, 0x00	; 0
     1dc:	40 e0       	ldi	r20, 0x00	; 0
     1de:	50 e0       	ldi	r21, 0x00	; 0
     1e0:	60 e0       	ldi	r22, 0x00	; 0
     1e2:	70 e0       	ldi	r23, 0x00	; 0
     1e4:	0e 94 c9 09 	call	0x1392	; 0x1392 <xQueueGenericSend>
	while(1)
	{

		xLastWakeTime=xTaskGetTickCount();
     1e8:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xTaskGetTickCount>
     1ec:	9a 83       	std	Y+2, r25	; 0x02
     1ee:	89 83       	std	Y+1, r24	; 0x01
		Debug_By_Toggle(28);
     1f0:	8c e1       	ldi	r24, 0x1C	; 28
     1f2:	90 e0       	ldi	r25, 0x00	; 0
     1f4:	0e 94 85 06 	call	0xd0a	; 0xd0a <Debug_By_Toggle>
		xSemaphoreTake(Uart_Receive_New_Charachter_Semaphore,0);
     1f8:	60 e0       	ldi	r22, 0x00	; 0
     1fa:	70 e0       	ldi	r23, 0x00	; 0
     1fc:	80 91 e8 06 	lds	r24, 0x06E8	; 0x8006e8 <Uart_Receive_New_Charachter_Semaphore>
     200:	90 91 e9 06 	lds	r25, 0x06E9	; 0x8006e9 <Uart_Receive_New_Charachter_Semaphore+0x1>
     204:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <xQueueSemaphoreTake>
        if(UART_RecByte(&u8_UART_character)!=UART_RTOS_Not_New_Data)
     208:	84 e6       	ldi	r24, 0x64	; 100
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	0e 94 54 06 	call	0xca8	; 0xca8 <UART_RecByte>
     210:	89 30       	cpi	r24, 0x09	; 9
     212:	41 f0       	breq	.+16     	; 0x224 <UART_Send_Data_Received+0x8e>
		{
			xSemaphoreTake(UART_RTOS_New_Data_Semaphore,0);	
     214:	60 e0       	ldi	r22, 0x00	; 0
     216:	70 e0       	ldi	r23, 0x00	; 0
     218:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <UART_RTOS_New_Data_Semaphore>
     21c:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <UART_RTOS_New_Data_Semaphore+0x1>
     220:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <xQueueSemaphoreTake>
		}
		xSemaphoreGive(Uart_Receive_New_Charachter_Semaphore);
     224:	20 e0       	ldi	r18, 0x00	; 0
     226:	40 e0       	ldi	r20, 0x00	; 0
     228:	50 e0       	ldi	r21, 0x00	; 0
     22a:	60 e0       	ldi	r22, 0x00	; 0
     22c:	70 e0       	ldi	r23, 0x00	; 0
     22e:	80 91 e8 06 	lds	r24, 0x06E8	; 0x8006e8 <Uart_Receive_New_Charachter_Semaphore>
     232:	90 91 e9 06 	lds	r25, 0x06E9	; 0x8006e9 <Uart_Receive_New_Charachter_Semaphore+0x1>
     236:	0e 94 c9 09 	call	0x1392	; 0x1392 <xQueueGenericSend>
		Debug_By_Toggle(28);
     23a:	8c e1       	ldi	r24, 0x1C	; 28
     23c:	90 e0       	ldi	r25, 0x00	; 0
     23e:	0e 94 85 06 	call	0xd0a	; 0xd0a <Debug_By_Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
     242:	68 ec       	ldi	r22, 0xC8	; 200
     244:	70 e0       	ldi	r23, 0x00	; 0
     246:	ce 01       	movw	r24, r28
     248:	01 96       	adiw	r24, 0x01	; 1
     24a:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskDelayUntil>
	}
     24e:	cc cf       	rjmp	.-104    	; 0x1e8 <UART_Send_Data_Received+0x52>

00000250 <Temp_Sensor_Send_Data>:
}

void Temp_Sensor_Send_Data(void*Pv_Parameter)				    /** Periodicity 200 milisecond    -- Priority is 2**//**Execution time range micro    **/
{
     250:	cf 93       	push	r28
     252:	df 93       	push	r29
     254:	00 d0       	rcall	.+0      	; 0x256 <Temp_Sensor_Send_Data+0x6>
     256:	cd b7       	in	r28, 0x3d	; 61
     258:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 200;
	vSemaphoreCreateBinary(Temp_Receive_New_Number_Semaphore);
     25a:	43 e0       	ldi	r20, 0x03	; 3
     25c:	60 e0       	ldi	r22, 0x00	; 0
     25e:	81 e0       	ldi	r24, 0x01	; 1
     260:	0e 94 90 09 	call	0x1320	; 0x1320 <xQueueGenericCreate>
     264:	90 93 e7 06 	sts	0x06E7, r25	; 0x8006e7 <Temp_Receive_New_Number_Semaphore+0x1>
     268:	80 93 e6 06 	sts	0x06E6, r24	; 0x8006e6 <Temp_Receive_New_Number_Semaphore>
     26c:	00 97       	sbiw	r24, 0x00	; 0
     26e:	39 f0       	breq	.+14     	; 0x27e <Temp_Sensor_Send_Data+0x2e>
     270:	20 e0       	ldi	r18, 0x00	; 0
     272:	40 e0       	ldi	r20, 0x00	; 0
     274:	50 e0       	ldi	r21, 0x00	; 0
     276:	60 e0       	ldi	r22, 0x00	; 0
     278:	70 e0       	ldi	r23, 0x00	; 0
     27a:	0e 94 c9 09 	call	0x1392	; 0x1392 <xQueueGenericSend>
	while(1)
	{
		xLastWakeTime=xTaskGetTickCount();
     27e:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xTaskGetTickCount>
     282:	9a 83       	std	Y+2, r25	; 0x02
     284:	89 83       	std	Y+1, r24	; 0x01
		Debug_By_Toggle(29);
     286:	8d e1       	ldi	r24, 0x1D	; 29
     288:	90 e0       	ldi	r25, 0x00	; 0
     28a:	0e 94 85 06 	call	0xd0a	; 0xd0a <Debug_By_Toggle>
		xSemaphoreTake(Temp_Receive_New_Number_Semaphore,0);	
     28e:	60 e0       	ldi	r22, 0x00	; 0
     290:	70 e0       	ldi	r23, 0x00	; 0
     292:	80 91 e6 06 	lds	r24, 0x06E6	; 0x8006e6 <Temp_Receive_New_Number_Semaphore>
     296:	90 91 e7 06 	lds	r25, 0x06E7	; 0x8006e7 <Temp_Receive_New_Number_Semaphore+0x1>
     29a:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <xQueueSemaphoreTake>
        ADC_READ(&u32_TEMP_Number);
     29e:	82 e6       	ldi	r24, 0x62	; 98
     2a0:	90 e0       	ldi	r25, 0x00	; 0
     2a2:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <ADC_READ>
		u32_TEMP_Number=u32_TEMP_Number/2.049;
     2a6:	60 91 62 00 	lds	r22, 0x0062	; 0x800062 <u32_TEMP_Number>
     2aa:	70 91 63 00 	lds	r23, 0x0063	; 0x800063 <u32_TEMP_Number+0x1>
     2ae:	80 e0       	ldi	r24, 0x00	; 0
     2b0:	90 e0       	ldi	r25, 0x00	; 0
     2b2:	0e 94 c3 10 	call	0x2186	; 0x2186 <__floatunsisf>
     2b6:	21 ed       	ldi	r18, 0xD1	; 209
     2b8:	32 e2       	ldi	r19, 0x22	; 34
     2ba:	43 e0       	ldi	r20, 0x03	; 3
     2bc:	50 e4       	ldi	r21, 0x40	; 64
     2be:	0e 94 22 10 	call	0x2044	; 0x2044 <__divsf3>
     2c2:	0e 94 94 10 	call	0x2128	; 0x2128 <__fixunssfsi>
     2c6:	70 93 63 00 	sts	0x0063, r23	; 0x800063 <u32_TEMP_Number+0x1>
     2ca:	60 93 62 00 	sts	0x0062, r22	; 0x800062 <u32_TEMP_Number>
		xSemaphoreGive(Temp_Receive_New_Number_Semaphore);
     2ce:	20 e0       	ldi	r18, 0x00	; 0
     2d0:	40 e0       	ldi	r20, 0x00	; 0
     2d2:	50 e0       	ldi	r21, 0x00	; 0
     2d4:	60 e0       	ldi	r22, 0x00	; 0
     2d6:	70 e0       	ldi	r23, 0x00	; 0
     2d8:	80 91 e6 06 	lds	r24, 0x06E6	; 0x8006e6 <Temp_Receive_New_Number_Semaphore>
     2dc:	90 91 e7 06 	lds	r25, 0x06E7	; 0x8006e7 <Temp_Receive_New_Number_Semaphore+0x1>
     2e0:	0e 94 c9 09 	call	0x1392	; 0x1392 <xQueueGenericSend>
		Debug_By_Toggle(29);
     2e4:	8d e1       	ldi	r24, 0x1D	; 29
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	0e 94 85 06 	call	0xd0a	; 0xd0a <Debug_By_Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
     2ec:	68 ec       	ldi	r22, 0xC8	; 200
     2ee:	70 e0       	ldi	r23, 0x00	; 0
     2f0:	ce 01       	movw	r24, r28
     2f2:	01 96       	adiw	r24, 0x01	; 1
     2f4:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskDelayUntil>
     2f8:	c2 cf       	rjmp	.-124    	; 0x27e <Temp_Sensor_Send_Data+0x2e>

000002fa <LCD_Display_Update>:
	}
}

void LCD_Display_Update(void*Pv_Parameter)                      /** Periodicity 200 milisecond    -- Priority is 1**//**Execution time range micro    **/
{
     2fa:	cf 93       	push	r28
     2fc:	df 93       	push	r29
     2fe:	00 d0       	rcall	.+0      	; 0x300 <LCD_Display_Update+0x6>
     300:	cd b7       	in	r28, 0x3d	; 61
     302:	de b7       	in	r29, 0x3e	; 62
           if(su8_Latched_State_Of_Switch0==LOW)
           {
			    su8_index_Uart_buffer=1;
				LCD_clearScreen();
           }		
		   su8_Latched_State_Of_Switch0=HIGH;
     304:	ee 24       	eor	r14, r14
     306:	e3 94       	inc	r14
		}		
		if(u8_Switch0_Sempahore_Count_Buffer>=2)
		{
           if(su8_Latched_State_Of_Switch0==LOW)
           {
			    su8_index_Uart_buffer=1;
     308:	01 e0       	ldi	r16, 0x01	; 1
     30a:	10 e0       	ldi	r17, 0x00	; 0
	uinteg8_t u8_buffer_for_temp_RTOS_queue=0;
	static uinteg8_t su8_Latched_State_Of_Switch0=LOW;	
	while(1)
	{
			
		xLastWakeTime=xTaskGetTickCount();
     30c:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xTaskGetTickCount>
     310:	9a 83       	std	Y+2, r25	; 0x02
     312:	89 83       	std	Y+1, r24	; 0x01
		Debug_By_Toggle(30);
     314:	8e e1       	ldi	r24, 0x1E	; 30
     316:	90 e0       	ldi	r25, 0x00	; 0
     318:	0e 94 85 06 	call	0xd0a	; 0xd0a <Debug_By_Toggle>
		u8_Switch0_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch0_Couting_Semaphore);		
     31c:	80 91 ea 06 	lds	r24, 0x06EA	; 0x8006ea <Switch0_Couting_Semaphore>
     320:	90 91 eb 06 	lds	r25, 0x06EB	; 0x8006eb <Switch0_Couting_Semaphore+0x1>
     324:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <uxQueueMessagesWaiting>
     328:	f8 2e       	mov	r15, r24
		while(uxSemaphoreGetCount(Switch0_Couting_Semaphore)!=0)
     32a:	08 c0       	rjmp	.+16     	; 0x33c <LCD_Display_Update+0x42>
		{
			xSemaphoreTake(Switch0_Couting_Semaphore,0);
     32c:	60 e0       	ldi	r22, 0x00	; 0
     32e:	70 e0       	ldi	r23, 0x00	; 0
     330:	80 91 ea 06 	lds	r24, 0x06EA	; 0x8006ea <Switch0_Couting_Semaphore>
     334:	90 91 eb 06 	lds	r25, 0x06EB	; 0x8006eb <Switch0_Couting_Semaphore+0x1>
     338:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <xQueueSemaphoreTake>
	{
			
		xLastWakeTime=xTaskGetTickCount();
		Debug_By_Toggle(30);
		u8_Switch0_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch0_Couting_Semaphore);		
		while(uxSemaphoreGetCount(Switch0_Couting_Semaphore)!=0)
     33c:	80 91 ea 06 	lds	r24, 0x06EA	; 0x8006ea <Switch0_Couting_Semaphore>
     340:	90 91 eb 06 	lds	r25, 0x06EB	; 0x8006eb <Switch0_Couting_Semaphore+0x1>
     344:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <uxQueueMessagesWaiting>
     348:	81 11       	cpse	r24, r1
     34a:	f0 cf       	rjmp	.-32     	; 0x32c <LCD_Display_Update+0x32>
		{
			xSemaphoreTake(Switch0_Couting_Semaphore,0);
		}		
		if(u8_Switch0_Sempahore_Count_Buffer>=2)
     34c:	81 e0       	ldi	r24, 0x01	; 1
     34e:	8f 15       	cp	r24, r15
     350:	68 f4       	brcc	.+26     	; 0x36c <LCD_Display_Update+0x72>
		{
           if(su8_Latched_State_Of_Switch0==LOW)
     352:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__data_end>
     356:	81 11       	cpse	r24, r1
     358:	06 c0       	rjmp	.+12     	; 0x366 <LCD_Display_Update+0x6c>
           {
			    su8_index_Uart_buffer=1;
     35a:	10 93 61 00 	sts	0x0061, r17	; 0x800061 <__data_start+0x1>
     35e:	00 93 60 00 	sts	0x0060, r16	; 0x800060 <__data_start>
				LCD_clearScreen();
     362:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_clearScreen>
           }		
		   su8_Latched_State_Of_Switch0=HIGH;
     366:	e0 92 82 00 	sts	0x0082, r14	; 0x800082 <__data_end>
     36a:	02 c0       	rjmp	.+4      	; 0x370 <LCD_Display_Update+0x76>
		
		}
		else
		{
		   su8_Latched_State_Of_Switch0=LOW;			
     36c:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__data_end>
		}
		if(uxSemaphoreGetCount(UART_RTOS_New_Data_Semaphore)==0)
     370:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <UART_RTOS_New_Data_Semaphore>
     374:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <UART_RTOS_New_Data_Semaphore+0x1>
     378:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <uxQueueMessagesWaiting>
     37c:	81 11       	cpse	r24, r1
     37e:	44 c0       	rjmp	.+136    	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
		{
			xSemaphoreGive(UART_RTOS_New_Data_Semaphore);	
     380:	20 e0       	ldi	r18, 0x00	; 0
     382:	40 e0       	ldi	r20, 0x00	; 0
     384:	50 e0       	ldi	r21, 0x00	; 0
     386:	60 e0       	ldi	r22, 0x00	; 0
     388:	70 e0       	ldi	r23, 0x00	; 0
     38a:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <UART_RTOS_New_Data_Semaphore>
     38e:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <UART_RTOS_New_Data_Semaphore+0x1>
     392:	0e 94 c9 09 	call	0x1392	; 0x1392 <xQueueGenericSend>
			xSemaphoreTake(Uart_Receive_New_Charachter_Semaphore,0);
     396:	60 e0       	ldi	r22, 0x00	; 0
     398:	70 e0       	ldi	r23, 0x00	; 0
     39a:	80 91 e8 06 	lds	r24, 0x06E8	; 0x8006e8 <Uart_Receive_New_Charachter_Semaphore>
     39e:	90 91 e9 06 	lds	r25, 0x06E9	; 0x8006e9 <Uart_Receive_New_Charachter_Semaphore+0x1>
     3a2:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <xQueueSemaphoreTake>
			if(su8_index_Uart_buffer==1)
     3a6:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     3aa:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     3ae:	01 97       	sbiw	r24, 0x01	; 1
     3b0:	11 f4       	brne	.+4      	; 0x3b6 <LCD_Display_Update+0xbc>
			{
				LCD_clearScreen();
     3b2:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_clearScreen>
			}
			LCD_goToRowColumn(2,su8_index_Uart_buffer);
     3b6:	60 91 60 00 	lds	r22, 0x0060	; 0x800060 <__data_start>
     3ba:	70 91 61 00 	lds	r23, 0x0061	; 0x800061 <__data_start+0x1>
     3be:	82 e0       	ldi	r24, 0x02	; 2
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	0e 94 09 03 	call	0x612	; 0x612 <LCD_goToRowColumn>
			LCD_displayCharacter(u8_UART_character);
     3c6:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <u8_UART_character>
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	0e 94 c5 02 	call	0x58a	; 0x58a <LCD_displayCharacter>
			if(su8_index_Uart_buffer==16) 
     3d0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     3d4:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     3d8:	80 31       	cpi	r24, 0x10	; 16
     3da:	91 05       	cpc	r25, r1
     3dc:	29 f4       	brne	.+10     	; 0x3e8 <LCD_Display_Update+0xee>
			{
				su8_index_Uart_buffer=1;
     3de:	10 93 61 00 	sts	0x0061, r17	; 0x800061 <__data_start+0x1>
     3e2:	00 93 60 00 	sts	0x0060, r16	; 0x800060 <__data_start>
     3e6:	05 c0       	rjmp	.+10     	; 0x3f2 <LCD_Display_Update+0xf8>
			}
			else
			{
               su8_index_Uart_buffer++;				
     3e8:	01 96       	adiw	r24, 0x01	; 1
     3ea:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     3ee:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
			}
			xSemaphoreGive(Uart_Receive_New_Charachter_Semaphore);					
     3f2:	20 e0       	ldi	r18, 0x00	; 0
     3f4:	40 e0       	ldi	r20, 0x00	; 0
     3f6:	50 e0       	ldi	r21, 0x00	; 0
     3f8:	60 e0       	ldi	r22, 0x00	; 0
     3fa:	70 e0       	ldi	r23, 0x00	; 0
     3fc:	80 91 e8 06 	lds	r24, 0x06E8	; 0x8006e8 <Uart_Receive_New_Charachter_Semaphore>
     400:	90 91 e9 06 	lds	r25, 0x06E9	; 0x8006e9 <Uart_Receive_New_Charachter_Semaphore+0x1>
     404:	0e 94 c9 09 	call	0x1392	; 0x1392 <xQueueGenericSend>
		else
		{

			
		}
		xSemaphoreTake(Temp_Receive_New_Number_Semaphore,0);	
     408:	60 e0       	ldi	r22, 0x00	; 0
     40a:	70 e0       	ldi	r23, 0x00	; 0
     40c:	80 91 e6 06 	lds	r24, 0x06E6	; 0x8006e6 <Temp_Receive_New_Number_Semaphore>
     410:	90 91 e7 06 	lds	r25, 0x06E7	; 0x8006e7 <Temp_Receive_New_Number_Semaphore+0x1>
     414:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <xQueueSemaphoreTake>
		LCD_integerToString(u32_TEMP_Number,1,1);
     418:	a8 01       	movw	r20, r16
     41a:	b8 01       	movw	r22, r16
     41c:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <u32_TEMP_Number>
     420:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <u32_TEMP_Number+0x1>
     424:	0e 94 22 03 	call	0x644	; 0x644 <LCD_integerToString>
		xSemaphoreGive(Temp_Receive_New_Number_Semaphore);	
     428:	20 e0       	ldi	r18, 0x00	; 0
     42a:	40 e0       	ldi	r20, 0x00	; 0
     42c:	50 e0       	ldi	r21, 0x00	; 0
     42e:	60 e0       	ldi	r22, 0x00	; 0
     430:	70 e0       	ldi	r23, 0x00	; 0
     432:	80 91 e6 06 	lds	r24, 0x06E6	; 0x8006e6 <Temp_Receive_New_Number_Semaphore>
     436:	90 91 e7 06 	lds	r25, 0x06E7	; 0x8006e7 <Temp_Receive_New_Number_Semaphore+0x1>
     43a:	0e 94 c9 09 	call	0x1392	; 0x1392 <xQueueGenericSend>

		Debug_By_Toggle(30);
     43e:	8e e1       	ldi	r24, 0x1E	; 30
     440:	90 e0       	ldi	r25, 0x00	; 0
     442:	0e 94 85 06 	call	0xd0a	; 0xd0a <Debug_By_Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
     446:	68 ec       	ldi	r22, 0xC8	; 200
     448:	70 e0       	ldi	r23, 0x00	; 0
     44a:	ce 01       	movw	r24, r28
     44c:	01 96       	adiw	r24, 0x01	; 1
     44e:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskDelayUntil>
	}
     452:	5c cf       	rjmp	.-328    	; 0x30c <LCD_Display_Update+0x12>

00000454 <main>:
}

int main(void)
{
     454:	ef 92       	push	r14
     456:	ff 92       	push	r15
     458:	0f 93       	push	r16
    /**Create the task of System_Init where it uses 100 word from stack and has priority 4*/
    xTaskCreate(System_Init               ,NULL,100,NULL,4,&SYS_Handler);		
     45a:	0f 2e       	mov	r0, r31
     45c:	fb e8       	ldi	r31, 0x8B	; 139
     45e:	ef 2e       	mov	r14, r31
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	ff 2e       	mov	r15, r31
     464:	f0 2d       	mov	r31, r0
     466:	04 e0       	ldi	r16, 0x04	; 4
     468:	20 e0       	ldi	r18, 0x00	; 0
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	44 e6       	ldi	r20, 0x64	; 100
     46e:	50 e0       	ldi	r21, 0x00	; 0
     470:	60 e0       	ldi	r22, 0x00	; 0
     472:	70 e0       	ldi	r23, 0x00	; 0
     474:	89 e4       	ldi	r24, 0x49	; 73
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	0e 94 a2 0b 	call	0x1744	; 0x1744 <xTaskCreate>
    /**Create the task of Check_Switches where it uses 100 word from stack and has priority 3*/
    xTaskCreate(Send_Switch_State         ,NULL,100,NULL,3,&Switches_Handler);	
     47c:	0f 2e       	mov	r0, r31
     47e:	f9 e8       	ldi	r31, 0x89	; 137
     480:	ef 2e       	mov	r14, r31
     482:	f0 e0       	ldi	r31, 0x00	; 0
     484:	ff 2e       	mov	r15, r31
     486:	f0 2d       	mov	r31, r0
     488:	03 e0       	ldi	r16, 0x03	; 3
     48a:	20 e0       	ldi	r18, 0x00	; 0
     48c:	30 e0       	ldi	r19, 0x00	; 0
     48e:	44 e6       	ldi	r20, 0x64	; 100
     490:	50 e0       	ldi	r21, 0x00	; 0
     492:	60 e0       	ldi	r22, 0x00	; 0
     494:	70 e0       	ldi	r23, 0x00	; 0
     496:	8e e8       	ldi	r24, 0x8E	; 142
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	0e 94 a2 0b 	call	0x1744	; 0x1744 <xTaskCreate>
    /**Create the task of UART_rec where it uses 100 word from stack and has priority 3*/
    xTaskCreate(UART_Send_Data_Received   ,NULL,100,NULL,2,&UART_rec_Handler);	
     49e:	0f 2e       	mov	r0, r31
     4a0:	f7 e8       	ldi	r31, 0x87	; 135
     4a2:	ef 2e       	mov	r14, r31
     4a4:	f0 e0       	ldi	r31, 0x00	; 0
     4a6:	ff 2e       	mov	r15, r31
     4a8:	f0 2d       	mov	r31, r0
     4aa:	02 e0       	ldi	r16, 0x02	; 2
     4ac:	20 e0       	ldi	r18, 0x00	; 0
     4ae:	30 e0       	ldi	r19, 0x00	; 0
     4b0:	44 e6       	ldi	r20, 0x64	; 100
     4b2:	50 e0       	ldi	r21, 0x00	; 0
     4b4:	60 e0       	ldi	r22, 0x00	; 0
     4b6:	70 e0       	ldi	r23, 0x00	; 0
     4b8:	8b ec       	ldi	r24, 0xCB	; 203
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	0e 94 a2 0b 	call	0x1744	; 0x1744 <xTaskCreate>
    /**Create the task of Temp_Sensor_Read_Value where it uses 100 word from stack and has priority 3*/
    xTaskCreate(Temp_Sensor_Send_Data     ,NULL,100,NULL,2,&Temp_Sensor_Send_Data_Handler);
     4c0:	0f 2e       	mov	r0, r31
     4c2:	f3 e8       	ldi	r31, 0x83	; 131
     4c4:	ef 2e       	mov	r14, r31
     4c6:	f0 e0       	ldi	r31, 0x00	; 0
     4c8:	ff 2e       	mov	r15, r31
     4ca:	f0 2d       	mov	r31, r0
     4cc:	20 e0       	ldi	r18, 0x00	; 0
     4ce:	30 e0       	ldi	r19, 0x00	; 0
     4d0:	44 e6       	ldi	r20, 0x64	; 100
     4d2:	50 e0       	ldi	r21, 0x00	; 0
     4d4:	60 e0       	ldi	r22, 0x00	; 0
     4d6:	70 e0       	ldi	r23, 0x00	; 0
     4d8:	88 e2       	ldi	r24, 0x28	; 40
     4da:	91 e0       	ldi	r25, 0x01	; 1
     4dc:	0e 94 a2 0b 	call	0x1744	; 0x1744 <xTaskCreate>
    /**Create the task of UART_rec where it uses 100 word from stack and has priority 3*/
    xTaskCreate(LCD_Display_Update        ,NULL,100,NULL,1,&LCD_Display_Update_Handler);
     4e0:	0f 2e       	mov	r0, r31
     4e2:	f5 e8       	ldi	r31, 0x85	; 133
     4e4:	ef 2e       	mov	r14, r31
     4e6:	f0 e0       	ldi	r31, 0x00	; 0
     4e8:	ff 2e       	mov	r15, r31
     4ea:	f0 2d       	mov	r31, r0
     4ec:	01 e0       	ldi	r16, 0x01	; 1
     4ee:	20 e0       	ldi	r18, 0x00	; 0
     4f0:	30 e0       	ldi	r19, 0x00	; 0
     4f2:	44 e6       	ldi	r20, 0x64	; 100
     4f4:	50 e0       	ldi	r21, 0x00	; 0
     4f6:	60 e0       	ldi	r22, 0x00	; 0
     4f8:	70 e0       	ldi	r23, 0x00	; 0
     4fa:	8d e7       	ldi	r24, 0x7D	; 125
     4fc:	91 e0       	ldi	r25, 0x01	; 1
     4fe:	0e 94 a2 0b 	call	0x1744	; 0x1744 <xTaskCreate>

	/*Os start  */
	vTaskStartScheduler();
     502:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <vTaskStartScheduler>
}
     506:	80 e0       	ldi	r24, 0x00	; 0
     508:	90 e0       	ldi	r25, 0x00	; 0
     50a:	0f 91       	pop	r16
     50c:	ff 90       	pop	r15
     50e:	ef 90       	pop	r14
     510:	08 95       	ret

00000512 <LCD_sendCommand>:
		

}

ERROR_TYPE_t LCD_sendCommand(uinteg8_t u8_command)
{
     512:	cf 93       	push	r28
     514:	c8 2f       	mov	r28, r24
	uinteg8_t au8_error;

		CLR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
     516:	d9 98       	cbi	0x1b, 1	; 27
		CLR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
     518:	da 98       	cbi	0x1b, 2	; 27
/*		Debug_By_Toggle(22);	*/	
		SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
     51a:	db 9a       	sbi	0x1b, 3	; 27
        vTaskDelay(2/portTICK_PERIOD_MS);
     51c:	82 e0       	ldi	r24, 0x02	; 2
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vTaskDelay>
/*		Debug_By_Toggle(22);*/
#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
		LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (u8_command & 0xF0);
     524:	8b b3       	in	r24, 0x1b	; 27
     526:	8f 70       	andi	r24, 0x0F	; 15
     528:	9c 2f       	mov	r25, r28
     52a:	90 7f       	andi	r25, 0xF0	; 240
     52c:	89 2b       	or	r24, r25
     52e:	8b bb       	out	0x1b, r24	; 27
#endif
#elif (DATA_BITS_MODE == 8)
		LCD_DATA_PORT = u8_command; /* out the required command to the data bus D0 --> D7 */
#endif
/*		Debug_By_Toggle(22);	*/	
		CLR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
     530:	db 98       	cbi	0x1b, 3	; 27
	    vTaskDelay(2/portTICK_PERIOD_MS);
     532:	82 e0       	ldi	r24, 0x02	; 2
     534:	90 e0       	ldi	r25, 0x00	; 0
     536:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vTaskDelay>
/*		Debug_By_Toggle(22);*/		
		SET_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
     53a:	db 9a       	sbi	0x1b, 3	; 27
        vTaskDelay(2/portTICK_PERIOD_MS);
     53c:	82 e0       	ldi	r24, 0x02	; 2
     53e:	90 e0       	ldi	r25, 0x00	; 0
     540:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vTaskDelay>
/*		Debug_By_Toggle(22);*/		
#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
		LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((u8_command & 0x0F) << 4);
     544:	8b b3       	in	r24, 0x1b	; 27
     546:	28 2f       	mov	r18, r24
     548:	2f 70       	andi	r18, 0x0F	; 15
     54a:	30 e1       	ldi	r19, 0x10	; 16
     54c:	c3 9f       	mul	r28, r19
     54e:	c0 01       	movw	r24, r0
     550:	11 24       	eor	r1, r1
     552:	82 2b       	or	r24, r18
     554:	8b bb       	out	0x1b, r24	; 27
#else
		LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (u8_command & 0x0F);
#endif
#endif
/*		Debug_By_Toggle(22);	*/	
		CLR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
     556:	db 98       	cbi	0x1b, 3	; 27
        vTaskDelay(2/portTICK_PERIOD_MS);
     558:	82 e0       	ldi	r24, 0x02	; 2
     55a:	90 e0       	ldi	r25, 0x00	; 0
     55c:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vTaskDelay>
/*		Debug_By_Toggle(22);*/
}
     560:	cf 91       	pop	r28
     562:	08 95       	ret

00000564 <LCD_init>:
static uinteg8_t gu8_display_row_col=NULL;
ERROR_TYPE_t LCD_init(void)
{
	uinteg8_t au8_error=8;

		LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW);
     564:	8a b3       	in	r24, 0x1a	; 26
     566:	8e 60       	ori	r24, 0x0E	; 14
     568:	8a bb       	out	0x1a, r24	; 26
#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
		LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
     56a:	8a b3       	in	r24, 0x1a	; 26
     56c:	80 6f       	ori	r24, 0xF0	; 240
     56e:	8a bb       	out	0x1a, r24	; 26
		LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
     570:	82 e0       	ldi	r24, 0x02	; 2
     572:	0e 94 89 02 	call	0x512	; 0x512 <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
		LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
		LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

		LCD_sendCommand(0x28); /* cursor off */
     576:	88 e2       	ldi	r24, 0x28	; 40
     578:	0e 94 89 02 	call	0x512	; 0x512 <LCD_sendCommand>

		LCD_sendCommand(CURSOR_OFF);
     57c:	8c e0       	ldi	r24, 0x0C	; 12
     57e:	0e 94 89 02 	call	0x512	; 0x512 <LCD_sendCommand>
		LCD_sendCommand(0x01);
     582:	81 e0       	ldi	r24, 0x01	; 1
     584:	0e 94 89 02 	call	0x512	; 0x512 <LCD_sendCommand>
		
		

}
     588:	08 95       	ret

0000058a <LCD_displayCharacter>:
        vTaskDelay(2/portTICK_PERIOD_MS);
/*		Debug_By_Toggle(22);*/
}

ERROR_TYPE_t LCD_displayCharacter(uinteg8_t u8_data)
{
     58a:	cf 93       	push	r28
     58c:	c8 2f       	mov	r28, r24
	uinteg8_t au8_error=NULL;

			SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
     58e:	d9 9a       	sbi	0x1b, 1	; 27
			CLR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
     590:	da 98       	cbi	0x1b, 2	; 27
			SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
     592:	db 9a       	sbi	0x1b, 3	; 27
			vTaskDelay(1/portTICK_PERIOD_MS);
     594:	81 e0       	ldi	r24, 0x01	; 1
     596:	90 e0       	ldi	r25, 0x00	; 0
     598:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vTaskDelay>
			#if (DATA_BITS_MODE == 4) /* out the highest 4 bits of the required data to the data bus D4 --> D7 */
			#ifdef UPPER_PORT_PINS
			LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (u8_data & 0xF0);
     59c:	8b b3       	in	r24, 0x1b	; 27
     59e:	8f 70       	andi	r24, 0x0F	; 15
     5a0:	9c 2f       	mov	r25, r28
     5a2:	90 7f       	andi	r25, 0xF0	; 240
     5a4:	89 2b       	or	r24, r25
     5a6:	8b bb       	out	0x1b, r24	; 27
			LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((u8_data & 0xF0) >> 4);
			#endif
			#elif (DATA_BITS_MODE == 8)
			LCD_DATA_PORT = u8_data; /* out the required command to the data bus D0 --> D7 */
			#endif	
			CLR_BIT(LCD_CTRL_PORT,E); /* DISABLE LCD E=1 */
     5a8:	db 98       	cbi	0x1b, 3	; 27
			vTaskDelay(1/portTICK_PERIOD_MS);
     5aa:	81 e0       	ldi	r24, 0x01	; 1
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vTaskDelay>
			SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
     5b2:	db 9a       	sbi	0x1b, 3	; 27
			vTaskDelay(1/portTICK_PERIOD_MS);		
     5b4:	81 e0       	ldi	r24, 0x01	; 1
     5b6:	90 e0       	ldi	r25, 0x00	; 0
     5b8:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vTaskDelay>
			#ifdef UPPER_PORT_PINS
			LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((u8_data & 0x0F) << 4);
     5bc:	8b b3       	in	r24, 0x1b	; 27
     5be:	28 2f       	mov	r18, r24
     5c0:	2f 70       	andi	r18, 0x0F	; 15
     5c2:	30 e1       	ldi	r19, 0x10	; 16
     5c4:	c3 9f       	mul	r28, r19
     5c6:	c0 01       	movw	r24, r0
     5c8:	11 24       	eor	r1, r1
     5ca:	82 2b       	or	r24, r18
     5cc:	8b bb       	out	0x1b, r24	; 27
			#else
			LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (u8_data & 0x0F);
			#endif
			CLR_BIT(LCD_CTRL_PORT,E); /* DISABLE LCD E=1 */
     5ce:	db 98       	cbi	0x1b, 3	; 27
			vTaskDelay(1/portTICK_PERIOD_MS);			
     5d0:	81 e0       	ldi	r24, 0x01	; 1
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vTaskDelay>


	return au8_error;
}
     5d8:	80 e0       	ldi	r24, 0x00	; 0
     5da:	cf 91       	pop	r28
     5dc:	08 95       	ret

000005de <LCD_displayString>:

ERROR_TYPE_t LCD_displayString(const uinteg8_t * ptr_String)
{
     5de:	0f 93       	push	r16
     5e0:	1f 93       	push	r17
     5e2:	cf 93       	push	r28
     5e4:	fc 01       	movw	r30, r24
  uinteg8_t u8_string_index=0;
  while(ptr_String[u8_string_index])
     5e6:	80 81       	ld	r24, Z
     5e8:	88 23       	and	r24, r24
     5ea:	59 f0       	breq	.+22     	; 0x602 <LCD_displayString+0x24>
     5ec:	8f 01       	movw	r16, r30
     5ee:	c0 e0       	ldi	r28, 0x00	; 0
  {

	  LCD_displayCharacter(ptr_String[u8_string_index]);
     5f0:	0e 94 c5 02 	call	0x58a	; 0x58a <LCD_displayCharacter>
	  u8_string_index++;
     5f4:	cf 5f       	subi	r28, 0xFF	; 255
}

ERROR_TYPE_t LCD_displayString(const uinteg8_t * ptr_String)
{
  uinteg8_t u8_string_index=0;
  while(ptr_String[u8_string_index])
     5f6:	f8 01       	movw	r30, r16
     5f8:	ec 0f       	add	r30, r28
     5fa:	f1 1d       	adc	r31, r1
     5fc:	80 81       	ld	r24, Z
     5fe:	81 11       	cpse	r24, r1
     600:	f7 cf       	rjmp	.-18     	; 0x5f0 <LCD_displayString+0x12>
  {

	  LCD_displayCharacter(ptr_String[u8_string_index]);
	  u8_string_index++;
  }
}
     602:	cf 91       	pop	r28
     604:	1f 91       	pop	r17
     606:	0f 91       	pop	r16
     608:	08 95       	ret

0000060a <LCD_clearScreen>:

void LCD_clearScreen(void)
{
	LCD_sendCommand(CLEAR_COMMAND); //clear display
     60a:	81 e0       	ldi	r24, 0x01	; 1
     60c:	0e 94 89 02 	call	0x512	; 0x512 <LCD_sendCommand>
     610:	08 95       	ret

00000612 <LCD_goToRowColumn>:
}

void LCD_goToRowColumn(uinteg8_t row, uinteg8_t col)
{
	uinteg8_t address;
	switch(row)
     612:	81 30       	cpi	r24, 0x01	; 1
     614:	19 f0       	breq	.+6      	; 0x61c <LCD_goToRowColumn+0xa>
     616:	82 30       	cpi	r24, 0x02	; 2
     618:	21 f0       	breq	.+8      	; 0x622 <LCD_goToRowColumn+0x10>
     61a:	05 c0       	rjmp	.+10     	; 0x626 <LCD_goToRowColumn+0x14>
	{
		case 1:
			address = 0x80 + col-1;
     61c:	9f e7       	ldi	r25, 0x7F	; 127
     61e:	96 0f       	add	r25, r22
			//OR LCD_sendCommand(0x80).
			break;
     620:	02 c0       	rjmp	.+4      	; 0x626 <LCD_goToRowColumn+0x14>
		case 2:
			address = 0xC0 + col-1;
     622:	9f eb       	ldi	r25, 0xBF	; 191
     624:	96 0f       	add	r25, r22
		default:
			break;
			//Nothing.
	}

    LCD_sendCommand(address | 0b100000000);
     626:	89 2f       	mov	r24, r25
     628:	0e 94 89 02 	call	0x512	; 0x512 <LCD_sendCommand>
     62c:	08 95       	ret

0000062e <LCD_displayStringRowColumn>:

}

void LCD_displayStringRowColumn(uinteg8_t row,uinteg8_t col,const uinteg8_t *Str)
{
     62e:	cf 93       	push	r28
     630:	df 93       	push	r29
     632:	ea 01       	movw	r28, r20
	
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
     634:	0e 94 09 03 	call	0x612	; 0x612 <LCD_goToRowColumn>
	LCD_displayString(Str);
     638:	ce 01       	movw	r24, r28
     63a:	0e 94 ef 02 	call	0x5de	; 0x5de <LCD_displayString>

}
     63e:	df 91       	pop	r29
     640:	cf 91       	pop	r28
     642:	08 95       	ret

00000644 <LCD_integerToString>:
void LCD_integerToString(uinteg32_t value,uinteg8_t row,uinteg8_t col)
{
     644:	0f 93       	push	r16
     646:	1f 93       	push	r17
     648:	cf 93       	push	r28
     64a:	df 93       	push	r29
     64c:	cd b7       	in	r28, 0x3d	; 61
     64e:	de b7       	in	r29, 0x3e	; 62
     650:	a8 97       	sbiw	r28, 0x28	; 40
     652:	0f b6       	in	r0, 0x3f	; 63
     654:	f8 94       	cli
     656:	de bf       	out	0x3e, r29	; 62
     658:	0f be       	out	0x3f, r0	; 63
     65a:	cd bf       	out	0x3d, r28	; 61
     65c:	16 2f       	mov	r17, r22
     65e:	04 2f       	mov	r16, r20
	static uinteg8_t u8_LCD_integerToString_FLAG=1;
	uinteg32_t buffer[20];
	itoa(value, buffer , 10);
     660:	4a e0       	ldi	r20, 0x0A	; 10
     662:	50 e0       	ldi	r21, 0x00	; 0
     664:	be 01       	movw	r22, r28
     666:	6f 5f       	subi	r22, 0xFF	; 255
     668:	7f 4f       	sbci	r23, 0xFF	; 255
     66a:	0e 94 5a 11 	call	0x22b4	; 0x22b4 <itoa>
	LCD_displayStringRowColumn(row,col,buffer);
     66e:	ae 01       	movw	r20, r28
     670:	4f 5f       	subi	r20, 0xFF	; 255
     672:	5f 4f       	sbci	r21, 0xFF	; 255
     674:	60 2f       	mov	r22, r16
     676:	81 2f       	mov	r24, r17
     678:	0e 94 17 03 	call	0x62e	; 0x62e <LCD_displayStringRowColumn>

     67c:	a8 96       	adiw	r28, 0x28	; 40
     67e:	0f b6       	in	r0, 0x3f	; 63
     680:	f8 94       	cli
     682:	de bf       	out	0x3e, r29	; 62
     684:	0f be       	out	0x3f, r0	; 63
     686:	cd bf       	out	0x3d, r28	; 61
     688:	df 91       	pop	r29
     68a:	cf 91       	pop	r28
     68c:	1f 91       	pop	r17
     68e:	0f 91       	pop	r16
     690:	08 95       	ret

00000692 <ADC_INIT>:
/*- GLOBAL EXTERN VARIABLES -------------------------------*/
/*- LOCAL FUNCTIONS PROTOTYPES ----------------------------*/
/*- LOCAL FUNCTIONS IMPLEMENTATION ------------------------*/
/*- APIs IMPLEMENTATION -----------------------------------*/
ADC_Error_t ADC_INIT(gstrADC_Config_t*CopyPntrStr_ADC_Init_Config)
 { 
     692:	cf 93       	push	r28
     694:	df 93       	push	r29
     696:	fc 01       	movw	r30, r24
      if(NullPointer!=CopyPntrStr_ADC_Init_Config)
     698:	89 2b       	or	r24, r25
     69a:	09 f4       	brne	.+2      	; 0x69e <ADC_INIT+0xc>
     69c:	89 c0       	rjmp	.+274    	; 0x7b0 <ADC_INIT+0x11e>
	  {
		    /***Enable ADC unit***/
			ADC_Unit_Enable();
     69e:	37 98       	cbi	0x06, 7	; 6
     6a0:	37 9a       	sbi	0x06, 7	; 6

			/**** Configure the input channel for ADC****/
			if( ( (CopyPntrStr_ADC_Init_Config->ADC_Channel_Choose)<ADC_Channel_0                ) || ( (CopyPntrStr_ADC_Init_Config->ADC_Channel_Choose)>ADC_Channel_7         ) ) 
     6a2:	80 81       	ld	r24, Z
     6a4:	91 81       	ldd	r25, Z+1	; 0x01
     6a6:	88 30       	cpi	r24, 0x08	; 8
     6a8:	91 05       	cpc	r25, r1
     6aa:	20 f0       	brcs	.+8      	; 0x6b4 <ADC_INIT+0x22>
			{			
				sgADC_Error_ADC_INIT_API=ADC_INIT_ERROR_CHANNEL_CHOOSE ;
     6ac:	81 e0       	ldi	r24, 0x01	; 1
     6ae:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <sgADC_Error_ADC_INIT_API>
     6b2:	08 c0       	rjmp	.+16     	; 0x6c4 <ADC_INIT+0x32>
			}
			else
			{

				ADC_Channel_Set(CopyPntrStr_ADC_Init_Config->ADC_Channel_Choose);	 
     6b4:	96 b1       	in	r25, 0x06	; 6
     6b6:	80 95       	com	r24
     6b8:	89 23       	and	r24, r25
     6ba:	86 b9       	out	0x06, r24	; 6
     6bc:	97 b1       	in	r25, 0x07	; 7
     6be:	80 81       	ld	r24, Z
     6c0:	89 2b       	or	r24, r25
     6c2:	87 b9       	out	0x07, r24	; 7
			}
			/**** Configure ADC Refrence voltage****/
			if( ( (CopyPntrStr_ADC_Init_Config->ADC_Reference_Voltage)<ADC_Voltage_Refrence_AREF) || ( (CopyPntrStr_ADC_Init_Config->ADC_Reference_Voltage)>ADC_Voltage_Internal ) )
     6c4:	82 81       	ldd	r24, Z+2	; 0x02
     6c6:	93 81       	ldd	r25, Z+3	; 0x03
     6c8:	81 3c       	cpi	r24, 0xC1	; 193
     6ca:	91 05       	cpc	r25, r1
     6cc:	20 f0       	brcs	.+8      	; 0x6d6 <ADC_INIT+0x44>
			{
				sgADC_Error_ADC_INIT_API=ADC_INIT_ERROR_VOLTAGE_REFRENCE_CHOOSE ;
     6ce:	82 e0       	ldi	r24, 0x02	; 2
     6d0:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <sgADC_Error_ADC_INIT_API>
     6d4:	08 c0       	rjmp	.+16     	; 0x6e6 <ADC_INIT+0x54>
			}
			else
			{
				ADC_Voltage_Refrence_Set(CopyPntrStr_ADC_Init_Config->ADC_Reference_Voltage); 	 
     6d6:	96 b1       	in	r25, 0x06	; 6
     6d8:	80 95       	com	r24
     6da:	89 23       	and	r24, r25
     6dc:	86 b9       	out	0x06, r24	; 6
     6de:	97 b1       	in	r25, 0x07	; 7
     6e0:	82 81       	ldd	r24, Z+2	; 0x02
     6e2:	89 2b       	or	r24, r25
     6e4:	87 b9       	out	0x07, r24	; 7
			}
			/**** Configure ADC sampling frequency ****/
			if( ( (CopyPntrStr_ADC_Init_Config->ADC_Frequency)<ADC_Freq_4MHZ                     ) || ( (CopyPntrStr_ADC_Init_Config->ADC_Frequency)        >ADC_Freq_125KHZ       ) ) 
     6e6:	84 81       	ldd	r24, Z+4	; 0x04
     6e8:	95 81       	ldd	r25, Z+5	; 0x05
     6ea:	07 97       	sbiw	r24, 0x07	; 7
     6ec:	20 f0       	brcs	.+8      	; 0x6f6 <ADC_INIT+0x64>
			{		
				sgADC_Error_ADC_INIT_API=ADC_INIT_ERROR_FREQUENCY_CHOOSE ;
     6ee:	83 e0       	ldi	r24, 0x03	; 3
     6f0:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <sgADC_Error_ADC_INIT_API>
     6f4:	07 c0       	rjmp	.+14     	; 0x704 <ADC_INIT+0x72>
			}
			else
			{
				ADC_Choose_Frequency(CopyPntrStr_ADC_Init_Config->ADC_Frequency);
     6f6:	86 b1       	in	r24, 0x06	; 6
     6f8:	88 7f       	andi	r24, 0xF8	; 248
     6fa:	86 b9       	out	0x06, r24	; 6
     6fc:	96 b1       	in	r25, 0x06	; 6
     6fe:	84 81       	ldd	r24, Z+4	; 0x04
     700:	89 2b       	or	r24, r25
     702:	86 b9       	out	0x06, r24	; 6
			}
			/**** Configure Auto Trigger if it is requested by the user ****/
			if( (CopyPntrStr_ADC_Init_Config->ADC_Auto_Trig_Enable)==ADC_Auto_Trigger_Enable ) 
     704:	86 81       	ldd	r24, Z+6	; 0x06
     706:	97 81       	ldd	r25, Z+7	; 0x07
     708:	85 31       	cpi	r24, 0x15	; 21
     70a:	91 05       	cpc	r25, r1
     70c:	19 f4       	brne	.+6      	; 0x714 <ADC_INIT+0x82>
			{

				ADC_Auto_Trigger_Set();
     70e:	35 98       	cbi	0x06, 5	; 6
     710:	35 9a       	sbi	0x06, 5	; 6
     712:	05 c0       	rjmp	.+10     	; 0x71e <ADC_INIT+0x8c>
			}
			else if ( (CopyPntrStr_ADC_Init_Config->ADC_Auto_Trig_Enable)==ADC_Auto_Trigger_Disable ) 
     714:	46 97       	sbiw	r24, 0x16	; 22
     716:	19 f0       	breq	.+6      	; 0x71e <ADC_INIT+0x8c>
			{
				/*Do Nothing*/
			}
			else
			{			
				sgADC_Error_ADC_INIT_API=ADC_INIT_ERROR_NEITHER_TRIGGER_ENABLE_NOR_DISABLE;
     718:	85 e0       	ldi	r24, 0x05	; 5
     71a:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <sgADC_Error_ADC_INIT_API>
			}
			/**** Configure Source of auto triggering  ****/
			if( ( (CopyPntrStr_ADC_Init_Config->ADC_Auto_Trig_Source)<ADC_Auto_Trig_Source_Free_Running_mode_Bits      ) ||  (CopyPntrStr_ADC_Init_Config->ADC_Auto_Trig_Source)>ADC_No_Need_To_Trigger  )
     71e:	80 85       	ldd	r24, Z+8	; 0x08
     720:	91 85       	ldd	r25, Z+9	; 0x09
     722:	82 3e       	cpi	r24, 0xE2	; 226
     724:	91 05       	cpc	r25, r1
     726:	20 f0       	brcs	.+8      	; 0x730 <ADC_INIT+0x9e>
			{			
				sgADC_Error_ADC_INIT_API=ADC_INIT_ERROR_NO_DEFINED_TRIGGER ;		 
     728:	86 e0       	ldi	r24, 0x06	; 6
     72a:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <sgADC_Error_ADC_INIT_API>
     72e:	0b c0       	rjmp	.+22     	; 0x746 <ADC_INIT+0xb4>
			} 
			else if((CopyPntrStr_ADC_Init_Config->ADC_Auto_Trig_Source)!=ADC_No_Need_To_Trigger  )
     730:	81 3e       	cpi	r24, 0xE1	; 225
     732:	91 05       	cpc	r25, r1
     734:	41 f0       	breq	.+16     	; 0x746 <ADC_INIT+0xb4>
			{
		 	    ADC_Auto_Trigger_Source_Set(CopyPntrStr_ADC_Init_Config->ADC_Auto_Trig_Source);
     736:	90 b7       	in	r25, 0x30	; 48
     738:	80 95       	com	r24
     73a:	89 23       	and	r24, r25
     73c:	80 bf       	out	0x30, r24	; 48
     73e:	90 b7       	in	r25, 0x30	; 48
     740:	80 85       	ldd	r24, Z+8	; 0x08
     742:	89 2b       	or	r24, r25
     744:	80 bf       	out	0x30, r24	; 48
			{
			
				/*Do Nothing*/
			}
			/**** Configure Left or Right Data Register ****/
			if(  (CopyPntrStr_ADC_Init_Config->ADC_Left_Right_Adjustment)==ADC_Left_Adjustment    )  
     746:	82 85       	ldd	r24, Z+10	; 0x0a
     748:	93 85       	ldd	r25, Z+11	; 0x0b
     74a:	80 32       	cpi	r24, 0x20	; 32
     74c:	91 05       	cpc	r25, r1
     74e:	31 f4       	brne	.+12     	; 0x75c <ADC_INIT+0xca>
			{

				ADC_Data_Left_Adjustment_Set(); 
     750:	3d 98       	cbi	0x07, 5	; 7
     752:	3d 9a       	sbi	0x07, 5	; 7
				sgu8_ADC_Left_Adjust_Enabled_Flag=ADC_Left_Adjustment;
     754:	80 e2       	ldi	r24, 0x20	; 32
     756:	80 93 8d 00 	sts	0x008D, r24	; 0x80008d <sgu8_ADC_Left_Adjust_Enabled_Flag>
     75a:	09 c0       	rjmp	.+18     	; 0x76e <ADC_INIT+0xdc>
			}
			else if( (CopyPntrStr_ADC_Init_Config->ADC_Left_Right_Adjustment)==ADC_Right_Adjustment )
     75c:	81 97       	sbiw	r24, 0x21	; 33
     75e:	21 f4       	brne	.+8      	; 0x768 <ADC_INIT+0xd6>
			{
		 
				sgu8_ADC_Left_Adjust_Enabled_Flag=ADC_Right_Adjustment;
     760:	81 e2       	ldi	r24, 0x21	; 33
     762:	80 93 8d 00 	sts	0x008D, r24	; 0x80008d <sgu8_ADC_Left_Adjust_Enabled_Flag>
     766:	03 c0       	rjmp	.+6      	; 0x76e <ADC_INIT+0xdc>
			}	
			else
			{
				sgADC_Error_ADC_INIT_API=ADC_INIT_ERROR_NEITHER_LEFT_NOR_RIGHT;			 
     768:	87 e0       	ldi	r24, 0x07	; 7
     76a:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <sgADC_Error_ADC_INIT_API>
			}
			
			/**Configure Execution Way**/
			if( ( (CopyPntrStr_ADC_Init_Config->ADC_Execution_Method)<ADC_Executed_By_Interrupt      ) || ( (CopyPntrStr_ADC_Init_Config->ADC_Execution_Method)>ADC_Executed_By_Event_Driven  ) )
     76e:	84 85       	ldd	r24, Z+12	; 0x0c
     770:	95 85       	ldd	r25, Z+13	; 0x0d
     772:	9c 01       	movw	r18, r24
     774:	22 52       	subi	r18, 0x22	; 34
     776:	31 09       	sbc	r19, r1
     778:	24 30       	cpi	r18, 0x04	; 4
     77a:	31 05       	cpc	r19, r1
     77c:	20 f0       	brcs	.+8      	; 0x786 <ADC_INIT+0xf4>
			{			
				sgADC_Error_ADC_INIT_API=ADC_INIT_ERROR_NO_DEFINED_EXECUTION_METHOD ;
     77e:	8a e0       	ldi	r24, 0x0A	; 10
     780:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <sgADC_Error_ADC_INIT_API>
     784:	18 c0       	rjmp	.+48     	; 0x7b6 <ADC_INIT+0x124>
			}
			else if(  CopyPntrStr_ADC_Init_Config->ADC_Execution_Method ==ADC_Executed_By_Interrupt || CopyPntrStr_ADC_Init_Config->ADC_Execution_Method ==ADC_Executed_By_Event_Driven)
     786:	82 32       	cpi	r24, 0x22	; 34
     788:	91 05       	cpc	r25, r1
     78a:	19 f0       	breq	.+6      	; 0x792 <ADC_INIT+0x100>
     78c:	85 32       	cpi	r24, 0x25	; 37
     78e:	91 05       	cpc	r25, r1
     790:	31 f4       	brne	.+12     	; 0x79e <ADC_INIT+0x10c>
			{
				sgu8_ADC_Execution_Way=CopyPntrStr_ADC_Init_Config->ADC_Execution_Method;
     792:	80 93 8e 00 	sts	0x008E, r24	; 0x80008e <sgu8_ADC_Execution_Way>
				EnableGeneralInterrupt();
     796:	8f b7       	in	r24, 0x3f	; 63
     798:	80 68       	ori	r24, 0x80	; 128
     79a:	8f bf       	out	0x3f, r24	; 63
     79c:	0c c0       	rjmp	.+24     	; 0x7b6 <ADC_INIT+0x124>
     79e:	ef 01       	movw	r28, r30

			}
			else 
			{
  		        Debug_By_Toggle(16);	             
     7a0:	80 e1       	ldi	r24, 0x10	; 16
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	0e 94 85 06 	call	0xd0a	; 0xd0a <Debug_By_Toggle>
				sgu8_ADC_Execution_Way=CopyPntrStr_ADC_Init_Config->ADC_Execution_Method;
     7a8:	8c 85       	ldd	r24, Y+12	; 0x0c
     7aa:	80 93 8e 00 	sts	0x008E, r24	; 0x80008e <sgu8_ADC_Execution_Way>
     7ae:	03 c0       	rjmp	.+6      	; 0x7b6 <ADC_INIT+0x124>
     		}
	}
	else
	{
		sgADC_Error_ADC_INIT_API=ADC_INIT_ERROR_Config_Pointer_Point_To_NULL;
     7b0:	89 e0       	ldi	r24, 0x09	; 9
     7b2:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <sgADC_Error_ADC_INIT_API>
	}
		 return  sgADC_Error_ADC_INIT_API;     
 }
     7b6:	80 91 8f 00 	lds	r24, 0x008F	; 0x80008f <sgADC_Error_ADC_INIT_API>
     7ba:	df 91       	pop	r29
     7bc:	cf 91       	pop	r28
     7be:	08 95       	ret

000007c0 <ADC_READ>:
 
ADC_Error_t ADC_READ(uinteg32_t* Copyu32_ADC_Value)
{
     7c0:	fc 01       	movw	r30, r24
	 static uinteg8_t  sgu8_ADC_READ_STATE=0;
	 static uinteg32_t su32_Counter=0;
	 static uinteg8_t  su8_first_time_start_conversion_time_event=1;

     /*Check that there is no error occur while initialization*/	 
	 if(sgADC_Error_ADC_INIT_API==ADC_INIT_API_NO_ERROR)
     7c2:	90 91 8f 00 	lds	r25, 0x008F	; 0x80008f <sgADC_Error_ADC_INIT_API>
     7c6:	91 11       	cpse	r25, r1
     7c8:	72 c0       	rjmp	.+228    	; 0x8ae <__stack+0x4f>
	 { 	
	  	 
         /**Check If the execution way is done by polling **/ 	
		 if(sgu8_ADC_Execution_Way==ADC_Executed_By_Polling)
     7ca:	90 91 8e 00 	lds	r25, 0x008E	; 0x80008e <sgu8_ADC_Execution_Way>
     7ce:	93 32       	cpi	r25, 0x23	; 35
     7d0:	e9 f4       	brne	.+58     	; 0x80c <ADC_READ+0x4c>
		 {

			 ADC_Start_Conversion();
     7d2:	36 9a       	sbi	0x06, 6	; 6
			 while(ADC_Read_Interrupt_Flag_State()==0);
     7d4:	34 9b       	sbis	0x06, 4	; 6
     7d6:	fe cf       	rjmp	.-4      	; 0x7d4 <ADC_READ+0x14>

             /**Check If the data is left adjusted or right**/ 			 
			 if(sgu8_ADC_Left_Adjust_Enabled_Flag==ADC_Left_Adjustment)
     7d8:	80 91 8d 00 	lds	r24, 0x008D	; 0x80008d <sgu8_ADC_Left_Adjust_Enabled_Flag>
     7dc:	80 32       	cpi	r24, 0x20	; 32
     7de:	79 f4       	brne	.+30     	; 0x7fe <ADC_READ+0x3e>
			 {				
				  *Copyu32_ADC_Value=((uinteg32_t)(ADC_DATA_HIGH_REG<<2))|(uinteg8_t)(ADC_DATA_LOW_REG>>6);
     7e0:	85 b1       	in	r24, 0x05	; 5
     7e2:	24 b1       	in	r18, 0x04	; 4
     7e4:	90 e0       	ldi	r25, 0x00	; 0
     7e6:	88 0f       	add	r24, r24
     7e8:	99 1f       	adc	r25, r25
     7ea:	88 0f       	add	r24, r24
     7ec:	99 1f       	adc	r25, r25
     7ee:	22 95       	swap	r18
     7f0:	26 95       	lsr	r18
     7f2:	26 95       	lsr	r18
     7f4:	23 70       	andi	r18, 0x03	; 3
     7f6:	82 2b       	or	r24, r18
     7f8:	91 83       	std	Z+1, r25	; 0x01
     7fa:	80 83       	st	Z, r24
     7fc:	5b c0       	rjmp	.+182    	; 0x8b4 <__stack+0x55>
			 }
			 else
			 {
					u32_ADC_LOW_VALUE = (uinteg32_t)ADC_DATA_LOW_REG;		/* Read lower byte*/
     7fe:	84 b1       	in	r24, 0x04	; 4
					u32_ADC_TOTAL = (uinteg32_t)(ADC_DATA_HIGH_REG<<8);		/* Read higher 2 bits and*/
     800:	25 b1       	in	r18, 0x05	; 5
					*Copyu32_ADC_Value=u32_ADC_TOTAL|u32_ADC_LOW_VALUE ;
     802:	90 e0       	ldi	r25, 0x00	; 0
     804:	92 2b       	or	r25, r18
     806:	91 83       	std	Z+1, r25	; 0x01
     808:	80 83       	st	Z, r24
     80a:	54 c0       	rjmp	.+168    	; 0x8b4 <__stack+0x55>
		 }
         /**Check If the execution way is done by interrupt or event or time driven **/ 	
		 else
		 {
	 
			 if(sgu8_ADC_Execution_Way!=ADC_Executed_By_Time_Driven)
     80c:	94 32       	cpi	r25, 0x24	; 36
     80e:	41 f1       	breq	.+80     	; 0x860 <__stack+0x1>
			 {	
			
				if(su8_first_time_start_conversion_time_event) 
     810:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <su8_first_time_start_conversion_time_event.1617>
     814:	88 23       	and	r24, r24
     816:	29 f0       	breq	.+10     	; 0x822 <ADC_READ+0x62>
				{
					su8_first_time_start_conversion_time_event=1;
     818:	81 e0       	ldi	r24, 0x01	; 1
     81a:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <su8_first_time_start_conversion_time_event.1617>
					ADC_Start_Conversion();
     81e:	36 9a       	sbi	0x06, 6	; 6
     820:	49 c0       	rjmp	.+146    	; 0x8b4 <__stack+0x55>
				}
				else
				{
                    su8_first_time_start_conversion_time_event=0;
     822:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <su8_first_time_start_conversion_time_event.1617>
					if(ADC_Read_Interrupt_Flag_State())
     826:	34 9b       	sbis	0x06, 4	; 6
     828:	45 c0       	rjmp	.+138    	; 0x8b4 <__stack+0x55>
					{
						/**Check If the data is left adjusted or right**/
						if(sgu8_ADC_Left_Adjust_Enabled_Flag==ADC_Left_Adjustment)
     82a:	80 91 8d 00 	lds	r24, 0x008D	; 0x80008d <sgu8_ADC_Left_Adjust_Enabled_Flag>
     82e:	80 32       	cpi	r24, 0x20	; 32
     830:	79 f4       	brne	.+30     	; 0x850 <ADC_READ+0x90>
						{
							*Copyu32_ADC_Value=((uinteg32_t)(ADC_DATA_HIGH_REG<<2))|(uinteg8_t)(ADC_DATA_LOW_REG>>6);
     832:	85 b1       	in	r24, 0x05	; 5
     834:	24 b1       	in	r18, 0x04	; 4
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	88 0f       	add	r24, r24
     83a:	99 1f       	adc	r25, r25
     83c:	88 0f       	add	r24, r24
     83e:	99 1f       	adc	r25, r25
     840:	22 95       	swap	r18
     842:	26 95       	lsr	r18
     844:	26 95       	lsr	r18
     846:	23 70       	andi	r18, 0x03	; 3
     848:	82 2b       	or	r24, r18
     84a:	91 83       	std	Z+1, r25	; 0x01
     84c:	80 83       	st	Z, r24
     84e:	06 c0       	rjmp	.+12     	; 0x85c <ADC_READ+0x9c>
						}
						else
						{
							u32_ADC_LOW_VALUE = (uinteg32_t)ADC_DATA_LOW_REG;		/* Read lower byte*/
     850:	84 b1       	in	r24, 0x04	; 4
							u32_ADC_TOTAL = (uinteg32_t)(ADC_DATA_HIGH_REG<<8);		/* Read higher 2 bits and*/
     852:	25 b1       	in	r18, 0x05	; 5
							*Copyu32_ADC_Value=u32_ADC_TOTAL|u32_ADC_LOW_VALUE ;
     854:	90 e0       	ldi	r25, 0x00	; 0
     856:	92 2b       	or	r25, r18
     858:	91 83       	std	Z+1, r25	; 0x01
     85a:	80 83       	st	Z, r24
						}
						ADC_Start_Conversion();
     85c:	36 9a       	sbi	0x06, 6	; 6
     85e:	2a c0       	rjmp	.+84     	; 0x8b4 <__stack+0x55>
			    }

			 }
			 else
			 {
				if(su8_first_time_start_conversion_time_event)
     860:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <su8_first_time_start_conversion_time_event.1617>
     864:	88 23       	and	r24, r24
     866:	21 f0       	breq	.+8      	; 0x870 <__stack+0x11>
				{
					su8_first_time_start_conversion_time_event=0;
     868:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <su8_first_time_start_conversion_time_event.1617>
					ADC_Start_Conversion();
     86c:	36 9a       	sbi	0x06, 6	; 6
     86e:	22 c0       	rjmp	.+68     	; 0x8b4 <__stack+0x55>
				}
				else
				{
					su8_first_time_start_conversion_time_event=0;
     870:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <su8_first_time_start_conversion_time_event.1617>
					if(ADC_Read_Interrupt_Flag_State())
     874:	34 9b       	sbis	0x06, 4	; 6
     876:	1e c0       	rjmp	.+60     	; 0x8b4 <__stack+0x55>
					{
						/**Check If the data is left adjusted or right**/
						if(sgu8_ADC_Left_Adjust_Enabled_Flag==ADC_Left_Adjustment)
     878:	80 91 8d 00 	lds	r24, 0x008D	; 0x80008d <sgu8_ADC_Left_Adjust_Enabled_Flag>
     87c:	80 32       	cpi	r24, 0x20	; 32
     87e:	79 f4       	brne	.+30     	; 0x89e <__stack+0x3f>
						{
							*Copyu32_ADC_Value=((uinteg32_t)(ADC_DATA_HIGH_REG<<2))|(uinteg8_t)(ADC_DATA_LOW_REG>>6);
     880:	85 b1       	in	r24, 0x05	; 5
     882:	24 b1       	in	r18, 0x04	; 4
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	88 0f       	add	r24, r24
     888:	99 1f       	adc	r25, r25
     88a:	88 0f       	add	r24, r24
     88c:	99 1f       	adc	r25, r25
     88e:	22 95       	swap	r18
     890:	26 95       	lsr	r18
     892:	26 95       	lsr	r18
     894:	23 70       	andi	r18, 0x03	; 3
     896:	82 2b       	or	r24, r18
     898:	91 83       	std	Z+1, r25	; 0x01
     89a:	80 83       	st	Z, r24
     89c:	06 c0       	rjmp	.+12     	; 0x8aa <__stack+0x4b>
						}
						else
						{
							u32_ADC_LOW_VALUE = (uinteg32_t)ADC_DATA_LOW_REG;		/* Read lower byte*/
     89e:	84 b1       	in	r24, 0x04	; 4
							u32_ADC_TOTAL = (uinteg32_t)(ADC_DATA_HIGH_REG<<8);		/* Read higher 2 bits and*/
     8a0:	25 b1       	in	r18, 0x05	; 5
							*Copyu32_ADC_Value=u32_ADC_TOTAL|u32_ADC_LOW_VALUE ;
     8a2:	90 e0       	ldi	r25, 0x00	; 0
     8a4:	92 2b       	or	r25, r18
     8a6:	91 83       	std	Z+1, r25	; 0x01
     8a8:	80 83       	st	Z, r24
						}
						ADC_Start_Conversion();
     8aa:	36 9a       	sbi	0x06, 6	; 6
     8ac:	03 c0       	rjmp	.+6      	; 0x8b4 <__stack+0x55>
			 } 
		 }
	 }
	 else
	 {
		 sgADC_Error_ADC_READ_API=ADC_READ_ERROR_Due_To_ADC_INIT_ERROR;
     8ae:	8f e1       	ldi	r24, 0x1F	; 31
     8b0:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <sgADC_Error_ADC_READ_API>
	 }
	 return sgADC_Error_ADC_READ_API; 
 }
     8b4:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <sgADC_Error_ADC_READ_API>
     8b8:	08 95       	ret

000008ba <DIO_Init_Pin>:
		default :
		return DIO_ERROR_NOK;
		break;
		}
return DIO_ERROR_OK;
}
     8ba:	80 32       	cpi	r24, 0x20	; 32
     8bc:	08 f0       	brcs	.+2      	; 0x8c0 <DIO_Init_Pin+0x6>
     8be:	8f c0       	rjmp	.+286    	; 0x9de <DIO_Init_Pin+0x124>
     8c0:	98 2f       	mov	r25, r24
     8c2:	97 70       	andi	r25, 0x07	; 7
     8c4:	86 95       	lsr	r24
     8c6:	86 95       	lsr	r24
     8c8:	86 95       	lsr	r24
     8ca:	8f 5b       	subi	r24, 0xBF	; 191
     8cc:	82 34       	cpi	r24, 0x42	; 66
     8ce:	51 f1       	breq	.+84     	; 0x924 <DIO_Init_Pin+0x6a>
     8d0:	18 f4       	brcc	.+6      	; 0x8d8 <DIO_Init_Pin+0x1e>
     8d2:	81 34       	cpi	r24, 0x41	; 65
     8d4:	41 f0       	breq	.+16     	; 0x8e6 <DIO_Init_Pin+0x2c>
     8d6:	85 c0       	rjmp	.+266    	; 0x9e2 <DIO_Init_Pin+0x128>
     8d8:	83 34       	cpi	r24, 0x43	; 67
     8da:	09 f4       	brne	.+2      	; 0x8de <DIO_Init_Pin+0x24>
     8dc:	42 c0       	rjmp	.+132    	; 0x962 <DIO_Init_Pin+0xa8>
     8de:	84 34       	cpi	r24, 0x44	; 68
     8e0:	09 f4       	brne	.+2      	; 0x8e4 <DIO_Init_Pin+0x2a>
     8e2:	5e c0       	rjmp	.+188    	; 0x9a0 <DIO_Init_Pin+0xe6>
     8e4:	7e c0       	rjmp	.+252    	; 0x9e2 <DIO_Init_Pin+0x128>
     8e6:	61 11       	cpse	r22, r1
     8e8:	0f c0       	rjmp	.+30     	; 0x908 <DIO_Init_Pin+0x4e>
     8ea:	4a b3       	in	r20, 0x1a	; 26
     8ec:	21 e0       	ldi	r18, 0x01	; 1
     8ee:	30 e0       	ldi	r19, 0x00	; 0
     8f0:	b9 01       	movw	r22, r18
     8f2:	02 c0       	rjmp	.+4      	; 0x8f8 <DIO_Init_Pin+0x3e>
     8f4:	66 0f       	add	r22, r22
     8f6:	77 1f       	adc	r23, r23
     8f8:	9a 95       	dec	r25
     8fa:	e2 f7       	brpl	.-8      	; 0x8f4 <DIO_Init_Pin+0x3a>
     8fc:	cb 01       	movw	r24, r22
     8fe:	80 95       	com	r24
     900:	84 23       	and	r24, r20
     902:	8a bb       	out	0x1a, r24	; 26
     904:	80 e0       	ldi	r24, 0x00	; 0
     906:	08 95       	ret
     908:	4a b3       	in	r20, 0x1a	; 26
     90a:	21 e0       	ldi	r18, 0x01	; 1
     90c:	30 e0       	ldi	r19, 0x00	; 0
     90e:	b9 01       	movw	r22, r18
     910:	02 c0       	rjmp	.+4      	; 0x916 <DIO_Init_Pin+0x5c>
     912:	66 0f       	add	r22, r22
     914:	77 1f       	adc	r23, r23
     916:	9a 95       	dec	r25
     918:	e2 f7       	brpl	.-8      	; 0x912 <DIO_Init_Pin+0x58>
     91a:	cb 01       	movw	r24, r22
     91c:	84 2b       	or	r24, r20
     91e:	8a bb       	out	0x1a, r24	; 26
     920:	80 e0       	ldi	r24, 0x00	; 0
     922:	08 95       	ret
     924:	61 11       	cpse	r22, r1
     926:	0f c0       	rjmp	.+30     	; 0x946 <DIO_Init_Pin+0x8c>
     928:	47 b3       	in	r20, 0x17	; 23
     92a:	21 e0       	ldi	r18, 0x01	; 1
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	b9 01       	movw	r22, r18
     930:	02 c0       	rjmp	.+4      	; 0x936 <DIO_Init_Pin+0x7c>
     932:	66 0f       	add	r22, r22
     934:	77 1f       	adc	r23, r23
     936:	9a 95       	dec	r25
     938:	e2 f7       	brpl	.-8      	; 0x932 <DIO_Init_Pin+0x78>
     93a:	cb 01       	movw	r24, r22
     93c:	80 95       	com	r24
     93e:	84 23       	and	r24, r20
     940:	87 bb       	out	0x17, r24	; 23
     942:	80 e0       	ldi	r24, 0x00	; 0
     944:	08 95       	ret
     946:	47 b3       	in	r20, 0x17	; 23
     948:	21 e0       	ldi	r18, 0x01	; 1
     94a:	30 e0       	ldi	r19, 0x00	; 0
     94c:	b9 01       	movw	r22, r18
     94e:	02 c0       	rjmp	.+4      	; 0x954 <DIO_Init_Pin+0x9a>
     950:	66 0f       	add	r22, r22
     952:	77 1f       	adc	r23, r23
     954:	9a 95       	dec	r25
     956:	e2 f7       	brpl	.-8      	; 0x950 <DIO_Init_Pin+0x96>
     958:	cb 01       	movw	r24, r22
     95a:	84 2b       	or	r24, r20
     95c:	87 bb       	out	0x17, r24	; 23
     95e:	80 e0       	ldi	r24, 0x00	; 0
     960:	08 95       	ret
     962:	61 11       	cpse	r22, r1
     964:	0f c0       	rjmp	.+30     	; 0x984 <DIO_Init_Pin+0xca>
     966:	44 b3       	in	r20, 0x14	; 20
     968:	21 e0       	ldi	r18, 0x01	; 1
     96a:	30 e0       	ldi	r19, 0x00	; 0
     96c:	b9 01       	movw	r22, r18
     96e:	02 c0       	rjmp	.+4      	; 0x974 <DIO_Init_Pin+0xba>
     970:	66 0f       	add	r22, r22
     972:	77 1f       	adc	r23, r23
     974:	9a 95       	dec	r25
     976:	e2 f7       	brpl	.-8      	; 0x970 <DIO_Init_Pin+0xb6>
     978:	cb 01       	movw	r24, r22
     97a:	80 95       	com	r24
     97c:	84 23       	and	r24, r20
     97e:	84 bb       	out	0x14, r24	; 20
     980:	80 e0       	ldi	r24, 0x00	; 0
     982:	08 95       	ret
     984:	44 b3       	in	r20, 0x14	; 20
     986:	21 e0       	ldi	r18, 0x01	; 1
     988:	30 e0       	ldi	r19, 0x00	; 0
     98a:	b9 01       	movw	r22, r18
     98c:	02 c0       	rjmp	.+4      	; 0x992 <DIO_Init_Pin+0xd8>
     98e:	66 0f       	add	r22, r22
     990:	77 1f       	adc	r23, r23
     992:	9a 95       	dec	r25
     994:	e2 f7       	brpl	.-8      	; 0x98e <DIO_Init_Pin+0xd4>
     996:	cb 01       	movw	r24, r22
     998:	84 2b       	or	r24, r20
     99a:	84 bb       	out	0x14, r24	; 20
     99c:	80 e0       	ldi	r24, 0x00	; 0
     99e:	08 95       	ret
     9a0:	61 11       	cpse	r22, r1
     9a2:	0f c0       	rjmp	.+30     	; 0x9c2 <DIO_Init_Pin+0x108>
     9a4:	41 b3       	in	r20, 0x11	; 17
     9a6:	21 e0       	ldi	r18, 0x01	; 1
     9a8:	30 e0       	ldi	r19, 0x00	; 0
     9aa:	b9 01       	movw	r22, r18
     9ac:	02 c0       	rjmp	.+4      	; 0x9b2 <DIO_Init_Pin+0xf8>
     9ae:	66 0f       	add	r22, r22
     9b0:	77 1f       	adc	r23, r23
     9b2:	9a 95       	dec	r25
     9b4:	e2 f7       	brpl	.-8      	; 0x9ae <DIO_Init_Pin+0xf4>
     9b6:	cb 01       	movw	r24, r22
     9b8:	80 95       	com	r24
     9ba:	84 23       	and	r24, r20
     9bc:	81 bb       	out	0x11, r24	; 17
     9be:	80 e0       	ldi	r24, 0x00	; 0
     9c0:	08 95       	ret
     9c2:	41 b3       	in	r20, 0x11	; 17
     9c4:	21 e0       	ldi	r18, 0x01	; 1
     9c6:	30 e0       	ldi	r19, 0x00	; 0
     9c8:	b9 01       	movw	r22, r18
     9ca:	02 c0       	rjmp	.+4      	; 0x9d0 <DIO_Init_Pin+0x116>
     9cc:	66 0f       	add	r22, r22
     9ce:	77 1f       	adc	r23, r23
     9d0:	9a 95       	dec	r25
     9d2:	e2 f7       	brpl	.-8      	; 0x9cc <DIO_Init_Pin+0x112>
     9d4:	cb 01       	movw	r24, r22
     9d6:	84 2b       	or	r24, r20
     9d8:	81 bb       	out	0x11, r24	; 17
     9da:	80 e0       	ldi	r24, 0x00	; 0
     9dc:	08 95       	ret
     9de:	81 e0       	ldi	r24, 0x01	; 1
     9e0:	08 95       	ret
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	08 95       	ret

000009e6 <DIO_Read_Pin>:
     9e6:	80 32       	cpi	r24, 0x20	; 32
     9e8:	08 f0       	brcs	.+2      	; 0x9ec <DIO_Read_Pin+0x6>
     9ea:	4d c0       	rjmp	.+154    	; 0xa86 <DIO_Read_Pin+0xa0>
     9ec:	98 2f       	mov	r25, r24
     9ee:	97 70       	andi	r25, 0x07	; 7
     9f0:	86 95       	lsr	r24
     9f2:	86 95       	lsr	r24
     9f4:	86 95       	lsr	r24
     9f6:	8f 5b       	subi	r24, 0xBF	; 191
     9f8:	82 34       	cpi	r24, 0x42	; 66
     9fa:	c1 f0       	breq	.+48     	; 0xa2c <DIO_Read_Pin+0x46>
     9fc:	18 f4       	brcc	.+6      	; 0xa04 <DIO_Read_Pin+0x1e>
     9fe:	81 34       	cpi	r24, 0x41	; 65
     a00:	31 f0       	breq	.+12     	; 0xa0e <DIO_Read_Pin+0x28>
     a02:	43 c0       	rjmp	.+134    	; 0xa8a <DIO_Read_Pin+0xa4>
     a04:	83 34       	cpi	r24, 0x43	; 67
     a06:	09 f1       	breq	.+66     	; 0xa4a <DIO_Read_Pin+0x64>
     a08:	84 34       	cpi	r24, 0x44	; 68
     a0a:	71 f1       	breq	.+92     	; 0xa68 <DIO_Read_Pin+0x82>
     a0c:	3e c0       	rjmp	.+124    	; 0xa8a <DIO_Read_Pin+0xa4>
     a0e:	89 b3       	in	r24, 0x19	; 25
     a10:	28 2f       	mov	r18, r24
     a12:	30 e0       	ldi	r19, 0x00	; 0
     a14:	a9 01       	movw	r20, r18
     a16:	02 c0       	rjmp	.+4      	; 0xa1c <DIO_Read_Pin+0x36>
     a18:	55 95       	asr	r21
     a1a:	47 95       	ror	r20
     a1c:	9a 95       	dec	r25
     a1e:	e2 f7       	brpl	.-8      	; 0xa18 <DIO_Read_Pin+0x32>
     a20:	ca 01       	movw	r24, r20
     a22:	81 70       	andi	r24, 0x01	; 1
     a24:	fb 01       	movw	r30, r22
     a26:	80 83       	st	Z, r24
     a28:	80 e0       	ldi	r24, 0x00	; 0
     a2a:	08 95       	ret
     a2c:	86 b3       	in	r24, 0x16	; 22
     a2e:	28 2f       	mov	r18, r24
     a30:	30 e0       	ldi	r19, 0x00	; 0
     a32:	a9 01       	movw	r20, r18
     a34:	02 c0       	rjmp	.+4      	; 0xa3a <DIO_Read_Pin+0x54>
     a36:	55 95       	asr	r21
     a38:	47 95       	ror	r20
     a3a:	9a 95       	dec	r25
     a3c:	e2 f7       	brpl	.-8      	; 0xa36 <DIO_Read_Pin+0x50>
     a3e:	ca 01       	movw	r24, r20
     a40:	81 70       	andi	r24, 0x01	; 1
     a42:	fb 01       	movw	r30, r22
     a44:	80 83       	st	Z, r24
     a46:	80 e0       	ldi	r24, 0x00	; 0
     a48:	08 95       	ret
     a4a:	83 b3       	in	r24, 0x13	; 19
     a4c:	28 2f       	mov	r18, r24
     a4e:	30 e0       	ldi	r19, 0x00	; 0
     a50:	a9 01       	movw	r20, r18
     a52:	02 c0       	rjmp	.+4      	; 0xa58 <DIO_Read_Pin+0x72>
     a54:	55 95       	asr	r21
     a56:	47 95       	ror	r20
     a58:	9a 95       	dec	r25
     a5a:	e2 f7       	brpl	.-8      	; 0xa54 <DIO_Read_Pin+0x6e>
     a5c:	ca 01       	movw	r24, r20
     a5e:	81 70       	andi	r24, 0x01	; 1
     a60:	fb 01       	movw	r30, r22
     a62:	80 83       	st	Z, r24
     a64:	80 e0       	ldi	r24, 0x00	; 0
     a66:	08 95       	ret
     a68:	80 b3       	in	r24, 0x10	; 16
     a6a:	28 2f       	mov	r18, r24
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	a9 01       	movw	r20, r18
     a70:	02 c0       	rjmp	.+4      	; 0xa76 <DIO_Read_Pin+0x90>
     a72:	55 95       	asr	r21
     a74:	47 95       	ror	r20
     a76:	9a 95       	dec	r25
     a78:	e2 f7       	brpl	.-8      	; 0xa72 <DIO_Read_Pin+0x8c>
     a7a:	ca 01       	movw	r24, r20
     a7c:	81 70       	andi	r24, 0x01	; 1
     a7e:	fb 01       	movw	r30, r22
     a80:	80 83       	st	Z, r24
     a82:	80 e0       	ldi	r24, 0x00	; 0
     a84:	08 95       	ret
     a86:	81 e0       	ldi	r24, 0x01	; 1
     a88:	08 95       	ret
     a8a:	81 e0       	ldi	r24, 0x01	; 1
     a8c:	08 95       	ret

00000a8e <DIO_toggle_Pin>:
uinteg8_t DIO_toggle_Pin(uinteg8_t pin)
{
	uinteg8_t por;
	if(pin>=PinsNeeded || pin>=No_of_pins ) return DIO_ERROR_NOK;
     a8e:	80 32       	cpi	r24, 0x20	; 32
     a90:	08 f0       	brcs	.+2      	; 0xa94 <DIO_toggle_Pin+0x6>
     a92:	49 c0       	rjmp	.+146    	; 0xb26 <DIO_toggle_Pin+0x98>
	else
	{
		por='A'+pin/PortSize;
		pin=pin%PortSize;
     a94:	98 2f       	mov	r25, r24
     a96:	97 70       	andi	r25, 0x07	; 7
	}
	
	switch(por)
     a98:	86 95       	lsr	r24
     a9a:	86 95       	lsr	r24
     a9c:	86 95       	lsr	r24
     a9e:	8f 5b       	subi	r24, 0xBF	; 191
     aa0:	82 34       	cpi	r24, 0x42	; 66
     aa2:	b9 f0       	breq	.+46     	; 0xad2 <DIO_toggle_Pin+0x44>
     aa4:	18 f4       	brcc	.+6      	; 0xaac <DIO_toggle_Pin+0x1e>
     aa6:	81 34       	cpi	r24, 0x41	; 65
     aa8:	31 f0       	breq	.+12     	; 0xab6 <DIO_toggle_Pin+0x28>
     aaa:	3f c0       	rjmp	.+126    	; 0xb2a <DIO_toggle_Pin+0x9c>
     aac:	83 34       	cpi	r24, 0x43	; 67
     aae:	f9 f0       	breq	.+62     	; 0xaee <DIO_toggle_Pin+0x60>
     ab0:	84 34       	cpi	r24, 0x44	; 68
     ab2:	59 f1       	breq	.+86     	; 0xb0a <DIO_toggle_Pin+0x7c>
     ab4:	3a c0       	rjmp	.+116    	; 0xb2a <DIO_toggle_Pin+0x9c>
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
     ab6:	4b b3       	in	r20, 0x1b	; 27
     ab8:	21 e0       	ldi	r18, 0x01	; 1
     aba:	30 e0       	ldi	r19, 0x00	; 0
     abc:	b9 01       	movw	r22, r18
     abe:	02 c0       	rjmp	.+4      	; 0xac4 <DIO_toggle_Pin+0x36>
     ac0:	66 0f       	add	r22, r22
     ac2:	77 1f       	adc	r23, r23
     ac4:	9a 95       	dec	r25
     ac6:	e2 f7       	brpl	.-8      	; 0xac0 <DIO_toggle_Pin+0x32>
     ac8:	cb 01       	movw	r24, r22
     aca:	84 27       	eor	r24, r20
     acc:	8b bb       	out	0x1b, r24	; 27
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     ace:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	switch(por)
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
     ad0:	08 95       	ret
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
     ad2:	48 b3       	in	r20, 0x18	; 24
     ad4:	21 e0       	ldi	r18, 0x01	; 1
     ad6:	30 e0       	ldi	r19, 0x00	; 0
     ad8:	b9 01       	movw	r22, r18
     ada:	02 c0       	rjmp	.+4      	; 0xae0 <DIO_toggle_Pin+0x52>
     adc:	66 0f       	add	r22, r22
     ade:	77 1f       	adc	r23, r23
     ae0:	9a 95       	dec	r25
     ae2:	e2 f7       	brpl	.-8      	; 0xadc <DIO_toggle_Pin+0x4e>
     ae4:	cb 01       	movw	r24, r22
     ae6:	84 27       	eor	r24, r20
     ae8:	88 bb       	out	0x18, r24	; 24
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     aea:	80 e0       	ldi	r24, 0x00	; 0
	switch(por)
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
     aec:	08 95       	ret
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
     aee:	45 b3       	in	r20, 0x15	; 21
     af0:	21 e0       	ldi	r18, 0x01	; 1
     af2:	30 e0       	ldi	r19, 0x00	; 0
     af4:	b9 01       	movw	r22, r18
     af6:	02 c0       	rjmp	.+4      	; 0xafc <DIO_toggle_Pin+0x6e>
     af8:	66 0f       	add	r22, r22
     afa:	77 1f       	adc	r23, r23
     afc:	9a 95       	dec	r25
     afe:	e2 f7       	brpl	.-8      	; 0xaf8 <DIO_toggle_Pin+0x6a>
     b00:	cb 01       	movw	r24, r22
     b02:	84 27       	eor	r24, r20
     b04:	85 bb       	out	0x15, r24	; 21
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     b06:	80 e0       	ldi	r24, 0x00	; 0
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
			 break;
     b08:	08 95       	ret
		case 'D':TOGGLE_BIT(WriteRegisterD,pin);
     b0a:	42 b3       	in	r20, 0x12	; 18
     b0c:	21 e0       	ldi	r18, 0x01	; 1
     b0e:	30 e0       	ldi	r19, 0x00	; 0
     b10:	b9 01       	movw	r22, r18
     b12:	02 c0       	rjmp	.+4      	; 0xb18 <DIO_toggle_Pin+0x8a>
     b14:	66 0f       	add	r22, r22
     b16:	77 1f       	adc	r23, r23
     b18:	9a 95       	dec	r25
     b1a:	e2 f7       	brpl	.-8      	; 0xb14 <DIO_toggle_Pin+0x86>
     b1c:	cb 01       	movw	r24, r22
     b1e:	84 27       	eor	r24, r20
     b20:	82 bb       	out	0x12, r24	; 18
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     b22:	80 e0       	ldi	r24, 0x00	; 0
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
			 break;
		case 'D':TOGGLE_BIT(WriteRegisterD,pin);
			 break;
     b24:	08 95       	ret
return DIO_ERROR_OK;
}
uinteg8_t DIO_toggle_Pin(uinteg8_t pin)
{
	uinteg8_t por;
	if(pin>=PinsNeeded || pin>=No_of_pins ) return DIO_ERROR_NOK;
     b26:	81 e0       	ldi	r24, 0x01	; 1
     b28:	08 95       	ret
			 break;
		case 'G':TOGGLE_BIT(PORTG,pin);
			 break;
#endif
		default :
		return DIO_ERROR_NOK;
     b2a:	81 e0       	ldi	r24, 0x01	; 1
		break;
		
	}
	return DIO_ERROR_OK;
}
     b2c:	08 95       	ret

00000b2e <__vector_13>:
  }
  else
  {
 
  }
}
     b2e:	1f 92       	push	r1
     b30:	0f 92       	push	r0
     b32:	0f b6       	in	r0, 0x3f	; 63
     b34:	0f 92       	push	r0
     b36:	11 24       	eor	r1, r1
     b38:	2f 93       	push	r18
     b3a:	3f 93       	push	r19
     b3c:	4f 93       	push	r20
     b3e:	5f 93       	push	r21
     b40:	6f 93       	push	r22
     b42:	7f 93       	push	r23
     b44:	8f 93       	push	r24
     b46:	9f 93       	push	r25
     b48:	af 93       	push	r26
     b4a:	bf 93       	push	r27
     b4c:	ef 93       	push	r30
     b4e:	ff 93       	push	r31
     b50:	80 91 93 00 	lds	r24, 0x0093	; 0x800093 <gPntrToFunc_UART_RX_ISR>
     b54:	90 91 94 00 	lds	r25, 0x0094	; 0x800094 <gPntrToFunc_UART_RX_ISR+0x1>
     b58:	89 2b       	or	r24, r25
     b5a:	29 f0       	breq	.+10     	; 0xb66 <__vector_13+0x38>
     b5c:	e0 91 93 00 	lds	r30, 0x0093	; 0x800093 <gPntrToFunc_UART_RX_ISR>
     b60:	f0 91 94 00 	lds	r31, 0x0094	; 0x800094 <gPntrToFunc_UART_RX_ISR+0x1>
     b64:	09 95       	icall
     b66:	ff 91       	pop	r31
     b68:	ef 91       	pop	r30
     b6a:	bf 91       	pop	r27
     b6c:	af 91       	pop	r26
     b6e:	9f 91       	pop	r25
     b70:	8f 91       	pop	r24
     b72:	7f 91       	pop	r23
     b74:	6f 91       	pop	r22
     b76:	5f 91       	pop	r21
     b78:	4f 91       	pop	r20
     b7a:	3f 91       	pop	r19
     b7c:	2f 91       	pop	r18
     b7e:	0f 90       	pop	r0
     b80:	0f be       	out	0x3f, r0	; 63
     b82:	0f 90       	pop	r0
     b84:	1f 90       	pop	r1
     b86:	18 95       	reti

00000b88 <__vector_15>:
     b88:	1f 92       	push	r1
     b8a:	0f 92       	push	r0
     b8c:	0f b6       	in	r0, 0x3f	; 63
     b8e:	0f 92       	push	r0
     b90:	11 24       	eor	r1, r1
     b92:	2f 93       	push	r18
     b94:	3f 93       	push	r19
     b96:	4f 93       	push	r20
     b98:	5f 93       	push	r21
     b9a:	6f 93       	push	r22
     b9c:	7f 93       	push	r23
     b9e:	8f 93       	push	r24
     ba0:	9f 93       	push	r25
     ba2:	af 93       	push	r26
     ba4:	bf 93       	push	r27
     ba6:	ef 93       	push	r30
     ba8:	ff 93       	push	r31
     baa:	80 91 95 00 	lds	r24, 0x0095	; 0x800095 <gPntrToFunc_UART_TX_ISR>
     bae:	90 91 96 00 	lds	r25, 0x0096	; 0x800096 <gPntrToFunc_UART_TX_ISR+0x1>
     bb2:	89 2b       	or	r24, r25
     bb4:	29 f0       	breq	.+10     	; 0xbc0 <__vector_15+0x38>
     bb6:	e0 91 95 00 	lds	r30, 0x0095	; 0x800095 <gPntrToFunc_UART_TX_ISR>
     bba:	f0 91 96 00 	lds	r31, 0x0096	; 0x800096 <gPntrToFunc_UART_TX_ISR+0x1>
     bbe:	09 95       	icall
     bc0:	ff 91       	pop	r31
     bc2:	ef 91       	pop	r30
     bc4:	bf 91       	pop	r27
     bc6:	af 91       	pop	r26
     bc8:	9f 91       	pop	r25
     bca:	8f 91       	pop	r24
     bcc:	7f 91       	pop	r23
     bce:	6f 91       	pop	r22
     bd0:	5f 91       	pop	r21
     bd2:	4f 91       	pop	r20
     bd4:	3f 91       	pop	r19
     bd6:	2f 91       	pop	r18
     bd8:	0f 90       	pop	r0
     bda:	0f be       	out	0x3f, r0	; 63
     bdc:	0f 90       	pop	r0
     bde:	1f 90       	pop	r1
     be0:	18 95       	reti

00000be2 <UART_Init>:
     be2:	fc 01       	movw	r30, r24
     be4:	89 2b       	or	r24, r25
     be6:	09 f4       	brne	.+2      	; 0xbea <UART_Init+0x8>
     be8:	5c c0       	rjmp	.+184    	; 0xca2 <UART_Init+0xc0>
     bea:	10 bc       	out	0x20, r1	; 32
     bec:	82 81       	ldd	r24, Z+2	; 0x02
     bee:	89 b9       	out	0x09, r24	; 9
     bf0:	80 81       	ld	r24, Z
     bf2:	8d 30       	cpi	r24, 0x0D	; 13
     bf4:	19 f4       	brne	.+6      	; 0xbfc <UART_Init+0x1a>
     bf6:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <sgu8_UART_Transimter_enable>
     bfa:	53 9a       	sbi	0x0a, 3	; 10
     bfc:	81 81       	ldd	r24, Z+1	; 0x01
     bfe:	8e 30       	cpi	r24, 0x0E	; 14
     c00:	19 f4       	brne	.+6      	; 0xc08 <UART_Init+0x26>
     c02:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <sgu8_UART_Receiver_enable>
     c06:	54 9a       	sbi	0x0a, 4	; 10
     c08:	83 81       	ldd	r24, Z+3	; 0x03
     c0a:	81 11       	cpse	r24, r1
     c0c:	03 c0       	rjmp	.+6      	; 0xc14 <UART_Init+0x32>
     c0e:	80 b5       	in	r24, 0x20	; 32
     c10:	80 bd       	out	0x20, r24	; 32
     c12:	0b c0       	rjmp	.+22     	; 0xc2a <UART_Init+0x48>
     c14:	81 30       	cpi	r24, 0x01	; 1
     c16:	21 f4       	brne	.+8      	; 0xc20 <UART_Init+0x3e>
     c18:	80 b5       	in	r24, 0x20	; 32
     c1a:	80 62       	ori	r24, 0x20	; 32
     c1c:	80 bd       	out	0x20, r24	; 32
     c1e:	05 c0       	rjmp	.+10     	; 0xc2a <UART_Init+0x48>
     c20:	82 30       	cpi	r24, 0x02	; 2
     c22:	19 f4       	brne	.+6      	; 0xc2a <UART_Init+0x48>
     c24:	80 b5       	in	r24, 0x20	; 32
     c26:	80 63       	ori	r24, 0x30	; 48
     c28:	80 bd       	out	0x20, r24	; 32
     c2a:	83 81       	ldd	r24, Z+3	; 0x03
     c2c:	84 30       	cpi	r24, 0x04	; 4
     c2e:	21 f4       	brne	.+8      	; 0xc38 <UART_Init+0x56>
     c30:	80 b5       	in	r24, 0x20	; 32
     c32:	88 60       	ori	r24, 0x08	; 8
     c34:	80 bd       	out	0x20, r24	; 32
     c36:	04 c0       	rjmp	.+8      	; 0xc40 <UART_Init+0x5e>
     c38:	83 30       	cpi	r24, 0x03	; 3
     c3a:	11 f4       	brne	.+4      	; 0xc40 <UART_Init+0x5e>
     c3c:	80 b5       	in	r24, 0x20	; 32
     c3e:	80 bd       	out	0x20, r24	; 32
     c40:	85 81       	ldd	r24, Z+5	; 0x05
     c42:	85 30       	cpi	r24, 0x05	; 5
     c44:	19 f4       	brne	.+6      	; 0xc4c <UART_Init+0x6a>
     c46:	80 b5       	in	r24, 0x20	; 32
     c48:	80 bd       	out	0x20, r24	; 32
     c4a:	17 c0       	rjmp	.+46     	; 0xc7a <UART_Init+0x98>
     c4c:	86 30       	cpi	r24, 0x06	; 6
     c4e:	21 f4       	brne	.+8      	; 0xc58 <UART_Init+0x76>
     c50:	80 b5       	in	r24, 0x20	; 32
     c52:	82 60       	ori	r24, 0x02	; 2
     c54:	80 bd       	out	0x20, r24	; 32
     c56:	11 c0       	rjmp	.+34     	; 0xc7a <UART_Init+0x98>
     c58:	87 30       	cpi	r24, 0x07	; 7
     c5a:	21 f4       	brne	.+8      	; 0xc64 <UART_Init+0x82>
     c5c:	80 b5       	in	r24, 0x20	; 32
     c5e:	84 60       	ori	r24, 0x04	; 4
     c60:	80 bd       	out	0x20, r24	; 32
     c62:	0b c0       	rjmp	.+22     	; 0xc7a <UART_Init+0x98>
     c64:	88 30       	cpi	r24, 0x08	; 8
     c66:	21 f4       	brne	.+8      	; 0xc70 <UART_Init+0x8e>
     c68:	80 b5       	in	r24, 0x20	; 32
     c6a:	86 60       	ori	r24, 0x06	; 6
     c6c:	80 bd       	out	0x20, r24	; 32
     c6e:	05 c0       	rjmp	.+10     	; 0xc7a <UART_Init+0x98>
     c70:	89 30       	cpi	r24, 0x09	; 9
     c72:	19 f4       	brne	.+6      	; 0xc7a <UART_Init+0x98>
     c74:	80 b5       	in	r24, 0x20	; 32
     c76:	86 60       	ori	r24, 0x06	; 6
     c78:	80 bd       	out	0x20, r24	; 32
     c7a:	86 81       	ldd	r24, Z+6	; 0x06
     c7c:	8a 30       	cpi	r24, 0x0A	; 10
     c7e:	71 f4       	brne	.+28     	; 0xc9c <UART_Init+0xba>
     c80:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <sgu8_UART_Execution_Mode>
     c84:	8f b7       	in	r24, 0x3f	; 63
     c86:	80 68       	ori	r24, 0x80	; 128
     c88:	8f bf       	out	0x3f, r24	; 63
     c8a:	81 81       	ldd	r24, Z+1	; 0x01
     c8c:	8e 30       	cpi	r24, 0x0E	; 14
     c8e:	09 f4       	brne	.+2      	; 0xc92 <UART_Init+0xb0>
     c90:	57 9a       	sbi	0x0a, 7	; 10
     c92:	80 81       	ld	r24, Z
     c94:	8d 30       	cpi	r24, 0x0D	; 13
     c96:	39 f4       	brne	.+14     	; 0xca6 <UART_Init+0xc4>
     c98:	56 9a       	sbi	0x0a, 6	; 10
     c9a:	05 c0       	rjmp	.+10     	; 0xca6 <UART_Init+0xc4>
     c9c:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <sgu8_UART_Execution_Mode>
     ca0:	02 c0       	rjmp	.+4      	; 0xca6 <UART_Init+0xc4>
     ca2:	8c e0       	ldi	r24, 0x0C	; 12
     ca4:	08 95       	ret
     ca6:	08 95       	ret

00000ca8 <UART_RecByte>:
 * Input     : (uinteg8_t* pchar_index)It takes pointer to char
 * Output    : Error Checking
 *_______________________________________________________________________________________________________________________________*/

UART_Error_t UART_RecByte(uinteg8_t volatile * volatile pchar_index)
{
     ca8:	cf 93       	push	r28
     caa:	df 93       	push	r29
     cac:	00 d0       	rcall	.+0      	; 0xcae <UART_RecByte+0x6>
     cae:	cd b7       	in	r28, 0x3d	; 61
     cb0:	de b7       	in	r29, 0x3e	; 62
     cb2:	9a 83       	std	Y+2, r25	; 0x02
     cb4:	89 83       	std	Y+1, r24	; 0x01

    if(sgu8_UART_Receiver_enable==UART_Receive_Enable)
     cb6:	80 91 91 00 	lds	r24, 0x0091	; 0x800091 <sgu8_UART_Receiver_enable>
     cba:	8e 30       	cpi	r24, 0x0E	; 14
     cbc:	09 f5       	brne	.+66     	; 0xd00 <UART_RecByte+0x58>
	{

		if(sgu8_UART_Execution_Mode==UART_Polling_mode_enable)
     cbe:	80 91 92 00 	lds	r24, 0x0092	; 0x800092 <sgu8_UART_Execution_Mode>
     cc2:	8c 30       	cpi	r24, 0x0C	; 12
     cc4:	39 f4       	brne	.+14     	; 0xcd4 <UART_RecByte+0x2c>
		{
			while ( !( UART_CNTRL_STATUS_REG_A & (1<<UART_Receive_Complete_FLAG)) );
     cc6:	5f 9b       	sbis	0x0b, 7	; 11
     cc8:	fe cf       	rjmp	.-4      	; 0xcc6 <UART_RecByte+0x1e>
			*pchar_index=UART_DATA_REGISTER;
     cca:	e9 81       	ldd	r30, Y+1	; 0x01
     ccc:	fa 81       	ldd	r31, Y+2	; 0x02
     cce:	8c b1       	in	r24, 0x0c	; 12
     cd0:	80 83       	st	Z, r24
     cd2:	16 c0       	rjmp	.+44     	; 0xd00 <UART_RecByte+0x58>
		}
		else if(sgu8_UART_Execution_Mode==UART_Interrupt_mode_enable)
     cd4:	8a 30       	cpi	r24, 0x0A	; 10
     cd6:	29 f4       	brne	.+10     	; 0xce2 <UART_RecByte+0x3a>
		{
            *pchar_index=UART_DATA_REGISTER;
     cd8:	e9 81       	ldd	r30, Y+1	; 0x01
     cda:	fa 81       	ldd	r31, Y+2	; 0x02
     cdc:	8c b1       	in	r24, 0x0c	; 12
     cde:	80 83       	st	Z, r24
     ce0:	0f c0       	rjmp	.+30     	; 0xd00 <UART_RecByte+0x58>
		}
		else if(sgu8_UART_Execution_Mode==UART_FreeRTOS_mode_enable)
     ce2:	8b 30       	cpi	r24, 0x0B	; 11
     ce4:	69 f4       	brne	.+26     	; 0xd00 <UART_RecByte+0x58>
		{
			if( ( UART_CNTRL_STATUS_REG_A & (1<<UART_Receive_Complete_FLAG)) )
     ce6:	5f 9b       	sbis	0x0b, 7	; 11
     ce8:	05 c0       	rjmp	.+10     	; 0xcf4 <UART_RecByte+0x4c>
			{				
				*pchar_index=UART_DATA_REGISTER;
     cea:	e9 81       	ldd	r30, Y+1	; 0x01
     cec:	fa 81       	ldd	r31, Y+2	; 0x02
     cee:	8c b1       	in	r24, 0x0c	; 12
     cf0:	80 83       	st	Z, r24
     cf2:	06 c0       	rjmp	.+12     	; 0xd00 <UART_RecByte+0x58>
			}
			else
			{
                Debug_By_Toggle(18);
     cf4:	82 e1       	ldi	r24, 0x12	; 18
     cf6:	90 e0       	ldi	r25, 0x00	; 0
     cf8:	0e 94 85 06 	call	0xd0a	; 0xd0a <Debug_By_Toggle>
				return UART_RTOS_Not_New_Data;
     cfc:	89 e0       	ldi	r24, 0x09	; 9
     cfe:	00 c0       	rjmp	.+0      	; 0xd00 <UART_RecByte+0x58>
	}
	else
	{
	}

}
     d00:	0f 90       	pop	r0
     d02:	0f 90       	pop	r0
     d04:	df 91       	pop	r29
     d06:	cf 91       	pop	r28
     d08:	08 95       	ret

00000d0a <Debug_By_Toggle>:
#define Debug_By_Toggle_State_Other_times 1
#define Debug_By_Toggle_State_Nothing     2


void Debug_By_Toggle(uinteg8_t u8_Pin)
{
     d0a:	cf 93       	push	r28
     d0c:	c8 2f       	mov	r28, r24
	DIO_Init_Pin(u8_Pin,1);
     d0e:	61 e0       	ldi	r22, 0x01	; 1
     d10:	0e 94 5d 04 	call	0x8ba	; 0x8ba <DIO_Init_Pin>
	DIO_toggle_Pin(u8_Pin);
     d14:	8c 2f       	mov	r24, r28
     d16:	0e 94 47 05 	call	0xa8e	; 0xa8e <DIO_toggle_Pin>
     d1a:	cf 91       	pop	r28
     d1c:	08 95       	ret

00000d1e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     d1e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d20:	03 96       	adiw	r24, 0x03	; 3
     d22:	92 83       	std	Z+2, r25	; 0x02
     d24:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     d26:	2f ef       	ldi	r18, 0xFF	; 255
     d28:	3f ef       	ldi	r19, 0xFF	; 255
     d2a:	34 83       	std	Z+4, r19	; 0x04
     d2c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d2e:	96 83       	std	Z+6, r25	; 0x06
     d30:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d32:	90 87       	std	Z+8, r25	; 0x08
     d34:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     d36:	10 82       	st	Z, r1
     d38:	08 95       	ret

00000d3a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     d3a:	fc 01       	movw	r30, r24
     d3c:	11 86       	std	Z+9, r1	; 0x09
     d3e:	10 86       	std	Z+8, r1	; 0x08
     d40:	08 95       	ret

00000d42 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     d42:	cf 93       	push	r28
     d44:	df 93       	push	r29
     d46:	9c 01       	movw	r18, r24
     d48:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     d4a:	dc 01       	movw	r26, r24
     d4c:	11 96       	adiw	r26, 0x01	; 1
     d4e:	cd 91       	ld	r28, X+
     d50:	dc 91       	ld	r29, X
     d52:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     d54:	d3 83       	std	Z+3, r29	; 0x03
     d56:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     d58:	8c 81       	ldd	r24, Y+4	; 0x04
     d5a:	9d 81       	ldd	r25, Y+5	; 0x05
     d5c:	95 83       	std	Z+5, r25	; 0x05
     d5e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     d60:	8c 81       	ldd	r24, Y+4	; 0x04
     d62:	9d 81       	ldd	r25, Y+5	; 0x05
     d64:	dc 01       	movw	r26, r24
     d66:	13 96       	adiw	r26, 0x03	; 3
     d68:	7c 93       	st	X, r23
     d6a:	6e 93       	st	-X, r22
     d6c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     d6e:	7d 83       	std	Y+5, r23	; 0x05
     d70:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     d72:	31 87       	std	Z+9, r19	; 0x09
     d74:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     d76:	f9 01       	movw	r30, r18
     d78:	80 81       	ld	r24, Z
     d7a:	8f 5f       	subi	r24, 0xFF	; 255
     d7c:	80 83       	st	Z, r24
}
     d7e:	df 91       	pop	r29
     d80:	cf 91       	pop	r28
     d82:	08 95       	ret

00000d84 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     d84:	cf 93       	push	r28
     d86:	df 93       	push	r29
     d88:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     d8a:	48 81       	ld	r20, Y
     d8c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     d8e:	4f 3f       	cpi	r20, 0xFF	; 255
     d90:	2f ef       	ldi	r18, 0xFF	; 255
     d92:	52 07       	cpc	r21, r18
     d94:	21 f4       	brne	.+8      	; 0xd9e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     d96:	fc 01       	movw	r30, r24
     d98:	a7 81       	ldd	r26, Z+7	; 0x07
     d9a:	b0 85       	ldd	r27, Z+8	; 0x08
     d9c:	0d c0       	rjmp	.+26     	; 0xdb8 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     d9e:	dc 01       	movw	r26, r24
     da0:	13 96       	adiw	r26, 0x03	; 3
     da2:	01 c0       	rjmp	.+2      	; 0xda6 <vListInsert+0x22>
     da4:	df 01       	movw	r26, r30
     da6:	12 96       	adiw	r26, 0x02	; 2
     da8:	ed 91       	ld	r30, X+
     daa:	fc 91       	ld	r31, X
     dac:	13 97       	sbiw	r26, 0x03	; 3
     dae:	20 81       	ld	r18, Z
     db0:	31 81       	ldd	r19, Z+1	; 0x01
     db2:	42 17       	cp	r20, r18
     db4:	53 07       	cpc	r21, r19
     db6:	b0 f7       	brcc	.-20     	; 0xda4 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     db8:	12 96       	adiw	r26, 0x02	; 2
     dba:	ed 91       	ld	r30, X+
     dbc:	fc 91       	ld	r31, X
     dbe:	13 97       	sbiw	r26, 0x03	; 3
     dc0:	fb 83       	std	Y+3, r31	; 0x03
     dc2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     dc4:	d5 83       	std	Z+5, r29	; 0x05
     dc6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     dc8:	bd 83       	std	Y+5, r27	; 0x05
     dca:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     dcc:	13 96       	adiw	r26, 0x03	; 3
     dce:	dc 93       	st	X, r29
     dd0:	ce 93       	st	-X, r28
     dd2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     dd4:	99 87       	std	Y+9, r25	; 0x09
     dd6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     dd8:	fc 01       	movw	r30, r24
     dda:	20 81       	ld	r18, Z
     ddc:	2f 5f       	subi	r18, 0xFF	; 255
     dde:	20 83       	st	Z, r18
}
     de0:	df 91       	pop	r29
     de2:	cf 91       	pop	r28
     de4:	08 95       	ret

00000de6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     de6:	cf 93       	push	r28
     de8:	df 93       	push	r29
     dea:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     dec:	a0 85       	ldd	r26, Z+8	; 0x08
     dee:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     df0:	c2 81       	ldd	r28, Z+2	; 0x02
     df2:	d3 81       	ldd	r29, Z+3	; 0x03
     df4:	84 81       	ldd	r24, Z+4	; 0x04
     df6:	95 81       	ldd	r25, Z+5	; 0x05
     df8:	9d 83       	std	Y+5, r25	; 0x05
     dfa:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     dfc:	c4 81       	ldd	r28, Z+4	; 0x04
     dfe:	d5 81       	ldd	r29, Z+5	; 0x05
     e00:	82 81       	ldd	r24, Z+2	; 0x02
     e02:	93 81       	ldd	r25, Z+3	; 0x03
     e04:	9b 83       	std	Y+3, r25	; 0x03
     e06:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     e08:	11 96       	adiw	r26, 0x01	; 1
     e0a:	8d 91       	ld	r24, X+
     e0c:	9c 91       	ld	r25, X
     e0e:	12 97       	sbiw	r26, 0x02	; 2
     e10:	e8 17       	cp	r30, r24
     e12:	f9 07       	cpc	r31, r25
     e14:	31 f4       	brne	.+12     	; 0xe22 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     e16:	84 81       	ldd	r24, Z+4	; 0x04
     e18:	95 81       	ldd	r25, Z+5	; 0x05
     e1a:	12 96       	adiw	r26, 0x02	; 2
     e1c:	9c 93       	st	X, r25
     e1e:	8e 93       	st	-X, r24
     e20:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     e22:	11 86       	std	Z+9, r1	; 0x09
     e24:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     e26:	8c 91       	ld	r24, X
     e28:	81 50       	subi	r24, 0x01	; 1
     e2a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     e2c:	8c 91       	ld	r24, X
}
     e2e:	df 91       	pop	r29
     e30:	cf 91       	pop	r28
     e32:	08 95       	ret

00000e34 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     e34:	31 e1       	ldi	r19, 0x11	; 17
     e36:	fc 01       	movw	r30, r24
     e38:	30 83       	st	Z, r19
     e3a:	31 97       	sbiw	r30, 0x01	; 1
     e3c:	22 e2       	ldi	r18, 0x22	; 34
     e3e:	20 83       	st	Z, r18
     e40:	31 97       	sbiw	r30, 0x01	; 1
     e42:	a3 e3       	ldi	r26, 0x33	; 51
     e44:	a0 83       	st	Z, r26
     e46:	31 97       	sbiw	r30, 0x01	; 1
     e48:	60 83       	st	Z, r22
     e4a:	31 97       	sbiw	r30, 0x01	; 1
     e4c:	70 83       	st	Z, r23
     e4e:	31 97       	sbiw	r30, 0x01	; 1
     e50:	10 82       	st	Z, r1
     e52:	31 97       	sbiw	r30, 0x01	; 1
     e54:	60 e8       	ldi	r22, 0x80	; 128
     e56:	60 83       	st	Z, r22
     e58:	31 97       	sbiw	r30, 0x01	; 1
     e5a:	10 82       	st	Z, r1
     e5c:	31 97       	sbiw	r30, 0x01	; 1
     e5e:	62 e0       	ldi	r22, 0x02	; 2
     e60:	60 83       	st	Z, r22
     e62:	31 97       	sbiw	r30, 0x01	; 1
     e64:	63 e0       	ldi	r22, 0x03	; 3
     e66:	60 83       	st	Z, r22
     e68:	31 97       	sbiw	r30, 0x01	; 1
     e6a:	64 e0       	ldi	r22, 0x04	; 4
     e6c:	60 83       	st	Z, r22
     e6e:	31 97       	sbiw	r30, 0x01	; 1
     e70:	65 e0       	ldi	r22, 0x05	; 5
     e72:	60 83       	st	Z, r22
     e74:	31 97       	sbiw	r30, 0x01	; 1
     e76:	66 e0       	ldi	r22, 0x06	; 6
     e78:	60 83       	st	Z, r22
     e7a:	31 97       	sbiw	r30, 0x01	; 1
     e7c:	67 e0       	ldi	r22, 0x07	; 7
     e7e:	60 83       	st	Z, r22
     e80:	31 97       	sbiw	r30, 0x01	; 1
     e82:	68 e0       	ldi	r22, 0x08	; 8
     e84:	60 83       	st	Z, r22
     e86:	31 97       	sbiw	r30, 0x01	; 1
     e88:	69 e0       	ldi	r22, 0x09	; 9
     e8a:	60 83       	st	Z, r22
     e8c:	31 97       	sbiw	r30, 0x01	; 1
     e8e:	60 e1       	ldi	r22, 0x10	; 16
     e90:	60 83       	st	Z, r22
     e92:	31 97       	sbiw	r30, 0x01	; 1
     e94:	30 83       	st	Z, r19
     e96:	31 97       	sbiw	r30, 0x01	; 1
     e98:	32 e1       	ldi	r19, 0x12	; 18
     e9a:	30 83       	st	Z, r19
     e9c:	31 97       	sbiw	r30, 0x01	; 1
     e9e:	33 e1       	ldi	r19, 0x13	; 19
     ea0:	30 83       	st	Z, r19
     ea2:	31 97       	sbiw	r30, 0x01	; 1
     ea4:	34 e1       	ldi	r19, 0x14	; 20
     ea6:	30 83       	st	Z, r19
     ea8:	31 97       	sbiw	r30, 0x01	; 1
     eaa:	35 e1       	ldi	r19, 0x15	; 21
     eac:	30 83       	st	Z, r19
     eae:	31 97       	sbiw	r30, 0x01	; 1
     eb0:	36 e1       	ldi	r19, 0x16	; 22
     eb2:	30 83       	st	Z, r19
     eb4:	31 97       	sbiw	r30, 0x01	; 1
     eb6:	37 e1       	ldi	r19, 0x17	; 23
     eb8:	30 83       	st	Z, r19
     eba:	31 97       	sbiw	r30, 0x01	; 1
     ebc:	38 e1       	ldi	r19, 0x18	; 24
     ebe:	30 83       	st	Z, r19
     ec0:	31 97       	sbiw	r30, 0x01	; 1
     ec2:	39 e1       	ldi	r19, 0x19	; 25
     ec4:	30 83       	st	Z, r19
     ec6:	31 97       	sbiw	r30, 0x01	; 1
     ec8:	30 e2       	ldi	r19, 0x20	; 32
     eca:	30 83       	st	Z, r19
     ecc:	31 97       	sbiw	r30, 0x01	; 1
     ece:	31 e2       	ldi	r19, 0x21	; 33
     ed0:	30 83       	st	Z, r19
     ed2:	31 97       	sbiw	r30, 0x01	; 1
     ed4:	20 83       	st	Z, r18
     ed6:	31 97       	sbiw	r30, 0x01	; 1
     ed8:	23 e2       	ldi	r18, 0x23	; 35
     eda:	20 83       	st	Z, r18
     edc:	31 97       	sbiw	r30, 0x01	; 1
     ede:	40 83       	st	Z, r20
     ee0:	31 97       	sbiw	r30, 0x01	; 1
     ee2:	50 83       	st	Z, r21
     ee4:	31 97       	sbiw	r30, 0x01	; 1
     ee6:	26 e2       	ldi	r18, 0x26	; 38
     ee8:	20 83       	st	Z, r18
     eea:	31 97       	sbiw	r30, 0x01	; 1
     eec:	27 e2       	ldi	r18, 0x27	; 39
     eee:	20 83       	st	Z, r18
     ef0:	31 97       	sbiw	r30, 0x01	; 1
     ef2:	28 e2       	ldi	r18, 0x28	; 40
     ef4:	20 83       	st	Z, r18
     ef6:	31 97       	sbiw	r30, 0x01	; 1
     ef8:	29 e2       	ldi	r18, 0x29	; 41
     efa:	20 83       	st	Z, r18
     efc:	31 97       	sbiw	r30, 0x01	; 1
     efe:	20 e3       	ldi	r18, 0x30	; 48
     f00:	20 83       	st	Z, r18
     f02:	31 97       	sbiw	r30, 0x01	; 1
     f04:	21 e3       	ldi	r18, 0x31	; 49
     f06:	20 83       	st	Z, r18
     f08:	86 97       	sbiw	r24, 0x26	; 38
     f0a:	08 95       	ret

00000f0c <xPortStartScheduler>:
     f0c:	1b bc       	out	0x2b, r1	; 43
     f0e:	8c e7       	ldi	r24, 0x7C	; 124
     f10:	8a bd       	out	0x2a, r24	; 42
     f12:	8b e0       	ldi	r24, 0x0B	; 11
     f14:	8e bd       	out	0x2e, r24	; 46
     f16:	89 b7       	in	r24, 0x39	; 57
     f18:	80 61       	ori	r24, 0x10	; 16
     f1a:	89 bf       	out	0x39, r24	; 57
     f1c:	a0 91 e4 06 	lds	r26, 0x06E4	; 0x8006e4 <pxCurrentTCB>
     f20:	b0 91 e5 06 	lds	r27, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
     f24:	cd 91       	ld	r28, X+
     f26:	cd bf       	out	0x3d, r28	; 61
     f28:	dd 91       	ld	r29, X+
     f2a:	de bf       	out	0x3e, r29	; 62
     f2c:	ff 91       	pop	r31
     f2e:	ef 91       	pop	r30
     f30:	df 91       	pop	r29
     f32:	cf 91       	pop	r28
     f34:	bf 91       	pop	r27
     f36:	af 91       	pop	r26
     f38:	9f 91       	pop	r25
     f3a:	8f 91       	pop	r24
     f3c:	7f 91       	pop	r23
     f3e:	6f 91       	pop	r22
     f40:	5f 91       	pop	r21
     f42:	4f 91       	pop	r20
     f44:	3f 91       	pop	r19
     f46:	2f 91       	pop	r18
     f48:	1f 91       	pop	r17
     f4a:	0f 91       	pop	r16
     f4c:	ff 90       	pop	r15
     f4e:	ef 90       	pop	r14
     f50:	df 90       	pop	r13
     f52:	cf 90       	pop	r12
     f54:	bf 90       	pop	r11
     f56:	af 90       	pop	r10
     f58:	9f 90       	pop	r9
     f5a:	8f 90       	pop	r8
     f5c:	7f 90       	pop	r7
     f5e:	6f 90       	pop	r6
     f60:	5f 90       	pop	r5
     f62:	4f 90       	pop	r4
     f64:	3f 90       	pop	r3
     f66:	2f 90       	pop	r2
     f68:	1f 90       	pop	r1
     f6a:	0f 90       	pop	r0
     f6c:	0f be       	out	0x3f, r0	; 63
     f6e:	0f 90       	pop	r0
     f70:	08 95       	ret
     f72:	81 e0       	ldi	r24, 0x01	; 1
     f74:	08 95       	ret

00000f76 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     f76:	0f 92       	push	r0
     f78:	0f b6       	in	r0, 0x3f	; 63
     f7a:	f8 94       	cli
     f7c:	0f 92       	push	r0
     f7e:	1f 92       	push	r1
     f80:	11 24       	eor	r1, r1
     f82:	2f 92       	push	r2
     f84:	3f 92       	push	r3
     f86:	4f 92       	push	r4
     f88:	5f 92       	push	r5
     f8a:	6f 92       	push	r6
     f8c:	7f 92       	push	r7
     f8e:	8f 92       	push	r8
     f90:	9f 92       	push	r9
     f92:	af 92       	push	r10
     f94:	bf 92       	push	r11
     f96:	cf 92       	push	r12
     f98:	df 92       	push	r13
     f9a:	ef 92       	push	r14
     f9c:	ff 92       	push	r15
     f9e:	0f 93       	push	r16
     fa0:	1f 93       	push	r17
     fa2:	2f 93       	push	r18
     fa4:	3f 93       	push	r19
     fa6:	4f 93       	push	r20
     fa8:	5f 93       	push	r21
     faa:	6f 93       	push	r22
     fac:	7f 93       	push	r23
     fae:	8f 93       	push	r24
     fb0:	9f 93       	push	r25
     fb2:	af 93       	push	r26
     fb4:	bf 93       	push	r27
     fb6:	cf 93       	push	r28
     fb8:	df 93       	push	r29
     fba:	ef 93       	push	r30
     fbc:	ff 93       	push	r31
     fbe:	a0 91 e4 06 	lds	r26, 0x06E4	; 0x8006e4 <pxCurrentTCB>
     fc2:	b0 91 e5 06 	lds	r27, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
     fc6:	0d b6       	in	r0, 0x3d	; 61
     fc8:	0d 92       	st	X+, r0
     fca:	0e b6       	in	r0, 0x3e	; 62
     fcc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     fce:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     fd2:	a0 91 e4 06 	lds	r26, 0x06E4	; 0x8006e4 <pxCurrentTCB>
     fd6:	b0 91 e5 06 	lds	r27, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
     fda:	cd 91       	ld	r28, X+
     fdc:	cd bf       	out	0x3d, r28	; 61
     fde:	dd 91       	ld	r29, X+
     fe0:	de bf       	out	0x3e, r29	; 62
     fe2:	ff 91       	pop	r31
     fe4:	ef 91       	pop	r30
     fe6:	df 91       	pop	r29
     fe8:	cf 91       	pop	r28
     fea:	bf 91       	pop	r27
     fec:	af 91       	pop	r26
     fee:	9f 91       	pop	r25
     ff0:	8f 91       	pop	r24
     ff2:	7f 91       	pop	r23
     ff4:	6f 91       	pop	r22
     ff6:	5f 91       	pop	r21
     ff8:	4f 91       	pop	r20
     ffa:	3f 91       	pop	r19
     ffc:	2f 91       	pop	r18
     ffe:	1f 91       	pop	r17
    1000:	0f 91       	pop	r16
    1002:	ff 90       	pop	r15
    1004:	ef 90       	pop	r14
    1006:	df 90       	pop	r13
    1008:	cf 90       	pop	r12
    100a:	bf 90       	pop	r11
    100c:	af 90       	pop	r10
    100e:	9f 90       	pop	r9
    1010:	8f 90       	pop	r8
    1012:	7f 90       	pop	r7
    1014:	6f 90       	pop	r6
    1016:	5f 90       	pop	r5
    1018:	4f 90       	pop	r4
    101a:	3f 90       	pop	r3
    101c:	2f 90       	pop	r2
    101e:	1f 90       	pop	r1
    1020:	0f 90       	pop	r0
    1022:	0f be       	out	0x3f, r0	; 63
    1024:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1026:	08 95       	ret

00001028 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1028:	0f 92       	push	r0
    102a:	0f b6       	in	r0, 0x3f	; 63
    102c:	f8 94       	cli
    102e:	0f 92       	push	r0
    1030:	1f 92       	push	r1
    1032:	11 24       	eor	r1, r1
    1034:	2f 92       	push	r2
    1036:	3f 92       	push	r3
    1038:	4f 92       	push	r4
    103a:	5f 92       	push	r5
    103c:	6f 92       	push	r6
    103e:	7f 92       	push	r7
    1040:	8f 92       	push	r8
    1042:	9f 92       	push	r9
    1044:	af 92       	push	r10
    1046:	bf 92       	push	r11
    1048:	cf 92       	push	r12
    104a:	df 92       	push	r13
    104c:	ef 92       	push	r14
    104e:	ff 92       	push	r15
    1050:	0f 93       	push	r16
    1052:	1f 93       	push	r17
    1054:	2f 93       	push	r18
    1056:	3f 93       	push	r19
    1058:	4f 93       	push	r20
    105a:	5f 93       	push	r21
    105c:	6f 93       	push	r22
    105e:	7f 93       	push	r23
    1060:	8f 93       	push	r24
    1062:	9f 93       	push	r25
    1064:	af 93       	push	r26
    1066:	bf 93       	push	r27
    1068:	cf 93       	push	r28
    106a:	df 93       	push	r29
    106c:	ef 93       	push	r30
    106e:	ff 93       	push	r31
    1070:	a0 91 e4 06 	lds	r26, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    1074:	b0 91 e5 06 	lds	r27, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    1078:	0d b6       	in	r0, 0x3d	; 61
    107a:	0d 92       	st	X+, r0
    107c:	0e b6       	in	r0, 0x3e	; 62
    107e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1080:	0e 94 3f 0d 	call	0x1a7e	; 0x1a7e <xTaskIncrementTick>
    1084:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1086:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    108a:	a0 91 e4 06 	lds	r26, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    108e:	b0 91 e5 06 	lds	r27, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    1092:	cd 91       	ld	r28, X+
    1094:	cd bf       	out	0x3d, r28	; 61
    1096:	dd 91       	ld	r29, X+
    1098:	de bf       	out	0x3e, r29	; 62
    109a:	ff 91       	pop	r31
    109c:	ef 91       	pop	r30
    109e:	df 91       	pop	r29
    10a0:	cf 91       	pop	r28
    10a2:	bf 91       	pop	r27
    10a4:	af 91       	pop	r26
    10a6:	9f 91       	pop	r25
    10a8:	8f 91       	pop	r24
    10aa:	7f 91       	pop	r23
    10ac:	6f 91       	pop	r22
    10ae:	5f 91       	pop	r21
    10b0:	4f 91       	pop	r20
    10b2:	3f 91       	pop	r19
    10b4:	2f 91       	pop	r18
    10b6:	1f 91       	pop	r17
    10b8:	0f 91       	pop	r16
    10ba:	ff 90       	pop	r15
    10bc:	ef 90       	pop	r14
    10be:	df 90       	pop	r13
    10c0:	cf 90       	pop	r12
    10c2:	bf 90       	pop	r11
    10c4:	af 90       	pop	r10
    10c6:	9f 90       	pop	r9
    10c8:	8f 90       	pop	r8
    10ca:	7f 90       	pop	r7
    10cc:	6f 90       	pop	r6
    10ce:	5f 90       	pop	r5
    10d0:	4f 90       	pop	r4
    10d2:	3f 90       	pop	r3
    10d4:	2f 90       	pop	r2
    10d6:	1f 90       	pop	r1
    10d8:	0f 90       	pop	r0
    10da:	0f be       	out	0x3f, r0	; 63
    10dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    10de:	08 95       	ret

000010e0 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    10e0:	0e 94 14 08 	call	0x1028	; 0x1028 <vPortYieldFromTick>
		asm volatile ( "reti" );
    10e4:	18 95       	reti

000010e6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    10e6:	cf 93       	push	r28
    10e8:	df 93       	push	r29
    10ea:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    10ec:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    10f0:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <pucAlignedHeap.2084>
    10f4:	90 91 98 00 	lds	r25, 0x0098	; 0x800098 <pucAlignedHeap.2084+0x1>
    10f8:	89 2b       	or	r24, r25
    10fa:	31 f4       	brne	.+12     	; 0x1108 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    10fc:	8c e9       	ldi	r24, 0x9C	; 156
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	90 93 98 00 	sts	0x0098, r25	; 0x800098 <pucAlignedHeap.2084+0x1>
    1104:	80 93 97 00 	sts	0x0097, r24	; 0x800097 <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1108:	20 91 99 00 	lds	r18, 0x0099	; 0x800099 <xNextFreeByte>
    110c:	30 91 9a 00 	lds	r19, 0x009A	; 0x80009a <xNextFreeByte+0x1>
    1110:	c9 01       	movw	r24, r18
    1112:	8c 0f       	add	r24, r28
    1114:	9d 1f       	adc	r25, r29
    1116:	8b 3d       	cpi	r24, 0xDB	; 219
    1118:	45 e0       	ldi	r20, 0x05	; 5
    111a:	94 07       	cpc	r25, r20
    111c:	70 f4       	brcc	.+28     	; 0x113a <pvPortMalloc+0x54>
    111e:	28 17       	cp	r18, r24
    1120:	39 07       	cpc	r19, r25
    1122:	70 f4       	brcc	.+28     	; 0x1140 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1124:	c0 91 97 00 	lds	r28, 0x0097	; 0x800097 <pucAlignedHeap.2084>
    1128:	d0 91 98 00 	lds	r29, 0x0098	; 0x800098 <pucAlignedHeap.2084+0x1>
    112c:	c2 0f       	add	r28, r18
    112e:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    1130:	90 93 9a 00 	sts	0x009A, r25	; 0x80009a <xNextFreeByte+0x1>
    1134:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <xNextFreeByte>
    1138:	05 c0       	rjmp	.+10     	; 0x1144 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    113a:	c0 e0       	ldi	r28, 0x00	; 0
    113c:	d0 e0       	ldi	r29, 0x00	; 0
    113e:	02 c0       	rjmp	.+4      	; 0x1144 <pvPortMalloc+0x5e>
    1140:	c0 e0       	ldi	r28, 0x00	; 0
    1142:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1144:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1148:	ce 01       	movw	r24, r28
    114a:	df 91       	pop	r29
    114c:	cf 91       	pop	r28
    114e:	08 95       	ret

00001150 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1150:	08 95       	ret

00001152 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1152:	0f b6       	in	r0, 0x3f	; 63
    1154:	f8 94       	cli
    1156:	0f 92       	push	r0
    1158:	fc 01       	movw	r30, r24
    115a:	92 8d       	ldd	r25, Z+26	; 0x1a
    115c:	0f 90       	pop	r0
    115e:	0f be       	out	0x3f, r0	; 63
    1160:	81 e0       	ldi	r24, 0x01	; 1
    1162:	91 11       	cpse	r25, r1
    1164:	80 e0       	ldi	r24, 0x00	; 0
    1166:	08 95       	ret

00001168 <prvCopyDataToQueue>:
    1168:	0f 93       	push	r16
    116a:	1f 93       	push	r17
    116c:	cf 93       	push	r28
    116e:	df 93       	push	r29
    1170:	ec 01       	movw	r28, r24
    1172:	04 2f       	mov	r16, r20
    1174:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1176:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1178:	44 23       	and	r20, r20
    117a:	b9 f1       	breq	.+110    	; 0x11ea <prvCopyDataToQueue+0x82>
    117c:	01 11       	cpse	r16, r1
    117e:	16 c0       	rjmp	.+44     	; 0x11ac <prvCopyDataToQueue+0x44>
    1180:	50 e0       	ldi	r21, 0x00	; 0
    1182:	8a 81       	ldd	r24, Y+2	; 0x02
    1184:	9b 81       	ldd	r25, Y+3	; 0x03
    1186:	0e 94 51 11 	call	0x22a2	; 0x22a2 <memcpy>
    118a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    118c:	8a 81       	ldd	r24, Y+2	; 0x02
    118e:	9b 81       	ldd	r25, Y+3	; 0x03
    1190:	82 0f       	add	r24, r18
    1192:	91 1d       	adc	r25, r1
    1194:	9b 83       	std	Y+3, r25	; 0x03
    1196:	8a 83       	std	Y+2, r24	; 0x02
    1198:	2c 81       	ldd	r18, Y+4	; 0x04
    119a:	3d 81       	ldd	r19, Y+5	; 0x05
    119c:	82 17       	cp	r24, r18
    119e:	93 07       	cpc	r25, r19
    11a0:	20 f1       	brcs	.+72     	; 0x11ea <prvCopyDataToQueue+0x82>
    11a2:	88 81       	ld	r24, Y
    11a4:	99 81       	ldd	r25, Y+1	; 0x01
    11a6:	9b 83       	std	Y+3, r25	; 0x03
    11a8:	8a 83       	std	Y+2, r24	; 0x02
    11aa:	1f c0       	rjmp	.+62     	; 0x11ea <prvCopyDataToQueue+0x82>
    11ac:	50 e0       	ldi	r21, 0x00	; 0
    11ae:	8e 81       	ldd	r24, Y+6	; 0x06
    11b0:	9f 81       	ldd	r25, Y+7	; 0x07
    11b2:	0e 94 51 11 	call	0x22a2	; 0x22a2 <memcpy>
    11b6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	91 95       	neg	r25
    11bc:	81 95       	neg	r24
    11be:	91 09       	sbc	r25, r1
    11c0:	2e 81       	ldd	r18, Y+6	; 0x06
    11c2:	3f 81       	ldd	r19, Y+7	; 0x07
    11c4:	28 0f       	add	r18, r24
    11c6:	39 1f       	adc	r19, r25
    11c8:	3f 83       	std	Y+7, r19	; 0x07
    11ca:	2e 83       	std	Y+6, r18	; 0x06
    11cc:	48 81       	ld	r20, Y
    11ce:	59 81       	ldd	r21, Y+1	; 0x01
    11d0:	24 17       	cp	r18, r20
    11d2:	35 07       	cpc	r19, r21
    11d4:	30 f4       	brcc	.+12     	; 0x11e2 <prvCopyDataToQueue+0x7a>
    11d6:	2c 81       	ldd	r18, Y+4	; 0x04
    11d8:	3d 81       	ldd	r19, Y+5	; 0x05
    11da:	82 0f       	add	r24, r18
    11dc:	93 1f       	adc	r25, r19
    11de:	9f 83       	std	Y+7, r25	; 0x07
    11e0:	8e 83       	std	Y+6, r24	; 0x06
    11e2:	02 30       	cpi	r16, 0x02	; 2
    11e4:	11 f4       	brne	.+4      	; 0x11ea <prvCopyDataToQueue+0x82>
    11e6:	11 11       	cpse	r17, r1
    11e8:	11 50       	subi	r17, 0x01	; 1
    11ea:	1f 5f       	subi	r17, 0xFF	; 255
    11ec:	1a 8f       	std	Y+26, r17	; 0x1a
    11ee:	80 e0       	ldi	r24, 0x00	; 0
    11f0:	df 91       	pop	r29
    11f2:	cf 91       	pop	r28
    11f4:	1f 91       	pop	r17
    11f6:	0f 91       	pop	r16
    11f8:	08 95       	ret

000011fa <prvUnlockQueue>:
    11fa:	ef 92       	push	r14
    11fc:	ff 92       	push	r15
    11fe:	0f 93       	push	r16
    1200:	1f 93       	push	r17
    1202:	cf 93       	push	r28
    1204:	8c 01       	movw	r16, r24
    1206:	0f b6       	in	r0, 0x3f	; 63
    1208:	f8 94       	cli
    120a:	0f 92       	push	r0
    120c:	fc 01       	movw	r30, r24
    120e:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1210:	1c 16       	cp	r1, r28
    1212:	ac f4       	brge	.+42     	; 0x123e <prvUnlockQueue+0x44>
    1214:	81 89       	ldd	r24, Z+17	; 0x11
    1216:	81 11       	cpse	r24, r1
    1218:	06 c0       	rjmp	.+12     	; 0x1226 <prvUnlockQueue+0x2c>
    121a:	11 c0       	rjmp	.+34     	; 0x123e <prvUnlockQueue+0x44>
    121c:	f8 01       	movw	r30, r16
    121e:	81 89       	ldd	r24, Z+17	; 0x11
    1220:	81 11       	cpse	r24, r1
    1222:	05 c0       	rjmp	.+10     	; 0x122e <prvUnlockQueue+0x34>
    1224:	0c c0       	rjmp	.+24     	; 0x123e <prvUnlockQueue+0x44>
    1226:	78 01       	movw	r14, r16
    1228:	f1 e1       	ldi	r31, 0x11	; 17
    122a:	ef 0e       	add	r14, r31
    122c:	f1 1c       	adc	r15, r1
    122e:	c7 01       	movw	r24, r14
    1230:	0e 94 95 0f 	call	0x1f2a	; 0x1f2a <xTaskRemoveFromEventList>
    1234:	81 11       	cpse	r24, r1
    1236:	0e 94 1e 10 	call	0x203c	; 0x203c <vTaskMissedYield>
    123a:	c1 50       	subi	r28, 0x01	; 1
    123c:	79 f7       	brne	.-34     	; 0x121c <prvUnlockQueue+0x22>
    123e:	8f ef       	ldi	r24, 0xFF	; 255
    1240:	f8 01       	movw	r30, r16
    1242:	86 8f       	std	Z+30, r24	; 0x1e
    1244:	0f 90       	pop	r0
    1246:	0f be       	out	0x3f, r0	; 63
    1248:	0f b6       	in	r0, 0x3f	; 63
    124a:	f8 94       	cli
    124c:	0f 92       	push	r0
    124e:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1250:	1c 16       	cp	r1, r28
    1252:	ac f4       	brge	.+42     	; 0x127e <prvUnlockQueue+0x84>
    1254:	80 85       	ldd	r24, Z+8	; 0x08
    1256:	81 11       	cpse	r24, r1
    1258:	06 c0       	rjmp	.+12     	; 0x1266 <prvUnlockQueue+0x6c>
    125a:	11 c0       	rjmp	.+34     	; 0x127e <prvUnlockQueue+0x84>
    125c:	f8 01       	movw	r30, r16
    125e:	80 85       	ldd	r24, Z+8	; 0x08
    1260:	81 11       	cpse	r24, r1
    1262:	05 c0       	rjmp	.+10     	; 0x126e <prvUnlockQueue+0x74>
    1264:	0c c0       	rjmp	.+24     	; 0x127e <prvUnlockQueue+0x84>
    1266:	78 01       	movw	r14, r16
    1268:	f8 e0       	ldi	r31, 0x08	; 8
    126a:	ef 0e       	add	r14, r31
    126c:	f1 1c       	adc	r15, r1
    126e:	c7 01       	movw	r24, r14
    1270:	0e 94 95 0f 	call	0x1f2a	; 0x1f2a <xTaskRemoveFromEventList>
    1274:	81 11       	cpse	r24, r1
    1276:	0e 94 1e 10 	call	0x203c	; 0x203c <vTaskMissedYield>
    127a:	c1 50       	subi	r28, 0x01	; 1
    127c:	79 f7       	brne	.-34     	; 0x125c <prvUnlockQueue+0x62>
    127e:	8f ef       	ldi	r24, 0xFF	; 255
    1280:	f8 01       	movw	r30, r16
    1282:	85 8f       	std	Z+29, r24	; 0x1d
    1284:	0f 90       	pop	r0
    1286:	0f be       	out	0x3f, r0	; 63
    1288:	cf 91       	pop	r28
    128a:	1f 91       	pop	r17
    128c:	0f 91       	pop	r16
    128e:	ff 90       	pop	r15
    1290:	ef 90       	pop	r14
    1292:	08 95       	ret

00001294 <xQueueGenericReset>:
    1294:	cf 93       	push	r28
    1296:	df 93       	push	r29
    1298:	ec 01       	movw	r28, r24
    129a:	0f b6       	in	r0, 0x3f	; 63
    129c:	f8 94       	cli
    129e:	0f 92       	push	r0
    12a0:	e8 81       	ld	r30, Y
    12a2:	f9 81       	ldd	r31, Y+1	; 0x01
    12a4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    12a6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12a8:	90 e0       	ldi	r25, 0x00	; 0
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	82 9f       	mul	r24, r18
    12ae:	a0 01       	movw	r20, r0
    12b0:	83 9f       	mul	r24, r19
    12b2:	50 0d       	add	r21, r0
    12b4:	92 9f       	mul	r25, r18
    12b6:	50 0d       	add	r21, r0
    12b8:	11 24       	eor	r1, r1
    12ba:	4e 0f       	add	r20, r30
    12bc:	5f 1f       	adc	r21, r31
    12be:	5d 83       	std	Y+5, r21	; 0x05
    12c0:	4c 83       	std	Y+4, r20	; 0x04
    12c2:	1a 8e       	std	Y+26, r1	; 0x1a
    12c4:	fb 83       	std	Y+3, r31	; 0x03
    12c6:	ea 83       	std	Y+2, r30	; 0x02
    12c8:	01 97       	sbiw	r24, 0x01	; 1
    12ca:	82 9f       	mul	r24, r18
    12cc:	a0 01       	movw	r20, r0
    12ce:	83 9f       	mul	r24, r19
    12d0:	50 0d       	add	r21, r0
    12d2:	92 9f       	mul	r25, r18
    12d4:	50 0d       	add	r21, r0
    12d6:	11 24       	eor	r1, r1
    12d8:	cf 01       	movw	r24, r30
    12da:	84 0f       	add	r24, r20
    12dc:	95 1f       	adc	r25, r21
    12de:	9f 83       	std	Y+7, r25	; 0x07
    12e0:	8e 83       	std	Y+6, r24	; 0x06
    12e2:	8f ef       	ldi	r24, 0xFF	; 255
    12e4:	8d 8f       	std	Y+29, r24	; 0x1d
    12e6:	8e 8f       	std	Y+30, r24	; 0x1e
    12e8:	61 11       	cpse	r22, r1
    12ea:	0c c0       	rjmp	.+24     	; 0x1304 <xQueueGenericReset+0x70>
    12ec:	88 85       	ldd	r24, Y+8	; 0x08
    12ee:	88 23       	and	r24, r24
    12f0:	89 f0       	breq	.+34     	; 0x1314 <xQueueGenericReset+0x80>
    12f2:	ce 01       	movw	r24, r28
    12f4:	08 96       	adiw	r24, 0x08	; 8
    12f6:	0e 94 95 0f 	call	0x1f2a	; 0x1f2a <xTaskRemoveFromEventList>
    12fa:	88 23       	and	r24, r24
    12fc:	59 f0       	breq	.+22     	; 0x1314 <xQueueGenericReset+0x80>
    12fe:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    1302:	08 c0       	rjmp	.+16     	; 0x1314 <xQueueGenericReset+0x80>
    1304:	ce 01       	movw	r24, r28
    1306:	08 96       	adiw	r24, 0x08	; 8
    1308:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInitialise>
    130c:	ce 01       	movw	r24, r28
    130e:	41 96       	adiw	r24, 0x11	; 17
    1310:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInitialise>
    1314:	0f 90       	pop	r0
    1316:	0f be       	out	0x3f, r0	; 63
    1318:	81 e0       	ldi	r24, 0x01	; 1
    131a:	df 91       	pop	r29
    131c:	cf 91       	pop	r28
    131e:	08 95       	ret

00001320 <xQueueGenericCreate>:
    1320:	0f 93       	push	r16
    1322:	1f 93       	push	r17
    1324:	cf 93       	push	r28
    1326:	df 93       	push	r29
    1328:	08 2f       	mov	r16, r24
    132a:	16 2f       	mov	r17, r22
    132c:	66 23       	and	r22, r22
    132e:	c1 f0       	breq	.+48     	; 0x1360 <xQueueGenericCreate+0x40>
    1330:	86 9f       	mul	r24, r22
    1332:	c0 01       	movw	r24, r0
    1334:	11 24       	eor	r1, r1
    1336:	4f 96       	adiw	r24, 0x1f	; 31
    1338:	0e 94 73 08 	call	0x10e6	; 0x10e6 <pvPortMalloc>
    133c:	ec 01       	movw	r28, r24
    133e:	00 97       	sbiw	r24, 0x00	; 0
    1340:	41 f4       	brne	.+16     	; 0x1352 <xQueueGenericCreate+0x32>
    1342:	15 c0       	rjmp	.+42     	; 0x136e <xQueueGenericCreate+0x4e>
    1344:	0b 8f       	std	Y+27, r16	; 0x1b
    1346:	1c 8f       	std	Y+28, r17	; 0x1c
    1348:	61 e0       	ldi	r22, 0x01	; 1
    134a:	ce 01       	movw	r24, r28
    134c:	0e 94 4a 09 	call	0x1294	; 0x1294 <xQueueGenericReset>
    1350:	0e c0       	rjmp	.+28     	; 0x136e <xQueueGenericCreate+0x4e>
    1352:	4f 96       	adiw	r24, 0x1f	; 31
    1354:	99 83       	std	Y+1, r25	; 0x01
    1356:	88 83       	st	Y, r24
    1358:	f5 cf       	rjmp	.-22     	; 0x1344 <xQueueGenericCreate+0x24>
    135a:	d9 83       	std	Y+1, r29	; 0x01
    135c:	c8 83       	st	Y, r28
    135e:	f2 cf       	rjmp	.-28     	; 0x1344 <xQueueGenericCreate+0x24>
    1360:	8f e1       	ldi	r24, 0x1F	; 31
    1362:	90 e0       	ldi	r25, 0x00	; 0
    1364:	0e 94 73 08 	call	0x10e6	; 0x10e6 <pvPortMalloc>
    1368:	ec 01       	movw	r28, r24
    136a:	89 2b       	or	r24, r25
    136c:	b1 f7       	brne	.-20     	; 0x135a <xQueueGenericCreate+0x3a>
    136e:	ce 01       	movw	r24, r28
    1370:	df 91       	pop	r29
    1372:	cf 91       	pop	r28
    1374:	1f 91       	pop	r17
    1376:	0f 91       	pop	r16
    1378:	08 95       	ret

0000137a <xQueueCreateCountingSemaphore>:
    137a:	cf 93       	push	r28
    137c:	c6 2f       	mov	r28, r22
    137e:	42 e0       	ldi	r20, 0x02	; 2
    1380:	60 e0       	ldi	r22, 0x00	; 0
    1382:	0e 94 90 09 	call	0x1320	; 0x1320 <xQueueGenericCreate>
    1386:	00 97       	sbiw	r24, 0x00	; 0
    1388:	11 f0       	breq	.+4      	; 0x138e <xQueueCreateCountingSemaphore+0x14>
    138a:	fc 01       	movw	r30, r24
    138c:	c2 8f       	std	Z+26, r28	; 0x1a
    138e:	cf 91       	pop	r28
    1390:	08 95       	ret

00001392 <xQueueGenericSend>:
    1392:	9f 92       	push	r9
    1394:	af 92       	push	r10
    1396:	bf 92       	push	r11
    1398:	cf 92       	push	r12
    139a:	df 92       	push	r13
    139c:	ef 92       	push	r14
    139e:	ff 92       	push	r15
    13a0:	0f 93       	push	r16
    13a2:	1f 93       	push	r17
    13a4:	cf 93       	push	r28
    13a6:	df 93       	push	r29
    13a8:	00 d0       	rcall	.+0      	; 0x13aa <xQueueGenericSend+0x18>
    13aa:	00 d0       	rcall	.+0      	; 0x13ac <xQueueGenericSend+0x1a>
    13ac:	1f 92       	push	r1
    13ae:	cd b7       	in	r28, 0x3d	; 61
    13b0:	de b7       	in	r29, 0x3e	; 62
    13b2:	8c 01       	movw	r16, r24
    13b4:	6b 01       	movw	r12, r22
    13b6:	5d 83       	std	Y+5, r21	; 0x05
    13b8:	4c 83       	std	Y+4, r20	; 0x04
    13ba:	a2 2e       	mov	r10, r18
    13bc:	b1 2c       	mov	r11, r1
    13be:	99 24       	eor	r9, r9
    13c0:	93 94       	inc	r9
    13c2:	7c 01       	movw	r14, r24
    13c4:	88 e0       	ldi	r24, 0x08	; 8
    13c6:	e8 0e       	add	r14, r24
    13c8:	f1 1c       	adc	r15, r1
    13ca:	0f b6       	in	r0, 0x3f	; 63
    13cc:	f8 94       	cli
    13ce:	0f 92       	push	r0
    13d0:	f8 01       	movw	r30, r16
    13d2:	92 8d       	ldd	r25, Z+26	; 0x1a
    13d4:	83 8d       	ldd	r24, Z+27	; 0x1b
    13d6:	98 17       	cp	r25, r24
    13d8:	18 f0       	brcs	.+6      	; 0x13e0 <xQueueGenericSend+0x4e>
    13da:	f2 e0       	ldi	r31, 0x02	; 2
    13dc:	af 12       	cpse	r10, r31
    13de:	19 c0       	rjmp	.+50     	; 0x1412 <xQueueGenericSend+0x80>
    13e0:	4a 2d       	mov	r20, r10
    13e2:	b6 01       	movw	r22, r12
    13e4:	c8 01       	movw	r24, r16
    13e6:	0e 94 b4 08 	call	0x1168	; 0x1168 <prvCopyDataToQueue>
    13ea:	f8 01       	movw	r30, r16
    13ec:	91 89       	ldd	r25, Z+17	; 0x11
    13ee:	99 23       	and	r25, r25
    13f0:	49 f0       	breq	.+18     	; 0x1404 <xQueueGenericSend+0x72>
    13f2:	c8 01       	movw	r24, r16
    13f4:	41 96       	adiw	r24, 0x11	; 17
    13f6:	0e 94 95 0f 	call	0x1f2a	; 0x1f2a <xTaskRemoveFromEventList>
    13fa:	88 23       	and	r24, r24
    13fc:	31 f0       	breq	.+12     	; 0x140a <xQueueGenericSend+0x78>
    13fe:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    1402:	03 c0       	rjmp	.+6      	; 0x140a <xQueueGenericSend+0x78>
    1404:	81 11       	cpse	r24, r1
    1406:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    140a:	0f 90       	pop	r0
    140c:	0f be       	out	0x3f, r0	; 63
    140e:	81 e0       	ldi	r24, 0x01	; 1
    1410:	50 c0       	rjmp	.+160    	; 0x14b2 <xQueueGenericSend+0x120>
    1412:	8c 81       	ldd	r24, Y+4	; 0x04
    1414:	9d 81       	ldd	r25, Y+5	; 0x05
    1416:	89 2b       	or	r24, r25
    1418:	21 f4       	brne	.+8      	; 0x1422 <xQueueGenericSend+0x90>
    141a:	0f 90       	pop	r0
    141c:	0f be       	out	0x3f, r0	; 63
    141e:	80 e0       	ldi	r24, 0x00	; 0
    1420:	48 c0       	rjmp	.+144    	; 0x14b2 <xQueueGenericSend+0x120>
    1422:	b1 10       	cpse	r11, r1
    1424:	05 c0       	rjmp	.+10     	; 0x1430 <xQueueGenericSend+0x9e>
    1426:	ce 01       	movw	r24, r28
    1428:	01 96       	adiw	r24, 0x01	; 1
    142a:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <vTaskInternalSetTimeOutState>
    142e:	b9 2c       	mov	r11, r9
    1430:	0f 90       	pop	r0
    1432:	0f be       	out	0x3f, r0	; 63
    1434:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <vTaskSuspendAll>
    1438:	0f b6       	in	r0, 0x3f	; 63
    143a:	f8 94       	cli
    143c:	0f 92       	push	r0
    143e:	f8 01       	movw	r30, r16
    1440:	85 8d       	ldd	r24, Z+29	; 0x1d
    1442:	8f 3f       	cpi	r24, 0xFF	; 255
    1444:	09 f4       	brne	.+2      	; 0x1448 <xQueueGenericSend+0xb6>
    1446:	15 8e       	std	Z+29, r1	; 0x1d
    1448:	f8 01       	movw	r30, r16
    144a:	86 8d       	ldd	r24, Z+30	; 0x1e
    144c:	8f 3f       	cpi	r24, 0xFF	; 255
    144e:	09 f4       	brne	.+2      	; 0x1452 <xQueueGenericSend+0xc0>
    1450:	16 8e       	std	Z+30, r1	; 0x1e
    1452:	0f 90       	pop	r0
    1454:	0f be       	out	0x3f, r0	; 63
    1456:	be 01       	movw	r22, r28
    1458:	6c 5f       	subi	r22, 0xFC	; 252
    145a:	7f 4f       	sbci	r23, 0xFF	; 255
    145c:	ce 01       	movw	r24, r28
    145e:	01 96       	adiw	r24, 0x01	; 1
    1460:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskCheckForTimeOut>
    1464:	81 11       	cpse	r24, r1
    1466:	1f c0       	rjmp	.+62     	; 0x14a6 <xQueueGenericSend+0x114>
    1468:	0f b6       	in	r0, 0x3f	; 63
    146a:	f8 94       	cli
    146c:	0f 92       	push	r0
    146e:	f8 01       	movw	r30, r16
    1470:	92 8d       	ldd	r25, Z+26	; 0x1a
    1472:	0f 90       	pop	r0
    1474:	0f be       	out	0x3f, r0	; 63
    1476:	83 8d       	ldd	r24, Z+27	; 0x1b
    1478:	98 13       	cpse	r25, r24
    147a:	0f c0       	rjmp	.+30     	; 0x149a <xQueueGenericSend+0x108>
    147c:	6c 81       	ldd	r22, Y+4	; 0x04
    147e:	7d 81       	ldd	r23, Y+5	; 0x05
    1480:	c7 01       	movw	r24, r14
    1482:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <vTaskPlaceOnEventList>
    1486:	c8 01       	movw	r24, r16
    1488:	0e 94 fd 08 	call	0x11fa	; 0x11fa <prvUnlockQueue>
    148c:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <xTaskResumeAll>
    1490:	81 11       	cpse	r24, r1
    1492:	9b cf       	rjmp	.-202    	; 0x13ca <xQueueGenericSend+0x38>
    1494:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    1498:	98 cf       	rjmp	.-208    	; 0x13ca <xQueueGenericSend+0x38>
    149a:	c8 01       	movw	r24, r16
    149c:	0e 94 fd 08 	call	0x11fa	; 0x11fa <prvUnlockQueue>
    14a0:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <xTaskResumeAll>
    14a4:	92 cf       	rjmp	.-220    	; 0x13ca <xQueueGenericSend+0x38>
    14a6:	c8 01       	movw	r24, r16
    14a8:	0e 94 fd 08 	call	0x11fa	; 0x11fa <prvUnlockQueue>
    14ac:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <xTaskResumeAll>
    14b0:	80 e0       	ldi	r24, 0x00	; 0
    14b2:	0f 90       	pop	r0
    14b4:	0f 90       	pop	r0
    14b6:	0f 90       	pop	r0
    14b8:	0f 90       	pop	r0
    14ba:	0f 90       	pop	r0
    14bc:	df 91       	pop	r29
    14be:	cf 91       	pop	r28
    14c0:	1f 91       	pop	r17
    14c2:	0f 91       	pop	r16
    14c4:	ff 90       	pop	r15
    14c6:	ef 90       	pop	r14
    14c8:	df 90       	pop	r13
    14ca:	cf 90       	pop	r12
    14cc:	bf 90       	pop	r11
    14ce:	af 90       	pop	r10
    14d0:	9f 90       	pop	r9
    14d2:	08 95       	ret

000014d4 <xQueueSemaphoreTake>:
    14d4:	cf 92       	push	r12
    14d6:	df 92       	push	r13
    14d8:	ef 92       	push	r14
    14da:	ff 92       	push	r15
    14dc:	0f 93       	push	r16
    14de:	1f 93       	push	r17
    14e0:	cf 93       	push	r28
    14e2:	df 93       	push	r29
    14e4:	00 d0       	rcall	.+0      	; 0x14e6 <xQueueSemaphoreTake+0x12>
    14e6:	00 d0       	rcall	.+0      	; 0x14e8 <xQueueSemaphoreTake+0x14>
    14e8:	1f 92       	push	r1
    14ea:	cd b7       	in	r28, 0x3d	; 61
    14ec:	de b7       	in	r29, 0x3e	; 62
    14ee:	8c 01       	movw	r16, r24
    14f0:	7d 83       	std	Y+5, r23	; 0x05
    14f2:	6c 83       	std	Y+4, r22	; 0x04
    14f4:	d1 2c       	mov	r13, r1
    14f6:	cc 24       	eor	r12, r12
    14f8:	c3 94       	inc	r12
    14fa:	7c 01       	movw	r14, r24
    14fc:	81 e1       	ldi	r24, 0x11	; 17
    14fe:	e8 0e       	add	r14, r24
    1500:	f1 1c       	adc	r15, r1
    1502:	0f b6       	in	r0, 0x3f	; 63
    1504:	f8 94       	cli
    1506:	0f 92       	push	r0
    1508:	f8 01       	movw	r30, r16
    150a:	82 8d       	ldd	r24, Z+26	; 0x1a
    150c:	88 23       	and	r24, r24
    150e:	81 f0       	breq	.+32     	; 0x1530 <xQueueSemaphoreTake+0x5c>
    1510:	81 50       	subi	r24, 0x01	; 1
    1512:	82 8f       	std	Z+26, r24	; 0x1a
    1514:	80 85       	ldd	r24, Z+8	; 0x08
    1516:	88 23       	and	r24, r24
    1518:	39 f0       	breq	.+14     	; 0x1528 <xQueueSemaphoreTake+0x54>
    151a:	c8 01       	movw	r24, r16
    151c:	08 96       	adiw	r24, 0x08	; 8
    151e:	0e 94 95 0f 	call	0x1f2a	; 0x1f2a <xTaskRemoveFromEventList>
    1522:	81 11       	cpse	r24, r1
    1524:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    1528:	0f 90       	pop	r0
    152a:	0f be       	out	0x3f, r0	; 63
    152c:	81 e0       	ldi	r24, 0x01	; 1
    152e:	51 c0       	rjmp	.+162    	; 0x15d2 <xQueueSemaphoreTake+0xfe>
    1530:	8c 81       	ldd	r24, Y+4	; 0x04
    1532:	9d 81       	ldd	r25, Y+5	; 0x05
    1534:	89 2b       	or	r24, r25
    1536:	21 f4       	brne	.+8      	; 0x1540 <xQueueSemaphoreTake+0x6c>
    1538:	0f 90       	pop	r0
    153a:	0f be       	out	0x3f, r0	; 63
    153c:	80 e0       	ldi	r24, 0x00	; 0
    153e:	49 c0       	rjmp	.+146    	; 0x15d2 <xQueueSemaphoreTake+0xfe>
    1540:	d1 10       	cpse	r13, r1
    1542:	05 c0       	rjmp	.+10     	; 0x154e <xQueueSemaphoreTake+0x7a>
    1544:	ce 01       	movw	r24, r28
    1546:	01 96       	adiw	r24, 0x01	; 1
    1548:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <vTaskInternalSetTimeOutState>
    154c:	dc 2c       	mov	r13, r12
    154e:	0f 90       	pop	r0
    1550:	0f be       	out	0x3f, r0	; 63
    1552:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <vTaskSuspendAll>
    1556:	0f b6       	in	r0, 0x3f	; 63
    1558:	f8 94       	cli
    155a:	0f 92       	push	r0
    155c:	f8 01       	movw	r30, r16
    155e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1560:	8f 3f       	cpi	r24, 0xFF	; 255
    1562:	09 f4       	brne	.+2      	; 0x1566 <xQueueSemaphoreTake+0x92>
    1564:	15 8e       	std	Z+29, r1	; 0x1d
    1566:	f8 01       	movw	r30, r16
    1568:	86 8d       	ldd	r24, Z+30	; 0x1e
    156a:	8f 3f       	cpi	r24, 0xFF	; 255
    156c:	09 f4       	brne	.+2      	; 0x1570 <xQueueSemaphoreTake+0x9c>
    156e:	16 8e       	std	Z+30, r1	; 0x1e
    1570:	0f 90       	pop	r0
    1572:	0f be       	out	0x3f, r0	; 63
    1574:	be 01       	movw	r22, r28
    1576:	6c 5f       	subi	r22, 0xFC	; 252
    1578:	7f 4f       	sbci	r23, 0xFF	; 255
    157a:	ce 01       	movw	r24, r28
    157c:	01 96       	adiw	r24, 0x01	; 1
    157e:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskCheckForTimeOut>
    1582:	81 11       	cpse	r24, r1
    1584:	1a c0       	rjmp	.+52     	; 0x15ba <xQueueSemaphoreTake+0xe6>
    1586:	c8 01       	movw	r24, r16
    1588:	0e 94 a9 08 	call	0x1152	; 0x1152 <prvIsQueueEmpty>
    158c:	88 23       	and	r24, r24
    158e:	79 f0       	breq	.+30     	; 0x15ae <xQueueSemaphoreTake+0xda>
    1590:	6c 81       	ldd	r22, Y+4	; 0x04
    1592:	7d 81       	ldd	r23, Y+5	; 0x05
    1594:	c7 01       	movw	r24, r14
    1596:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <vTaskPlaceOnEventList>
    159a:	c8 01       	movw	r24, r16
    159c:	0e 94 fd 08 	call	0x11fa	; 0x11fa <prvUnlockQueue>
    15a0:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <xTaskResumeAll>
    15a4:	81 11       	cpse	r24, r1
    15a6:	ad cf       	rjmp	.-166    	; 0x1502 <xQueueSemaphoreTake+0x2e>
    15a8:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    15ac:	aa cf       	rjmp	.-172    	; 0x1502 <xQueueSemaphoreTake+0x2e>
    15ae:	c8 01       	movw	r24, r16
    15b0:	0e 94 fd 08 	call	0x11fa	; 0x11fa <prvUnlockQueue>
    15b4:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <xTaskResumeAll>
    15b8:	a4 cf       	rjmp	.-184    	; 0x1502 <xQueueSemaphoreTake+0x2e>
    15ba:	c8 01       	movw	r24, r16
    15bc:	0e 94 fd 08 	call	0x11fa	; 0x11fa <prvUnlockQueue>
    15c0:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <xTaskResumeAll>
    15c4:	c8 01       	movw	r24, r16
    15c6:	0e 94 a9 08 	call	0x1152	; 0x1152 <prvIsQueueEmpty>
    15ca:	88 23       	and	r24, r24
    15cc:	09 f4       	brne	.+2      	; 0x15d0 <xQueueSemaphoreTake+0xfc>
    15ce:	99 cf       	rjmp	.-206    	; 0x1502 <xQueueSemaphoreTake+0x2e>
    15d0:	80 e0       	ldi	r24, 0x00	; 0
    15d2:	0f 90       	pop	r0
    15d4:	0f 90       	pop	r0
    15d6:	0f 90       	pop	r0
    15d8:	0f 90       	pop	r0
    15da:	0f 90       	pop	r0
    15dc:	df 91       	pop	r29
    15de:	cf 91       	pop	r28
    15e0:	1f 91       	pop	r17
    15e2:	0f 91       	pop	r16
    15e4:	ff 90       	pop	r15
    15e6:	ef 90       	pop	r14
    15e8:	df 90       	pop	r13
    15ea:	cf 90       	pop	r12
    15ec:	08 95       	ret

000015ee <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    15ee:	0f b6       	in	r0, 0x3f	; 63
    15f0:	f8 94       	cli
    15f2:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    15f4:	fc 01       	movw	r30, r24
    15f6:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    15f8:	0f 90       	pop	r0
    15fa:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    15fc:	08 95       	ret

000015fe <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    15fe:	e0 91 a3 06 	lds	r30, 0x06A3	; 0x8006a3 <pxDelayedTaskList>
    1602:	f0 91 a4 06 	lds	r31, 0x06A4	; 0x8006a4 <pxDelayedTaskList+0x1>
    1606:	80 81       	ld	r24, Z
    1608:	81 11       	cpse	r24, r1
    160a:	07 c0       	rjmp	.+14     	; 0x161a <prvResetNextTaskUnblockTime+0x1c>
    160c:	8f ef       	ldi	r24, 0xFF	; 255
    160e:	9f ef       	ldi	r25, 0xFF	; 255
    1610:	90 93 7b 06 	sts	0x067B, r25	; 0x80067b <xNextTaskUnblockTime+0x1>
    1614:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <xNextTaskUnblockTime>
    1618:	08 95       	ret
    161a:	e0 91 a3 06 	lds	r30, 0x06A3	; 0x8006a3 <pxDelayedTaskList>
    161e:	f0 91 a4 06 	lds	r31, 0x06A4	; 0x8006a4 <pxDelayedTaskList+0x1>
    1622:	05 80       	ldd	r0, Z+5	; 0x05
    1624:	f6 81       	ldd	r31, Z+6	; 0x06
    1626:	e0 2d       	mov	r30, r0
    1628:	06 80       	ldd	r0, Z+6	; 0x06
    162a:	f7 81       	ldd	r31, Z+7	; 0x07
    162c:	e0 2d       	mov	r30, r0
    162e:	82 81       	ldd	r24, Z+2	; 0x02
    1630:	93 81       	ldd	r25, Z+3	; 0x03
    1632:	90 93 7b 06 	sts	0x067B, r25	; 0x80067b <xNextTaskUnblockTime+0x1>
    1636:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <xNextTaskUnblockTime>
    163a:	08 95       	ret

0000163c <prvIdleTask>:
    163c:	0f e8       	ldi	r16, 0x8F	; 143
    163e:	16 e0       	ldi	r17, 0x06	; 6
    1640:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <uxDeletedTasksWaitingCleanUp>
    1644:	88 23       	and	r24, r24
    1646:	e1 f3       	breq	.-8      	; 0x1640 <prvIdleTask+0x4>
    1648:	0f b6       	in	r0, 0x3f	; 63
    164a:	f8 94       	cli
    164c:	0f 92       	push	r0
    164e:	d8 01       	movw	r26, r16
    1650:	15 96       	adiw	r26, 0x05	; 5
    1652:	ed 91       	ld	r30, X+
    1654:	fc 91       	ld	r31, X
    1656:	16 97       	sbiw	r26, 0x06	; 6
    1658:	c6 81       	ldd	r28, Z+6	; 0x06
    165a:	d7 81       	ldd	r29, Z+7	; 0x07
    165c:	ce 01       	movw	r24, r28
    165e:	02 96       	adiw	r24, 0x02	; 2
    1660:	0e 94 f3 06 	call	0xde6	; 0xde6 <uxListRemove>
    1664:	80 91 84 06 	lds	r24, 0x0684	; 0x800684 <uxCurrentNumberOfTasks>
    1668:	81 50       	subi	r24, 0x01	; 1
    166a:	80 93 84 06 	sts	0x0684, r24	; 0x800684 <uxCurrentNumberOfTasks>
    166e:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <uxDeletedTasksWaitingCleanUp>
    1672:	81 50       	subi	r24, 0x01	; 1
    1674:	80 93 8e 06 	sts	0x068E, r24	; 0x80068e <uxDeletedTasksWaitingCleanUp>
    1678:	0f 90       	pop	r0
    167a:	0f be       	out	0x3f, r0	; 63
    167c:	8f 89       	ldd	r24, Y+23	; 0x17
    167e:	98 8d       	ldd	r25, Y+24	; 0x18
    1680:	0e 94 a8 08 	call	0x1150	; 0x1150 <vPortFree>
    1684:	ce 01       	movw	r24, r28
    1686:	0e 94 a8 08 	call	0x1150	; 0x1150 <vPortFree>
    168a:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <uxDeletedTasksWaitingCleanUp>
    168e:	81 11       	cpse	r24, r1
    1690:	db cf       	rjmp	.-74     	; 0x1648 <prvIdleTask+0xc>
    1692:	d6 cf       	rjmp	.-84     	; 0x1640 <prvIdleTask+0x4>

00001694 <prvAddCurrentTaskToDelayedList>:
    1694:	ff 92       	push	r15
    1696:	0f 93       	push	r16
    1698:	1f 93       	push	r17
    169a:	cf 93       	push	r28
    169c:	df 93       	push	r29
    169e:	ec 01       	movw	r28, r24
    16a0:	f6 2e       	mov	r15, r22
    16a2:	00 91 82 06 	lds	r16, 0x0682	; 0x800682 <xTickCount>
    16a6:	10 91 83 06 	lds	r17, 0x0683	; 0x800683 <xTickCount+0x1>
    16aa:	80 91 e4 06 	lds	r24, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    16ae:	90 91 e5 06 	lds	r25, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    16b2:	02 96       	adiw	r24, 0x02	; 2
    16b4:	0e 94 f3 06 	call	0xde6	; 0xde6 <uxListRemove>
    16b8:	cf 3f       	cpi	r28, 0xFF	; 255
    16ba:	8f ef       	ldi	r24, 0xFF	; 255
    16bc:	d8 07       	cpc	r29, r24
    16be:	69 f4       	brne	.+26     	; 0x16da <prvAddCurrentTaskToDelayedList+0x46>
    16c0:	ff 20       	and	r15, r15
    16c2:	59 f0       	breq	.+22     	; 0x16da <prvAddCurrentTaskToDelayedList+0x46>
    16c4:	60 91 e4 06 	lds	r22, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    16c8:	70 91 e5 06 	lds	r23, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    16cc:	6e 5f       	subi	r22, 0xFE	; 254
    16ce:	7f 4f       	sbci	r23, 0xFF	; 255
    16d0:	85 e8       	ldi	r24, 0x85	; 133
    16d2:	96 e0       	ldi	r25, 0x06	; 6
    16d4:	0e 94 a1 06 	call	0xd42	; 0xd42 <vListInsertEnd>
    16d8:	2f c0       	rjmp	.+94     	; 0x1738 <prvAddCurrentTaskToDelayedList+0xa4>
    16da:	c0 0f       	add	r28, r16
    16dc:	d1 1f       	adc	r29, r17
    16de:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    16e2:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    16e6:	d3 83       	std	Z+3, r29	; 0x03
    16e8:	c2 83       	std	Z+2, r28	; 0x02
    16ea:	c0 17       	cp	r28, r16
    16ec:	d1 07       	cpc	r29, r17
    16ee:	68 f4       	brcc	.+26     	; 0x170a <prvAddCurrentTaskToDelayedList+0x76>
    16f0:	60 91 e4 06 	lds	r22, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    16f4:	70 91 e5 06 	lds	r23, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    16f8:	80 91 a1 06 	lds	r24, 0x06A1	; 0x8006a1 <pxOverflowDelayedTaskList>
    16fc:	90 91 a2 06 	lds	r25, 0x06A2	; 0x8006a2 <pxOverflowDelayedTaskList+0x1>
    1700:	6e 5f       	subi	r22, 0xFE	; 254
    1702:	7f 4f       	sbci	r23, 0xFF	; 255
    1704:	0e 94 c2 06 	call	0xd84	; 0xd84 <vListInsert>
    1708:	17 c0       	rjmp	.+46     	; 0x1738 <prvAddCurrentTaskToDelayedList+0xa4>
    170a:	60 91 e4 06 	lds	r22, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    170e:	70 91 e5 06 	lds	r23, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    1712:	80 91 a3 06 	lds	r24, 0x06A3	; 0x8006a3 <pxDelayedTaskList>
    1716:	90 91 a4 06 	lds	r25, 0x06A4	; 0x8006a4 <pxDelayedTaskList+0x1>
    171a:	6e 5f       	subi	r22, 0xFE	; 254
    171c:	7f 4f       	sbci	r23, 0xFF	; 255
    171e:	0e 94 c2 06 	call	0xd84	; 0xd84 <vListInsert>
    1722:	80 91 7a 06 	lds	r24, 0x067A	; 0x80067a <xNextTaskUnblockTime>
    1726:	90 91 7b 06 	lds	r25, 0x067B	; 0x80067b <xNextTaskUnblockTime+0x1>
    172a:	c8 17       	cp	r28, r24
    172c:	d9 07       	cpc	r29, r25
    172e:	20 f4       	brcc	.+8      	; 0x1738 <prvAddCurrentTaskToDelayedList+0xa4>
    1730:	d0 93 7b 06 	sts	0x067B, r29	; 0x80067b <xNextTaskUnblockTime+0x1>
    1734:	c0 93 7a 06 	sts	0x067A, r28	; 0x80067a <xNextTaskUnblockTime>
    1738:	df 91       	pop	r29
    173a:	cf 91       	pop	r28
    173c:	1f 91       	pop	r17
    173e:	0f 91       	pop	r16
    1740:	ff 90       	pop	r15
    1742:	08 95       	ret

00001744 <xTaskCreate>:
    1744:	4f 92       	push	r4
    1746:	5f 92       	push	r5
    1748:	6f 92       	push	r6
    174a:	7f 92       	push	r7
    174c:	8f 92       	push	r8
    174e:	9f 92       	push	r9
    1750:	af 92       	push	r10
    1752:	bf 92       	push	r11
    1754:	cf 92       	push	r12
    1756:	df 92       	push	r13
    1758:	ef 92       	push	r14
    175a:	ff 92       	push	r15
    175c:	0f 93       	push	r16
    175e:	1f 93       	push	r17
    1760:	cf 93       	push	r28
    1762:	df 93       	push	r29
    1764:	4c 01       	movw	r8, r24
    1766:	6b 01       	movw	r12, r22
    1768:	5a 01       	movw	r10, r20
    176a:	29 01       	movw	r4, r18
    176c:	ca 01       	movw	r24, r20
    176e:	0e 94 73 08 	call	0x10e6	; 0x10e6 <pvPortMalloc>
    1772:	3c 01       	movw	r6, r24
    1774:	89 2b       	or	r24, r25
    1776:	09 f4       	brne	.+2      	; 0x177a <xTaskCreate+0x36>
    1778:	e7 c0       	rjmp	.+462    	; 0x1948 <xTaskCreate+0x204>
    177a:	86 e2       	ldi	r24, 0x26	; 38
    177c:	90 e0       	ldi	r25, 0x00	; 0
    177e:	0e 94 73 08 	call	0x10e6	; 0x10e6 <pvPortMalloc>
    1782:	ec 01       	movw	r28, r24
    1784:	89 2b       	or	r24, r25
    1786:	59 f0       	breq	.+22     	; 0x179e <xTaskCreate+0x5a>
    1788:	78 8e       	std	Y+24, r7	; 0x18
    178a:	6f 8a       	std	Y+23, r6	; 0x17
    178c:	81 e0       	ldi	r24, 0x01	; 1
    178e:	a8 1a       	sub	r10, r24
    1790:	b1 08       	sbc	r11, r1
    1792:	a6 0c       	add	r10, r6
    1794:	b7 1c       	adc	r11, r7
    1796:	c1 14       	cp	r12, r1
    1798:	d1 04       	cpc	r13, r1
    179a:	29 f4       	brne	.+10     	; 0x17a6 <xTaskCreate+0x62>
    179c:	20 c0       	rjmp	.+64     	; 0x17de <xTaskCreate+0x9a>
    179e:	c3 01       	movw	r24, r6
    17a0:	0e 94 a8 08 	call	0x1150	; 0x1150 <vPortFree>
    17a4:	d1 c0       	rjmp	.+418    	; 0x1948 <xTaskCreate+0x204>
    17a6:	d6 01       	movw	r26, r12
    17a8:	8c 91       	ld	r24, X
    17aa:	89 8f       	std	Y+25, r24	; 0x19
    17ac:	8c 91       	ld	r24, X
    17ae:	88 23       	and	r24, r24
    17b0:	a1 f0       	breq	.+40     	; 0x17da <xTaskCreate+0x96>
    17b2:	ae 01       	movw	r20, r28
    17b4:	46 5e       	subi	r20, 0xE6	; 230
    17b6:	5f 4f       	sbci	r21, 0xFF	; 255
    17b8:	f6 01       	movw	r30, r12
    17ba:	31 96       	adiw	r30, 0x01	; 1
    17bc:	b8 e0       	ldi	r27, 0x08	; 8
    17be:	cb 0e       	add	r12, r27
    17c0:	d1 1c       	adc	r13, r1
    17c2:	cf 01       	movw	r24, r30
    17c4:	21 91       	ld	r18, Z+
    17c6:	da 01       	movw	r26, r20
    17c8:	2d 93       	st	X+, r18
    17ca:	ad 01       	movw	r20, r26
    17cc:	dc 01       	movw	r26, r24
    17ce:	8c 91       	ld	r24, X
    17d0:	88 23       	and	r24, r24
    17d2:	19 f0       	breq	.+6      	; 0x17da <xTaskCreate+0x96>
    17d4:	ce 16       	cp	r12, r30
    17d6:	df 06       	cpc	r13, r31
    17d8:	a1 f7       	brne	.-24     	; 0x17c2 <xTaskCreate+0x7e>
    17da:	18 a2       	std	Y+32, r1	; 0x20
    17dc:	01 c0       	rjmp	.+2      	; 0x17e0 <xTaskCreate+0x9c>
    17de:	19 8e       	std	Y+25, r1	; 0x19
    17e0:	05 30       	cpi	r16, 0x05	; 5
    17e2:	08 f0       	brcs	.+2      	; 0x17e6 <xTaskCreate+0xa2>
    17e4:	04 e0       	ldi	r16, 0x04	; 4
    17e6:	0e 8b       	std	Y+22, r16	; 0x16
    17e8:	6e 01       	movw	r12, r28
    17ea:	b2 e0       	ldi	r27, 0x02	; 2
    17ec:	cb 0e       	add	r12, r27
    17ee:	d1 1c       	adc	r13, r1
    17f0:	c6 01       	movw	r24, r12
    17f2:	0e 94 9d 06 	call	0xd3a	; 0xd3a <vListInitialiseItem>
    17f6:	ce 01       	movw	r24, r28
    17f8:	0c 96       	adiw	r24, 0x0c	; 12
    17fa:	0e 94 9d 06 	call	0xd3a	; 0xd3a <vListInitialiseItem>
    17fe:	d9 87       	std	Y+9, r29	; 0x09
    1800:	c8 87       	std	Y+8, r28	; 0x08
    1802:	85 e0       	ldi	r24, 0x05	; 5
    1804:	90 e0       	ldi	r25, 0x00	; 0
    1806:	80 1b       	sub	r24, r16
    1808:	91 09       	sbc	r25, r1
    180a:	9d 87       	std	Y+13, r25	; 0x0d
    180c:	8c 87       	std	Y+12, r24	; 0x0c
    180e:	db 8b       	std	Y+19, r29	; 0x13
    1810:	ca 8b       	std	Y+18, r28	; 0x12
    1812:	19 a2       	std	Y+33, r1	; 0x21
    1814:	1a a2       	std	Y+34, r1	; 0x22
    1816:	1b a2       	std	Y+35, r1	; 0x23
    1818:	1c a2       	std	Y+36, r1	; 0x24
    181a:	1d a2       	std	Y+37, r1	; 0x25
    181c:	a2 01       	movw	r20, r4
    181e:	b4 01       	movw	r22, r8
    1820:	c5 01       	movw	r24, r10
    1822:	0e 94 1a 07 	call	0xe34	; 0xe34 <pxPortInitialiseStack>
    1826:	99 83       	std	Y+1, r25	; 0x01
    1828:	88 83       	st	Y, r24
    182a:	e1 14       	cp	r14, r1
    182c:	f1 04       	cpc	r15, r1
    182e:	19 f0       	breq	.+6      	; 0x1836 <xTaskCreate+0xf2>
    1830:	f7 01       	movw	r30, r14
    1832:	d1 83       	std	Z+1, r29	; 0x01
    1834:	c0 83       	st	Z, r28
    1836:	0f b6       	in	r0, 0x3f	; 63
    1838:	f8 94       	cli
    183a:	0f 92       	push	r0
    183c:	80 91 84 06 	lds	r24, 0x0684	; 0x800684 <uxCurrentNumberOfTasks>
    1840:	8f 5f       	subi	r24, 0xFF	; 255
    1842:	80 93 84 06 	sts	0x0684, r24	; 0x800684 <uxCurrentNumberOfTasks>
    1846:	80 91 e4 06 	lds	r24, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    184a:	90 91 e5 06 	lds	r25, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    184e:	89 2b       	or	r24, r25
    1850:	d1 f5       	brne	.+116    	; 0x18c6 <xTaskCreate+0x182>
    1852:	d0 93 e5 06 	sts	0x06E5, r29	; 0x8006e5 <pxCurrentTCB+0x1>
    1856:	c0 93 e4 06 	sts	0x06E4, r28	; 0x8006e4 <pxCurrentTCB>
    185a:	80 91 84 06 	lds	r24, 0x0684	; 0x800684 <uxCurrentNumberOfTasks>
    185e:	81 30       	cpi	r24, 0x01	; 1
    1860:	09 f0       	breq	.+2      	; 0x1864 <xTaskCreate+0x120>
    1862:	41 c0       	rjmp	.+130    	; 0x18e6 <xTaskCreate+0x1a2>
    1864:	07 eb       	ldi	r16, 0xB7	; 183
    1866:	16 e0       	ldi	r17, 0x06	; 6
    1868:	0f 2e       	mov	r0, r31
    186a:	f4 ee       	ldi	r31, 0xE4	; 228
    186c:	ef 2e       	mov	r14, r31
    186e:	f6 e0       	ldi	r31, 0x06	; 6
    1870:	ff 2e       	mov	r15, r31
    1872:	f0 2d       	mov	r31, r0
    1874:	c8 01       	movw	r24, r16
    1876:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInitialise>
    187a:	07 5f       	subi	r16, 0xF7	; 247
    187c:	1f 4f       	sbci	r17, 0xFF	; 255
    187e:	0e 15       	cp	r16, r14
    1880:	1f 05       	cpc	r17, r15
    1882:	c1 f7       	brne	.-16     	; 0x1874 <xTaskCreate+0x130>
    1884:	8e ea       	ldi	r24, 0xAE	; 174
    1886:	96 e0       	ldi	r25, 0x06	; 6
    1888:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInitialise>
    188c:	85 ea       	ldi	r24, 0xA5	; 165
    188e:	96 e0       	ldi	r25, 0x06	; 6
    1890:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInitialise>
    1894:	88 e9       	ldi	r24, 0x98	; 152
    1896:	96 e0       	ldi	r25, 0x06	; 6
    1898:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInitialise>
    189c:	8f e8       	ldi	r24, 0x8F	; 143
    189e:	96 e0       	ldi	r25, 0x06	; 6
    18a0:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInitialise>
    18a4:	85 e8       	ldi	r24, 0x85	; 133
    18a6:	96 e0       	ldi	r25, 0x06	; 6
    18a8:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInitialise>
    18ac:	8e ea       	ldi	r24, 0xAE	; 174
    18ae:	96 e0       	ldi	r25, 0x06	; 6
    18b0:	90 93 a4 06 	sts	0x06A4, r25	; 0x8006a4 <pxDelayedTaskList+0x1>
    18b4:	80 93 a3 06 	sts	0x06A3, r24	; 0x8006a3 <pxDelayedTaskList>
    18b8:	85 ea       	ldi	r24, 0xA5	; 165
    18ba:	96 e0       	ldi	r25, 0x06	; 6
    18bc:	90 93 a2 06 	sts	0x06A2, r25	; 0x8006a2 <pxOverflowDelayedTaskList+0x1>
    18c0:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <pxOverflowDelayedTaskList>
    18c4:	10 c0       	rjmp	.+32     	; 0x18e6 <xTaskCreate+0x1a2>
    18c6:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <xSchedulerRunning>
    18ca:	81 11       	cpse	r24, r1
    18cc:	0c c0       	rjmp	.+24     	; 0x18e6 <xTaskCreate+0x1a2>
    18ce:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    18d2:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    18d6:	96 89       	ldd	r25, Z+22	; 0x16
    18d8:	8e 89       	ldd	r24, Y+22	; 0x16
    18da:	89 17       	cp	r24, r25
    18dc:	20 f0       	brcs	.+8      	; 0x18e6 <xTaskCreate+0x1a2>
    18de:	d0 93 e5 06 	sts	0x06E5, r29	; 0x8006e5 <pxCurrentTCB+0x1>
    18e2:	c0 93 e4 06 	sts	0x06E4, r28	; 0x8006e4 <pxCurrentTCB>
    18e6:	80 91 7c 06 	lds	r24, 0x067C	; 0x80067c <uxTaskNumber>
    18ea:	8f 5f       	subi	r24, 0xFF	; 255
    18ec:	80 93 7c 06 	sts	0x067C, r24	; 0x80067c <uxTaskNumber>
    18f0:	8e 89       	ldd	r24, Y+22	; 0x16
    18f2:	90 91 81 06 	lds	r25, 0x0681	; 0x800681 <uxTopReadyPriority>
    18f6:	98 17       	cp	r25, r24
    18f8:	10 f4       	brcc	.+4      	; 0x18fe <xTaskCreate+0x1ba>
    18fa:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <uxTopReadyPriority>
    18fe:	90 e0       	ldi	r25, 0x00	; 0
    1900:	9c 01       	movw	r18, r24
    1902:	22 0f       	add	r18, r18
    1904:	33 1f       	adc	r19, r19
    1906:	22 0f       	add	r18, r18
    1908:	33 1f       	adc	r19, r19
    190a:	22 0f       	add	r18, r18
    190c:	33 1f       	adc	r19, r19
    190e:	82 0f       	add	r24, r18
    1910:	93 1f       	adc	r25, r19
    1912:	b6 01       	movw	r22, r12
    1914:	89 54       	subi	r24, 0x49	; 73
    1916:	99 4f       	sbci	r25, 0xF9	; 249
    1918:	0e 94 a1 06 	call	0xd42	; 0xd42 <vListInsertEnd>
    191c:	0f 90       	pop	r0
    191e:	0f be       	out	0x3f, r0	; 63
    1920:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <xSchedulerRunning>
    1924:	88 23       	and	r24, r24
    1926:	61 f0       	breq	.+24     	; 0x1940 <xTaskCreate+0x1fc>
    1928:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    192c:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    1930:	96 89       	ldd	r25, Z+22	; 0x16
    1932:	8e 89       	ldd	r24, Y+22	; 0x16
    1934:	98 17       	cp	r25, r24
    1936:	30 f4       	brcc	.+12     	; 0x1944 <xTaskCreate+0x200>
    1938:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    193c:	81 e0       	ldi	r24, 0x01	; 1
    193e:	05 c0       	rjmp	.+10     	; 0x194a <xTaskCreate+0x206>
    1940:	81 e0       	ldi	r24, 0x01	; 1
    1942:	03 c0       	rjmp	.+6      	; 0x194a <xTaskCreate+0x206>
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	01 c0       	rjmp	.+2      	; 0x194a <xTaskCreate+0x206>
    1948:	8f ef       	ldi	r24, 0xFF	; 255
    194a:	df 91       	pop	r29
    194c:	cf 91       	pop	r28
    194e:	1f 91       	pop	r17
    1950:	0f 91       	pop	r16
    1952:	ff 90       	pop	r15
    1954:	ef 90       	pop	r14
    1956:	df 90       	pop	r13
    1958:	cf 90       	pop	r12
    195a:	bf 90       	pop	r11
    195c:	af 90       	pop	r10
    195e:	9f 90       	pop	r9
    1960:	8f 90       	pop	r8
    1962:	7f 90       	pop	r7
    1964:	6f 90       	pop	r6
    1966:	5f 90       	pop	r5
    1968:	4f 90       	pop	r4
    196a:	08 95       	ret

0000196c <vTaskResume>:
    196c:	0f 93       	push	r16
    196e:	1f 93       	push	r17
    1970:	cf 93       	push	r28
    1972:	df 93       	push	r29
    1974:	20 91 e4 06 	lds	r18, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    1978:	30 91 e5 06 	lds	r19, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    197c:	82 17       	cp	r24, r18
    197e:	93 07       	cpc	r25, r19
    1980:	09 f4       	brne	.+2      	; 0x1984 <vTaskResume+0x18>
    1982:	3e c0       	rjmp	.+124    	; 0x1a00 <vTaskResume+0x94>
    1984:	00 97       	sbiw	r24, 0x00	; 0
    1986:	09 f4       	brne	.+2      	; 0x198a <vTaskResume+0x1e>
    1988:	3b c0       	rjmp	.+118    	; 0x1a00 <vTaskResume+0x94>
    198a:	0f b6       	in	r0, 0x3f	; 63
    198c:	f8 94       	cli
    198e:	0f 92       	push	r0
    1990:	fc 01       	movw	r30, r24
    1992:	22 85       	ldd	r18, Z+10	; 0x0a
    1994:	33 85       	ldd	r19, Z+11	; 0x0b
    1996:	25 58       	subi	r18, 0x85	; 133
    1998:	36 40       	sbci	r19, 0x06	; 6
    199a:	81 f5       	brne	.+96     	; 0x19fc <vTaskResume+0x90>
    199c:	fc 01       	movw	r30, r24
    199e:	24 89       	ldd	r18, Z+20	; 0x14
    19a0:	35 89       	ldd	r19, Z+21	; 0x15
    19a2:	f6 e0       	ldi	r31, 0x06	; 6
    19a4:	28 39       	cpi	r18, 0x98	; 152
    19a6:	3f 07       	cpc	r19, r31
    19a8:	49 f1       	breq	.+82     	; 0x19fc <vTaskResume+0x90>
    19aa:	23 2b       	or	r18, r19
    19ac:	39 f5       	brne	.+78     	; 0x19fc <vTaskResume+0x90>
    19ae:	ec 01       	movw	r28, r24
    19b0:	8c 01       	movw	r16, r24
    19b2:	0e 5f       	subi	r16, 0xFE	; 254
    19b4:	1f 4f       	sbci	r17, 0xFF	; 255
    19b6:	c8 01       	movw	r24, r16
    19b8:	0e 94 f3 06 	call	0xde6	; 0xde6 <uxListRemove>
    19bc:	8e 89       	ldd	r24, Y+22	; 0x16
    19be:	90 91 81 06 	lds	r25, 0x0681	; 0x800681 <uxTopReadyPriority>
    19c2:	98 17       	cp	r25, r24
    19c4:	10 f4       	brcc	.+4      	; 0x19ca <vTaskResume+0x5e>
    19c6:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <uxTopReadyPriority>
    19ca:	90 e0       	ldi	r25, 0x00	; 0
    19cc:	9c 01       	movw	r18, r24
    19ce:	22 0f       	add	r18, r18
    19d0:	33 1f       	adc	r19, r19
    19d2:	22 0f       	add	r18, r18
    19d4:	33 1f       	adc	r19, r19
    19d6:	22 0f       	add	r18, r18
    19d8:	33 1f       	adc	r19, r19
    19da:	82 0f       	add	r24, r18
    19dc:	93 1f       	adc	r25, r19
    19de:	b8 01       	movw	r22, r16
    19e0:	89 54       	subi	r24, 0x49	; 73
    19e2:	99 4f       	sbci	r25, 0xF9	; 249
    19e4:	0e 94 a1 06 	call	0xd42	; 0xd42 <vListInsertEnd>
    19e8:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    19ec:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    19f0:	9e 89       	ldd	r25, Y+22	; 0x16
    19f2:	86 89       	ldd	r24, Z+22	; 0x16
    19f4:	98 17       	cp	r25, r24
    19f6:	10 f0       	brcs	.+4      	; 0x19fc <vTaskResume+0x90>
    19f8:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    19fc:	0f 90       	pop	r0
    19fe:	0f be       	out	0x3f, r0	; 63
    1a00:	df 91       	pop	r29
    1a02:	cf 91       	pop	r28
    1a04:	1f 91       	pop	r17
    1a06:	0f 91       	pop	r16
    1a08:	08 95       	ret

00001a0a <vTaskStartScheduler>:
    1a0a:	ef 92       	push	r14
    1a0c:	ff 92       	push	r15
    1a0e:	0f 93       	push	r16
    1a10:	0f 2e       	mov	r0, r31
    1a12:	f8 e7       	ldi	r31, 0x78	; 120
    1a14:	ef 2e       	mov	r14, r31
    1a16:	f6 e0       	ldi	r31, 0x06	; 6
    1a18:	ff 2e       	mov	r15, r31
    1a1a:	f0 2d       	mov	r31, r0
    1a1c:	00 e0       	ldi	r16, 0x00	; 0
    1a1e:	20 e0       	ldi	r18, 0x00	; 0
    1a20:	30 e0       	ldi	r19, 0x00	; 0
    1a22:	45 e5       	ldi	r20, 0x55	; 85
    1a24:	50 e0       	ldi	r21, 0x00	; 0
    1a26:	6c e7       	ldi	r22, 0x7C	; 124
    1a28:	70 e0       	ldi	r23, 0x00	; 0
    1a2a:	8e e1       	ldi	r24, 0x1E	; 30
    1a2c:	9b e0       	ldi	r25, 0x0B	; 11
    1a2e:	0e 94 a2 0b 	call	0x1744	; 0x1744 <xTaskCreate>
    1a32:	81 30       	cpi	r24, 0x01	; 1
    1a34:	81 f4       	brne	.+32     	; 0x1a56 <vTaskStartScheduler+0x4c>
    1a36:	f8 94       	cli
    1a38:	8f ef       	ldi	r24, 0xFF	; 255
    1a3a:	9f ef       	ldi	r25, 0xFF	; 255
    1a3c:	90 93 7b 06 	sts	0x067B, r25	; 0x80067b <xNextTaskUnblockTime+0x1>
    1a40:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <xNextTaskUnblockTime>
    1a44:	81 e0       	ldi	r24, 0x01	; 1
    1a46:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <xSchedulerRunning>
    1a4a:	10 92 83 06 	sts	0x0683, r1	; 0x800683 <xTickCount+0x1>
    1a4e:	10 92 82 06 	sts	0x0682, r1	; 0x800682 <xTickCount>
    1a52:	0e 94 86 07 	call	0xf0c	; 0xf0c <xPortStartScheduler>
    1a56:	0f 91       	pop	r16
    1a58:	ff 90       	pop	r15
    1a5a:	ef 90       	pop	r14
    1a5c:	08 95       	ret

00001a5e <vTaskSuspendAll>:
    1a5e:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <uxSchedulerSuspended>
    1a62:	8f 5f       	subi	r24, 0xFF	; 255
    1a64:	80 93 77 06 	sts	0x0677, r24	; 0x800677 <uxSchedulerSuspended>
    1a68:	08 95       	ret

00001a6a <xTaskGetTickCount>:
    1a6a:	0f b6       	in	r0, 0x3f	; 63
    1a6c:	f8 94       	cli
    1a6e:	0f 92       	push	r0
    1a70:	80 91 82 06 	lds	r24, 0x0682	; 0x800682 <xTickCount>
    1a74:	90 91 83 06 	lds	r25, 0x0683	; 0x800683 <xTickCount+0x1>
    1a78:	0f 90       	pop	r0
    1a7a:	0f be       	out	0x3f, r0	; 63
    1a7c:	08 95       	ret

00001a7e <xTaskIncrementTick>:
    1a7e:	cf 92       	push	r12
    1a80:	df 92       	push	r13
    1a82:	ef 92       	push	r14
    1a84:	ff 92       	push	r15
    1a86:	0f 93       	push	r16
    1a88:	1f 93       	push	r17
    1a8a:	cf 93       	push	r28
    1a8c:	df 93       	push	r29
    1a8e:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <uxSchedulerSuspended>
    1a92:	81 11       	cpse	r24, r1
    1a94:	99 c0       	rjmp	.+306    	; 0x1bc8 <xTaskIncrementTick+0x14a>
    1a96:	e0 90 82 06 	lds	r14, 0x0682	; 0x800682 <xTickCount>
    1a9a:	f0 90 83 06 	lds	r15, 0x0683	; 0x800683 <xTickCount+0x1>
    1a9e:	8f ef       	ldi	r24, 0xFF	; 255
    1aa0:	e8 1a       	sub	r14, r24
    1aa2:	f8 0a       	sbc	r15, r24
    1aa4:	f0 92 83 06 	sts	0x0683, r15	; 0x800683 <xTickCount+0x1>
    1aa8:	e0 92 82 06 	sts	0x0682, r14	; 0x800682 <xTickCount>
    1aac:	e1 14       	cp	r14, r1
    1aae:	f1 04       	cpc	r15, r1
    1ab0:	b9 f4       	brne	.+46     	; 0x1ae0 <xTaskIncrementTick+0x62>
    1ab2:	80 91 a3 06 	lds	r24, 0x06A3	; 0x8006a3 <pxDelayedTaskList>
    1ab6:	90 91 a4 06 	lds	r25, 0x06A4	; 0x8006a4 <pxDelayedTaskList+0x1>
    1aba:	20 91 a1 06 	lds	r18, 0x06A1	; 0x8006a1 <pxOverflowDelayedTaskList>
    1abe:	30 91 a2 06 	lds	r19, 0x06A2	; 0x8006a2 <pxOverflowDelayedTaskList+0x1>
    1ac2:	30 93 a4 06 	sts	0x06A4, r19	; 0x8006a4 <pxDelayedTaskList+0x1>
    1ac6:	20 93 a3 06 	sts	0x06A3, r18	; 0x8006a3 <pxDelayedTaskList>
    1aca:	90 93 a2 06 	sts	0x06A2, r25	; 0x8006a2 <pxOverflowDelayedTaskList+0x1>
    1ace:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <pxOverflowDelayedTaskList>
    1ad2:	80 91 7d 06 	lds	r24, 0x067D	; 0x80067d <xNumOfOverflows>
    1ad6:	8f 5f       	subi	r24, 0xFF	; 255
    1ad8:	80 93 7d 06 	sts	0x067D, r24	; 0x80067d <xNumOfOverflows>
    1adc:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <prvResetNextTaskUnblockTime>
    1ae0:	80 91 7a 06 	lds	r24, 0x067A	; 0x80067a <xNextTaskUnblockTime>
    1ae4:	90 91 7b 06 	lds	r25, 0x067B	; 0x80067b <xNextTaskUnblockTime+0x1>
    1ae8:	e8 16       	cp	r14, r24
    1aea:	f9 06       	cpc	r15, r25
    1aec:	10 f4       	brcc	.+4      	; 0x1af2 <xTaskIncrementTick+0x74>
    1aee:	d1 2c       	mov	r13, r1
    1af0:	53 c0       	rjmp	.+166    	; 0x1b98 <xTaskIncrementTick+0x11a>
    1af2:	d1 2c       	mov	r13, r1
    1af4:	cc 24       	eor	r12, r12
    1af6:	c3 94       	inc	r12
    1af8:	e0 91 a3 06 	lds	r30, 0x06A3	; 0x8006a3 <pxDelayedTaskList>
    1afc:	f0 91 a4 06 	lds	r31, 0x06A4	; 0x8006a4 <pxDelayedTaskList+0x1>
    1b00:	80 81       	ld	r24, Z
    1b02:	81 11       	cpse	r24, r1
    1b04:	07 c0       	rjmp	.+14     	; 0x1b14 <xTaskIncrementTick+0x96>
    1b06:	8f ef       	ldi	r24, 0xFF	; 255
    1b08:	9f ef       	ldi	r25, 0xFF	; 255
    1b0a:	90 93 7b 06 	sts	0x067B, r25	; 0x80067b <xNextTaskUnblockTime+0x1>
    1b0e:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <xNextTaskUnblockTime>
    1b12:	42 c0       	rjmp	.+132    	; 0x1b98 <xTaskIncrementTick+0x11a>
    1b14:	e0 91 a3 06 	lds	r30, 0x06A3	; 0x8006a3 <pxDelayedTaskList>
    1b18:	f0 91 a4 06 	lds	r31, 0x06A4	; 0x8006a4 <pxDelayedTaskList+0x1>
    1b1c:	05 80       	ldd	r0, Z+5	; 0x05
    1b1e:	f6 81       	ldd	r31, Z+6	; 0x06
    1b20:	e0 2d       	mov	r30, r0
    1b22:	c6 81       	ldd	r28, Z+6	; 0x06
    1b24:	d7 81       	ldd	r29, Z+7	; 0x07
    1b26:	8a 81       	ldd	r24, Y+2	; 0x02
    1b28:	9b 81       	ldd	r25, Y+3	; 0x03
    1b2a:	e8 16       	cp	r14, r24
    1b2c:	f9 06       	cpc	r15, r25
    1b2e:	28 f4       	brcc	.+10     	; 0x1b3a <xTaskIncrementTick+0xbc>
    1b30:	90 93 7b 06 	sts	0x067B, r25	; 0x80067b <xNextTaskUnblockTime+0x1>
    1b34:	80 93 7a 06 	sts	0x067A, r24	; 0x80067a <xNextTaskUnblockTime>
    1b38:	2f c0       	rjmp	.+94     	; 0x1b98 <xTaskIncrementTick+0x11a>
    1b3a:	8e 01       	movw	r16, r28
    1b3c:	0e 5f       	subi	r16, 0xFE	; 254
    1b3e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b40:	c8 01       	movw	r24, r16
    1b42:	0e 94 f3 06 	call	0xde6	; 0xde6 <uxListRemove>
    1b46:	8c 89       	ldd	r24, Y+20	; 0x14
    1b48:	9d 89       	ldd	r25, Y+21	; 0x15
    1b4a:	89 2b       	or	r24, r25
    1b4c:	21 f0       	breq	.+8      	; 0x1b56 <xTaskIncrementTick+0xd8>
    1b4e:	ce 01       	movw	r24, r28
    1b50:	0c 96       	adiw	r24, 0x0c	; 12
    1b52:	0e 94 f3 06 	call	0xde6	; 0xde6 <uxListRemove>
    1b56:	8e 89       	ldd	r24, Y+22	; 0x16
    1b58:	90 91 81 06 	lds	r25, 0x0681	; 0x800681 <uxTopReadyPriority>
    1b5c:	98 17       	cp	r25, r24
    1b5e:	10 f4       	brcc	.+4      	; 0x1b64 <xTaskIncrementTick+0xe6>
    1b60:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <uxTopReadyPriority>
    1b64:	90 e0       	ldi	r25, 0x00	; 0
    1b66:	9c 01       	movw	r18, r24
    1b68:	22 0f       	add	r18, r18
    1b6a:	33 1f       	adc	r19, r19
    1b6c:	22 0f       	add	r18, r18
    1b6e:	33 1f       	adc	r19, r19
    1b70:	22 0f       	add	r18, r18
    1b72:	33 1f       	adc	r19, r19
    1b74:	82 0f       	add	r24, r18
    1b76:	93 1f       	adc	r25, r19
    1b78:	b8 01       	movw	r22, r16
    1b7a:	89 54       	subi	r24, 0x49	; 73
    1b7c:	99 4f       	sbci	r25, 0xF9	; 249
    1b7e:	0e 94 a1 06 	call	0xd42	; 0xd42 <vListInsertEnd>
    1b82:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    1b86:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    1b8a:	9e 89       	ldd	r25, Y+22	; 0x16
    1b8c:	86 89       	ldd	r24, Z+22	; 0x16
    1b8e:	98 17       	cp	r25, r24
    1b90:	08 f4       	brcc	.+2      	; 0x1b94 <xTaskIncrementTick+0x116>
    1b92:	b2 cf       	rjmp	.-156    	; 0x1af8 <xTaskIncrementTick+0x7a>
    1b94:	dc 2c       	mov	r13, r12
    1b96:	b0 cf       	rjmp	.-160    	; 0x1af8 <xTaskIncrementTick+0x7a>
    1b98:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    1b9c:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    1ba0:	86 89       	ldd	r24, Z+22	; 0x16
    1ba2:	90 e0       	ldi	r25, 0x00	; 0
    1ba4:	fc 01       	movw	r30, r24
    1ba6:	ee 0f       	add	r30, r30
    1ba8:	ff 1f       	adc	r31, r31
    1baa:	ee 0f       	add	r30, r30
    1bac:	ff 1f       	adc	r31, r31
    1bae:	ee 0f       	add	r30, r30
    1bb0:	ff 1f       	adc	r31, r31
    1bb2:	8e 0f       	add	r24, r30
    1bb4:	9f 1f       	adc	r25, r31
    1bb6:	fc 01       	movw	r30, r24
    1bb8:	e9 54       	subi	r30, 0x49	; 73
    1bba:	f9 4f       	sbci	r31, 0xF9	; 249
    1bbc:	80 81       	ld	r24, Z
    1bbe:	82 30       	cpi	r24, 0x02	; 2
    1bc0:	48 f0       	brcs	.+18     	; 0x1bd4 <xTaskIncrementTick+0x156>
    1bc2:	dd 24       	eor	r13, r13
    1bc4:	d3 94       	inc	r13
    1bc6:	06 c0       	rjmp	.+12     	; 0x1bd4 <xTaskIncrementTick+0x156>
    1bc8:	80 91 7f 06 	lds	r24, 0x067F	; 0x80067f <uxPendedTicks>
    1bcc:	8f 5f       	subi	r24, 0xFF	; 255
    1bce:	80 93 7f 06 	sts	0x067F, r24	; 0x80067f <uxPendedTicks>
    1bd2:	d1 2c       	mov	r13, r1
    1bd4:	80 91 7e 06 	lds	r24, 0x067E	; 0x80067e <xYieldPending>
    1bd8:	88 23       	and	r24, r24
    1bda:	11 f0       	breq	.+4      	; 0x1be0 <xTaskIncrementTick+0x162>
    1bdc:	dd 24       	eor	r13, r13
    1bde:	d3 94       	inc	r13
    1be0:	8d 2d       	mov	r24, r13
    1be2:	df 91       	pop	r29
    1be4:	cf 91       	pop	r28
    1be6:	1f 91       	pop	r17
    1be8:	0f 91       	pop	r16
    1bea:	ff 90       	pop	r15
    1bec:	ef 90       	pop	r14
    1bee:	df 90       	pop	r13
    1bf0:	cf 90       	pop	r12
    1bf2:	08 95       	ret

00001bf4 <xTaskResumeAll>:
    1bf4:	df 92       	push	r13
    1bf6:	ef 92       	push	r14
    1bf8:	ff 92       	push	r15
    1bfa:	0f 93       	push	r16
    1bfc:	1f 93       	push	r17
    1bfe:	cf 93       	push	r28
    1c00:	df 93       	push	r29
    1c02:	0f b6       	in	r0, 0x3f	; 63
    1c04:	f8 94       	cli
    1c06:	0f 92       	push	r0
    1c08:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <uxSchedulerSuspended>
    1c0c:	81 50       	subi	r24, 0x01	; 1
    1c0e:	80 93 77 06 	sts	0x0677, r24	; 0x800677 <uxSchedulerSuspended>
    1c12:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <uxSchedulerSuspended>
    1c16:	81 11       	cpse	r24, r1
    1c18:	5f c0       	rjmp	.+190    	; 0x1cd8 <xTaskResumeAll+0xe4>
    1c1a:	80 91 84 06 	lds	r24, 0x0684	; 0x800684 <uxCurrentNumberOfTasks>
    1c1e:	81 11       	cpse	r24, r1
    1c20:	33 c0       	rjmp	.+102    	; 0x1c88 <xTaskResumeAll+0x94>
    1c22:	5d c0       	rjmp	.+186    	; 0x1cde <xTaskResumeAll+0xea>
    1c24:	d7 01       	movw	r26, r14
    1c26:	15 96       	adiw	r26, 0x05	; 5
    1c28:	ed 91       	ld	r30, X+
    1c2a:	fc 91       	ld	r31, X
    1c2c:	16 97       	sbiw	r26, 0x06	; 6
    1c2e:	c6 81       	ldd	r28, Z+6	; 0x06
    1c30:	d7 81       	ldd	r29, Z+7	; 0x07
    1c32:	ce 01       	movw	r24, r28
    1c34:	0c 96       	adiw	r24, 0x0c	; 12
    1c36:	0e 94 f3 06 	call	0xde6	; 0xde6 <uxListRemove>
    1c3a:	8e 01       	movw	r16, r28
    1c3c:	0e 5f       	subi	r16, 0xFE	; 254
    1c3e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c40:	c8 01       	movw	r24, r16
    1c42:	0e 94 f3 06 	call	0xde6	; 0xde6 <uxListRemove>
    1c46:	8e 89       	ldd	r24, Y+22	; 0x16
    1c48:	90 91 81 06 	lds	r25, 0x0681	; 0x800681 <uxTopReadyPriority>
    1c4c:	98 17       	cp	r25, r24
    1c4e:	10 f4       	brcc	.+4      	; 0x1c54 <xTaskResumeAll+0x60>
    1c50:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <uxTopReadyPriority>
    1c54:	90 e0       	ldi	r25, 0x00	; 0
    1c56:	9c 01       	movw	r18, r24
    1c58:	22 0f       	add	r18, r18
    1c5a:	33 1f       	adc	r19, r19
    1c5c:	22 0f       	add	r18, r18
    1c5e:	33 1f       	adc	r19, r19
    1c60:	22 0f       	add	r18, r18
    1c62:	33 1f       	adc	r19, r19
    1c64:	82 0f       	add	r24, r18
    1c66:	93 1f       	adc	r25, r19
    1c68:	b8 01       	movw	r22, r16
    1c6a:	89 54       	subi	r24, 0x49	; 73
    1c6c:	99 4f       	sbci	r25, 0xF9	; 249
    1c6e:	0e 94 a1 06 	call	0xd42	; 0xd42 <vListInsertEnd>
    1c72:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    1c76:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    1c7a:	9e 89       	ldd	r25, Y+22	; 0x16
    1c7c:	86 89       	ldd	r24, Z+22	; 0x16
    1c7e:	98 17       	cp	r25, r24
    1c80:	68 f0       	brcs	.+26     	; 0x1c9c <xTaskResumeAll+0xa8>
    1c82:	d0 92 7e 06 	sts	0x067E, r13	; 0x80067e <xYieldPending>
    1c86:	0a c0       	rjmp	.+20     	; 0x1c9c <xTaskResumeAll+0xa8>
    1c88:	c0 e0       	ldi	r28, 0x00	; 0
    1c8a:	d0 e0       	ldi	r29, 0x00	; 0
    1c8c:	0f 2e       	mov	r0, r31
    1c8e:	f8 e9       	ldi	r31, 0x98	; 152
    1c90:	ef 2e       	mov	r14, r31
    1c92:	f6 e0       	ldi	r31, 0x06	; 6
    1c94:	ff 2e       	mov	r15, r31
    1c96:	f0 2d       	mov	r31, r0
    1c98:	dd 24       	eor	r13, r13
    1c9a:	d3 94       	inc	r13
    1c9c:	f7 01       	movw	r30, r14
    1c9e:	80 81       	ld	r24, Z
    1ca0:	81 11       	cpse	r24, r1
    1ca2:	c0 cf       	rjmp	.-128    	; 0x1c24 <xTaskResumeAll+0x30>
    1ca4:	cd 2b       	or	r28, r29
    1ca6:	11 f0       	breq	.+4      	; 0x1cac <xTaskResumeAll+0xb8>
    1ca8:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <prvResetNextTaskUnblockTime>
    1cac:	c0 91 7f 06 	lds	r28, 0x067F	; 0x80067f <uxPendedTicks>
    1cb0:	cc 23       	and	r28, r28
    1cb2:	51 f0       	breq	.+20     	; 0x1cc8 <xTaskResumeAll+0xd4>
    1cb4:	d1 e0       	ldi	r29, 0x01	; 1
    1cb6:	0e 94 3f 0d 	call	0x1a7e	; 0x1a7e <xTaskIncrementTick>
    1cba:	81 11       	cpse	r24, r1
    1cbc:	d0 93 7e 06 	sts	0x067E, r29	; 0x80067e <xYieldPending>
    1cc0:	c1 50       	subi	r28, 0x01	; 1
    1cc2:	c9 f7       	brne	.-14     	; 0x1cb6 <xTaskResumeAll+0xc2>
    1cc4:	10 92 7f 06 	sts	0x067F, r1	; 0x80067f <uxPendedTicks>
    1cc8:	80 91 7e 06 	lds	r24, 0x067E	; 0x80067e <xYieldPending>
    1ccc:	88 23       	and	r24, r24
    1cce:	31 f0       	breq	.+12     	; 0x1cdc <xTaskResumeAll+0xe8>
    1cd0:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	03 c0       	rjmp	.+6      	; 0x1cde <xTaskResumeAll+0xea>
    1cd8:	80 e0       	ldi	r24, 0x00	; 0
    1cda:	01 c0       	rjmp	.+2      	; 0x1cde <xTaskResumeAll+0xea>
    1cdc:	80 e0       	ldi	r24, 0x00	; 0
    1cde:	0f 90       	pop	r0
    1ce0:	0f be       	out	0x3f, r0	; 63
    1ce2:	df 91       	pop	r29
    1ce4:	cf 91       	pop	r28
    1ce6:	1f 91       	pop	r17
    1ce8:	0f 91       	pop	r16
    1cea:	ff 90       	pop	r15
    1cec:	ef 90       	pop	r14
    1cee:	df 90       	pop	r13
    1cf0:	08 95       	ret

00001cf2 <vTaskDelayUntil>:
    1cf2:	0f 93       	push	r16
    1cf4:	1f 93       	push	r17
    1cf6:	cf 93       	push	r28
    1cf8:	df 93       	push	r29
    1cfa:	8c 01       	movw	r16, r24
    1cfc:	eb 01       	movw	r28, r22
    1cfe:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <vTaskSuspendAll>
    1d02:	40 91 82 06 	lds	r20, 0x0682	; 0x800682 <xTickCount>
    1d06:	50 91 83 06 	lds	r21, 0x0683	; 0x800683 <xTickCount+0x1>
    1d0a:	f8 01       	movw	r30, r16
    1d0c:	20 81       	ld	r18, Z
    1d0e:	31 81       	ldd	r19, Z+1	; 0x01
    1d10:	c9 01       	movw	r24, r18
    1d12:	8c 0f       	add	r24, r28
    1d14:	9d 1f       	adc	r25, r29
    1d16:	42 17       	cp	r20, r18
    1d18:	53 07       	cpc	r21, r19
    1d1a:	48 f4       	brcc	.+18     	; 0x1d2e <vTaskDelayUntil+0x3c>
    1d1c:	82 17       	cp	r24, r18
    1d1e:	93 07       	cpc	r25, r19
    1d20:	e8 f4       	brcc	.+58     	; 0x1d5c <vTaskDelayUntil+0x6a>
    1d22:	91 83       	std	Z+1, r25	; 0x01
    1d24:	80 83       	st	Z, r24
    1d26:	48 17       	cp	r20, r24
    1d28:	59 07       	cpc	r21, r25
    1d2a:	68 f4       	brcc	.+26     	; 0x1d46 <vTaskDelayUntil+0x54>
    1d2c:	07 c0       	rjmp	.+14     	; 0x1d3c <vTaskDelayUntil+0x4a>
    1d2e:	82 17       	cp	r24, r18
    1d30:	93 07       	cpc	r25, r19
    1d32:	80 f0       	brcs	.+32     	; 0x1d54 <vTaskDelayUntil+0x62>
    1d34:	48 17       	cp	r20, r24
    1d36:	59 07       	cpc	r21, r25
    1d38:	68 f0       	brcs	.+26     	; 0x1d54 <vTaskDelayUntil+0x62>
    1d3a:	10 c0       	rjmp	.+32     	; 0x1d5c <vTaskDelayUntil+0x6a>
    1d3c:	60 e0       	ldi	r22, 0x00	; 0
    1d3e:	84 1b       	sub	r24, r20
    1d40:	95 0b       	sbc	r25, r21
    1d42:	0e 94 4a 0b 	call	0x1694	; 0x1694 <prvAddCurrentTaskToDelayedList>
    1d46:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <xTaskResumeAll>
    1d4a:	81 11       	cpse	r24, r1
    1d4c:	0b c0       	rjmp	.+22     	; 0x1d64 <vTaskDelayUntil+0x72>
    1d4e:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    1d52:	08 c0       	rjmp	.+16     	; 0x1d64 <vTaskDelayUntil+0x72>
    1d54:	f8 01       	movw	r30, r16
    1d56:	91 83       	std	Z+1, r25	; 0x01
    1d58:	80 83       	st	Z, r24
    1d5a:	f0 cf       	rjmp	.-32     	; 0x1d3c <vTaskDelayUntil+0x4a>
    1d5c:	f8 01       	movw	r30, r16
    1d5e:	91 83       	std	Z+1, r25	; 0x01
    1d60:	80 83       	st	Z, r24
    1d62:	f1 cf       	rjmp	.-30     	; 0x1d46 <vTaskDelayUntil+0x54>
    1d64:	df 91       	pop	r29
    1d66:	cf 91       	pop	r28
    1d68:	1f 91       	pop	r17
    1d6a:	0f 91       	pop	r16
    1d6c:	08 95       	ret

00001d6e <vTaskDelay>:
    1d6e:	cf 93       	push	r28
    1d70:	df 93       	push	r29
    1d72:	ec 01       	movw	r28, r24
    1d74:	89 2b       	or	r24, r25
    1d76:	51 f0       	breq	.+20     	; 0x1d8c <vTaskDelay+0x1e>
    1d78:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <vTaskSuspendAll>
    1d7c:	60 e0       	ldi	r22, 0x00	; 0
    1d7e:	ce 01       	movw	r24, r28
    1d80:	0e 94 4a 0b 	call	0x1694	; 0x1694 <prvAddCurrentTaskToDelayedList>
    1d84:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <xTaskResumeAll>
    1d88:	81 11       	cpse	r24, r1
    1d8a:	02 c0       	rjmp	.+4      	; 0x1d90 <vTaskDelay+0x22>
    1d8c:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    1d90:	df 91       	pop	r29
    1d92:	cf 91       	pop	r28
    1d94:	08 95       	ret

00001d96 <vTaskSwitchContext>:
    1d96:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <uxSchedulerSuspended>
    1d9a:	88 23       	and	r24, r24
    1d9c:	21 f0       	breq	.+8      	; 0x1da6 <vTaskSwitchContext+0x10>
    1d9e:	81 e0       	ldi	r24, 0x01	; 1
    1da0:	80 93 7e 06 	sts	0x067E, r24	; 0x80067e <xYieldPending>
    1da4:	08 95       	ret
    1da6:	10 92 7e 06 	sts	0x067E, r1	; 0x80067e <xYieldPending>
    1daa:	20 91 81 06 	lds	r18, 0x0681	; 0x800681 <uxTopReadyPriority>
    1dae:	82 2f       	mov	r24, r18
    1db0:	90 e0       	ldi	r25, 0x00	; 0
    1db2:	fc 01       	movw	r30, r24
    1db4:	ee 0f       	add	r30, r30
    1db6:	ff 1f       	adc	r31, r31
    1db8:	ee 0f       	add	r30, r30
    1dba:	ff 1f       	adc	r31, r31
    1dbc:	ee 0f       	add	r30, r30
    1dbe:	ff 1f       	adc	r31, r31
    1dc0:	e8 0f       	add	r30, r24
    1dc2:	f9 1f       	adc	r31, r25
    1dc4:	e9 54       	subi	r30, 0x49	; 73
    1dc6:	f9 4f       	sbci	r31, 0xF9	; 249
    1dc8:	30 81       	ld	r19, Z
    1dca:	31 11       	cpse	r19, r1
    1dcc:	11 c0       	rjmp	.+34     	; 0x1df0 <vTaskSwitchContext+0x5a>
    1dce:	21 50       	subi	r18, 0x01	; 1
    1dd0:	82 2f       	mov	r24, r18
    1dd2:	90 e0       	ldi	r25, 0x00	; 0
    1dd4:	fc 01       	movw	r30, r24
    1dd6:	ee 0f       	add	r30, r30
    1dd8:	ff 1f       	adc	r31, r31
    1dda:	ee 0f       	add	r30, r30
    1ddc:	ff 1f       	adc	r31, r31
    1dde:	ee 0f       	add	r30, r30
    1de0:	ff 1f       	adc	r31, r31
    1de2:	e8 0f       	add	r30, r24
    1de4:	f9 1f       	adc	r31, r25
    1de6:	e9 54       	subi	r30, 0x49	; 73
    1de8:	f9 4f       	sbci	r31, 0xF9	; 249
    1dea:	30 81       	ld	r19, Z
    1dec:	33 23       	and	r19, r19
    1dee:	79 f3       	breq	.-34     	; 0x1dce <vTaskSwitchContext+0x38>
    1df0:	ac 01       	movw	r20, r24
    1df2:	44 0f       	add	r20, r20
    1df4:	55 1f       	adc	r21, r21
    1df6:	44 0f       	add	r20, r20
    1df8:	55 1f       	adc	r21, r21
    1dfa:	44 0f       	add	r20, r20
    1dfc:	55 1f       	adc	r21, r21
    1dfe:	48 0f       	add	r20, r24
    1e00:	59 1f       	adc	r21, r25
    1e02:	da 01       	movw	r26, r20
    1e04:	a9 54       	subi	r26, 0x49	; 73
    1e06:	b9 4f       	sbci	r27, 0xF9	; 249
    1e08:	11 96       	adiw	r26, 0x01	; 1
    1e0a:	ed 91       	ld	r30, X+
    1e0c:	fc 91       	ld	r31, X
    1e0e:	12 97       	sbiw	r26, 0x02	; 2
    1e10:	02 80       	ldd	r0, Z+2	; 0x02
    1e12:	f3 81       	ldd	r31, Z+3	; 0x03
    1e14:	e0 2d       	mov	r30, r0
    1e16:	12 96       	adiw	r26, 0x02	; 2
    1e18:	fc 93       	st	X, r31
    1e1a:	ee 93       	st	-X, r30
    1e1c:	11 97       	sbiw	r26, 0x01	; 1
    1e1e:	46 54       	subi	r20, 0x46	; 70
    1e20:	59 4f       	sbci	r21, 0xF9	; 249
    1e22:	e4 17       	cp	r30, r20
    1e24:	f5 07       	cpc	r31, r21
    1e26:	29 f4       	brne	.+10     	; 0x1e32 <vTaskSwitchContext+0x9c>
    1e28:	42 81       	ldd	r20, Z+2	; 0x02
    1e2a:	53 81       	ldd	r21, Z+3	; 0x03
    1e2c:	fd 01       	movw	r30, r26
    1e2e:	52 83       	std	Z+2, r21	; 0x02
    1e30:	41 83       	std	Z+1, r20	; 0x01
    1e32:	fc 01       	movw	r30, r24
    1e34:	ee 0f       	add	r30, r30
    1e36:	ff 1f       	adc	r31, r31
    1e38:	ee 0f       	add	r30, r30
    1e3a:	ff 1f       	adc	r31, r31
    1e3c:	ee 0f       	add	r30, r30
    1e3e:	ff 1f       	adc	r31, r31
    1e40:	8e 0f       	add	r24, r30
    1e42:	9f 1f       	adc	r25, r31
    1e44:	fc 01       	movw	r30, r24
    1e46:	e9 54       	subi	r30, 0x49	; 73
    1e48:	f9 4f       	sbci	r31, 0xF9	; 249
    1e4a:	01 80       	ldd	r0, Z+1	; 0x01
    1e4c:	f2 81       	ldd	r31, Z+2	; 0x02
    1e4e:	e0 2d       	mov	r30, r0
    1e50:	86 81       	ldd	r24, Z+6	; 0x06
    1e52:	97 81       	ldd	r25, Z+7	; 0x07
    1e54:	90 93 e5 06 	sts	0x06E5, r25	; 0x8006e5 <pxCurrentTCB+0x1>
    1e58:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <pxCurrentTCB>
    1e5c:	20 93 81 06 	sts	0x0681, r18	; 0x800681 <uxTopReadyPriority>
    1e60:	08 95       	ret

00001e62 <vTaskSuspend>:
    1e62:	0f 93       	push	r16
    1e64:	1f 93       	push	r17
    1e66:	cf 93       	push	r28
    1e68:	df 93       	push	r29
    1e6a:	ec 01       	movw	r28, r24
    1e6c:	0f b6       	in	r0, 0x3f	; 63
    1e6e:	f8 94       	cli
    1e70:	0f 92       	push	r0
    1e72:	89 2b       	or	r24, r25
    1e74:	21 f4       	brne	.+8      	; 0x1e7e <vTaskSuspend+0x1c>
    1e76:	c0 91 e4 06 	lds	r28, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    1e7a:	d0 91 e5 06 	lds	r29, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    1e7e:	8e 01       	movw	r16, r28
    1e80:	0e 5f       	subi	r16, 0xFE	; 254
    1e82:	1f 4f       	sbci	r17, 0xFF	; 255
    1e84:	c8 01       	movw	r24, r16
    1e86:	0e 94 f3 06 	call	0xde6	; 0xde6 <uxListRemove>
    1e8a:	8c 89       	ldd	r24, Y+20	; 0x14
    1e8c:	9d 89       	ldd	r25, Y+21	; 0x15
    1e8e:	89 2b       	or	r24, r25
    1e90:	21 f0       	breq	.+8      	; 0x1e9a <vTaskSuspend+0x38>
    1e92:	ce 01       	movw	r24, r28
    1e94:	0c 96       	adiw	r24, 0x0c	; 12
    1e96:	0e 94 f3 06 	call	0xde6	; 0xde6 <uxListRemove>
    1e9a:	b8 01       	movw	r22, r16
    1e9c:	85 e8       	ldi	r24, 0x85	; 133
    1e9e:	96 e0       	ldi	r25, 0x06	; 6
    1ea0:	0e 94 a1 06 	call	0xd42	; 0xd42 <vListInsertEnd>
    1ea4:	8d a1       	ldd	r24, Y+37	; 0x25
    1ea6:	81 30       	cpi	r24, 0x01	; 1
    1ea8:	09 f4       	brne	.+2      	; 0x1eac <vTaskSuspend+0x4a>
    1eaa:	1d a2       	std	Y+37, r1	; 0x25
    1eac:	0f 90       	pop	r0
    1eae:	0f be       	out	0x3f, r0	; 63
    1eb0:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <xSchedulerRunning>
    1eb4:	88 23       	and	r24, r24
    1eb6:	39 f0       	breq	.+14     	; 0x1ec6 <vTaskSuspend+0x64>
    1eb8:	0f b6       	in	r0, 0x3f	; 63
    1eba:	f8 94       	cli
    1ebc:	0f 92       	push	r0
    1ebe:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <prvResetNextTaskUnblockTime>
    1ec2:	0f 90       	pop	r0
    1ec4:	0f be       	out	0x3f, r0	; 63
    1ec6:	80 91 e4 06 	lds	r24, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    1eca:	90 91 e5 06 	lds	r25, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    1ece:	c8 17       	cp	r28, r24
    1ed0:	d9 07       	cpc	r29, r25
    1ed2:	a1 f4       	brne	.+40     	; 0x1efc <vTaskSuspend+0x9a>
    1ed4:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <xSchedulerRunning>
    1ed8:	88 23       	and	r24, r24
    1eda:	19 f0       	breq	.+6      	; 0x1ee2 <vTaskSuspend+0x80>
    1edc:	0e 94 bb 07 	call	0xf76	; 0xf76 <vPortYield>
    1ee0:	0d c0       	rjmp	.+26     	; 0x1efc <vTaskSuspend+0x9a>
    1ee2:	90 91 85 06 	lds	r25, 0x0685	; 0x800685 <xSuspendedTaskList>
    1ee6:	80 91 84 06 	lds	r24, 0x0684	; 0x800684 <uxCurrentNumberOfTasks>
    1eea:	98 13       	cpse	r25, r24
    1eec:	05 c0       	rjmp	.+10     	; 0x1ef8 <vTaskSuspend+0x96>
    1eee:	10 92 e5 06 	sts	0x06E5, r1	; 0x8006e5 <pxCurrentTCB+0x1>
    1ef2:	10 92 e4 06 	sts	0x06E4, r1	; 0x8006e4 <pxCurrentTCB>
    1ef6:	02 c0       	rjmp	.+4      	; 0x1efc <vTaskSuspend+0x9a>
    1ef8:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <vTaskSwitchContext>
    1efc:	df 91       	pop	r29
    1efe:	cf 91       	pop	r28
    1f00:	1f 91       	pop	r17
    1f02:	0f 91       	pop	r16
    1f04:	08 95       	ret

00001f06 <vTaskPlaceOnEventList>:
    1f06:	cf 93       	push	r28
    1f08:	df 93       	push	r29
    1f0a:	eb 01       	movw	r28, r22
    1f0c:	60 91 e4 06 	lds	r22, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    1f10:	70 91 e5 06 	lds	r23, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    1f14:	64 5f       	subi	r22, 0xF4	; 244
    1f16:	7f 4f       	sbci	r23, 0xFF	; 255
    1f18:	0e 94 c2 06 	call	0xd84	; 0xd84 <vListInsert>
    1f1c:	61 e0       	ldi	r22, 0x01	; 1
    1f1e:	ce 01       	movw	r24, r28
    1f20:	0e 94 4a 0b 	call	0x1694	; 0x1694 <prvAddCurrentTaskToDelayedList>
    1f24:	df 91       	pop	r29
    1f26:	cf 91       	pop	r28
    1f28:	08 95       	ret

00001f2a <xTaskRemoveFromEventList>:
    1f2a:	0f 93       	push	r16
    1f2c:	1f 93       	push	r17
    1f2e:	cf 93       	push	r28
    1f30:	df 93       	push	r29
    1f32:	dc 01       	movw	r26, r24
    1f34:	15 96       	adiw	r26, 0x05	; 5
    1f36:	ed 91       	ld	r30, X+
    1f38:	fc 91       	ld	r31, X
    1f3a:	16 97       	sbiw	r26, 0x06	; 6
    1f3c:	c6 81       	ldd	r28, Z+6	; 0x06
    1f3e:	d7 81       	ldd	r29, Z+7	; 0x07
    1f40:	8e 01       	movw	r16, r28
    1f42:	04 5f       	subi	r16, 0xF4	; 244
    1f44:	1f 4f       	sbci	r17, 0xFF	; 255
    1f46:	c8 01       	movw	r24, r16
    1f48:	0e 94 f3 06 	call	0xde6	; 0xde6 <uxListRemove>
    1f4c:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <uxSchedulerSuspended>
    1f50:	81 11       	cpse	r24, r1
    1f52:	1c c0       	rjmp	.+56     	; 0x1f8c <xTaskRemoveFromEventList+0x62>
    1f54:	0a 50       	subi	r16, 0x0A	; 10
    1f56:	11 09       	sbc	r17, r1
    1f58:	c8 01       	movw	r24, r16
    1f5a:	0e 94 f3 06 	call	0xde6	; 0xde6 <uxListRemove>
    1f5e:	8e 89       	ldd	r24, Y+22	; 0x16
    1f60:	90 91 81 06 	lds	r25, 0x0681	; 0x800681 <uxTopReadyPriority>
    1f64:	98 17       	cp	r25, r24
    1f66:	10 f4       	brcc	.+4      	; 0x1f6c <xTaskRemoveFromEventList+0x42>
    1f68:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <uxTopReadyPriority>
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	9c 01       	movw	r18, r24
    1f70:	22 0f       	add	r18, r18
    1f72:	33 1f       	adc	r19, r19
    1f74:	22 0f       	add	r18, r18
    1f76:	33 1f       	adc	r19, r19
    1f78:	22 0f       	add	r18, r18
    1f7a:	33 1f       	adc	r19, r19
    1f7c:	82 0f       	add	r24, r18
    1f7e:	93 1f       	adc	r25, r19
    1f80:	b8 01       	movw	r22, r16
    1f82:	89 54       	subi	r24, 0x49	; 73
    1f84:	99 4f       	sbci	r25, 0xF9	; 249
    1f86:	0e 94 a1 06 	call	0xd42	; 0xd42 <vListInsertEnd>
    1f8a:	05 c0       	rjmp	.+10     	; 0x1f96 <xTaskRemoveFromEventList+0x6c>
    1f8c:	b8 01       	movw	r22, r16
    1f8e:	88 e9       	ldi	r24, 0x98	; 152
    1f90:	96 e0       	ldi	r25, 0x06	; 6
    1f92:	0e 94 a1 06 	call	0xd42	; 0xd42 <vListInsertEnd>
    1f96:	e0 91 e4 06 	lds	r30, 0x06E4	; 0x8006e4 <pxCurrentTCB>
    1f9a:	f0 91 e5 06 	lds	r31, 0x06E5	; 0x8006e5 <pxCurrentTCB+0x1>
    1f9e:	9e 89       	ldd	r25, Y+22	; 0x16
    1fa0:	86 89       	ldd	r24, Z+22	; 0x16
    1fa2:	89 17       	cp	r24, r25
    1fa4:	20 f4       	brcc	.+8      	; 0x1fae <xTaskRemoveFromEventList+0x84>
    1fa6:	81 e0       	ldi	r24, 0x01	; 1
    1fa8:	80 93 7e 06 	sts	0x067E, r24	; 0x80067e <xYieldPending>
    1fac:	01 c0       	rjmp	.+2      	; 0x1fb0 <xTaskRemoveFromEventList+0x86>
    1fae:	80 e0       	ldi	r24, 0x00	; 0
    1fb0:	df 91       	pop	r29
    1fb2:	cf 91       	pop	r28
    1fb4:	1f 91       	pop	r17
    1fb6:	0f 91       	pop	r16
    1fb8:	08 95       	ret

00001fba <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1fba:	20 91 7d 06 	lds	r18, 0x067D	; 0x80067d <xNumOfOverflows>
    1fbe:	fc 01       	movw	r30, r24
    1fc0:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1fc2:	20 91 82 06 	lds	r18, 0x0682	; 0x800682 <xTickCount>
    1fc6:	30 91 83 06 	lds	r19, 0x0683	; 0x800683 <xTickCount+0x1>
    1fca:	32 83       	std	Z+2, r19	; 0x02
    1fcc:	21 83       	std	Z+1, r18	; 0x01
    1fce:	08 95       	ret

00001fd0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1fd0:	cf 93       	push	r28
    1fd2:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1fd4:	0f b6       	in	r0, 0x3f	; 63
    1fd6:	f8 94       	cli
    1fd8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1fda:	20 91 82 06 	lds	r18, 0x0682	; 0x800682 <xTickCount>
    1fde:	30 91 83 06 	lds	r19, 0x0683	; 0x800683 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    1fe2:	db 01       	movw	r26, r22
    1fe4:	4d 91       	ld	r20, X+
    1fe6:	5c 91       	ld	r21, X
    1fe8:	4f 3f       	cpi	r20, 0xFF	; 255
    1fea:	bf ef       	ldi	r27, 0xFF	; 255
    1fec:	5b 07       	cpc	r21, r27
    1fee:	f1 f0       	breq	.+60     	; 0x202c <xTaskCheckForTimeOut+0x5c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1ff0:	ec 01       	movw	r28, r24
    1ff2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ff4:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1ff6:	a0 91 7d 06 	lds	r26, 0x067D	; 0x80067d <xNumOfOverflows>
    1ffa:	b8 81       	ld	r27, Y
    1ffc:	ba 17       	cp	r27, r26
    1ffe:	19 f0       	breq	.+6      	; 0x2006 <xTaskCheckForTimeOut+0x36>
    2000:	2e 17       	cp	r18, r30
    2002:	3f 07       	cpc	r19, r31
    2004:	a8 f4       	brcc	.+42     	; 0x2030 <xTaskCheckForTimeOut+0x60>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2006:	2e 1b       	sub	r18, r30
    2008:	3f 0b       	sbc	r19, r31
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    200a:	24 17       	cp	r18, r20
    200c:	35 07       	cpc	r19, r21
    200e:	48 f4       	brcc	.+18     	; 0x2022 <xTaskCheckForTimeOut+0x52>
    2010:	fb 01       	movw	r30, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    2012:	42 1b       	sub	r20, r18
    2014:	53 0b       	sbc	r21, r19
    2016:	51 83       	std	Z+1, r21	; 0x01
    2018:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    201a:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    201e:	80 e0       	ldi	r24, 0x00	; 0
    2020:	08 c0       	rjmp	.+16     	; 0x2032 <xTaskCheckForTimeOut+0x62>
		}
		else
		{
			*pxTicksToWait = 0;
    2022:	fb 01       	movw	r30, r22
    2024:	11 82       	std	Z+1, r1	; 0x01
    2026:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    2028:	81 e0       	ldi	r24, 0x01	; 1
    202a:	03 c0       	rjmp	.+6      	; 0x2032 <xTaskCheckForTimeOut+0x62>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    202c:	80 e0       	ldi	r24, 0x00	; 0
    202e:	01 c0       	rjmp	.+2      	; 0x2032 <xTaskCheckForTimeOut+0x62>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2030:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    2032:	0f 90       	pop	r0
    2034:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2036:	df 91       	pop	r29
    2038:	cf 91       	pop	r28
    203a:	08 95       	ret

0000203c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    203c:	81 e0       	ldi	r24, 0x01	; 1
    203e:	80 93 7e 06 	sts	0x067E, r24	; 0x80067e <xYieldPending>
    2042:	08 95       	ret

00002044 <__divsf3>:
    2044:	0e 94 36 10 	call	0x206c	; 0x206c <__divsf3x>
    2048:	0c 94 17 11 	jmp	0x222e	; 0x222e <__fp_round>
    204c:	0e 94 10 11 	call	0x2220	; 0x2220 <__fp_pscB>
    2050:	58 f0       	brcs	.+22     	; 0x2068 <__divsf3+0x24>
    2052:	0e 94 09 11 	call	0x2212	; 0x2212 <__fp_pscA>
    2056:	40 f0       	brcs	.+16     	; 0x2068 <__divsf3+0x24>
    2058:	29 f4       	brne	.+10     	; 0x2064 <__divsf3+0x20>
    205a:	5f 3f       	cpi	r21, 0xFF	; 255
    205c:	29 f0       	breq	.+10     	; 0x2068 <__divsf3+0x24>
    205e:	0c 94 00 11 	jmp	0x2200	; 0x2200 <__fp_inf>
    2062:	51 11       	cpse	r21, r1
    2064:	0c 94 4b 11 	jmp	0x2296	; 0x2296 <__fp_szero>
    2068:	0c 94 06 11 	jmp	0x220c	; 0x220c <__fp_nan>

0000206c <__divsf3x>:
    206c:	0e 94 28 11 	call	0x2250	; 0x2250 <__fp_split3>
    2070:	68 f3       	brcs	.-38     	; 0x204c <__divsf3+0x8>

00002072 <__divsf3_pse>:
    2072:	99 23       	and	r25, r25
    2074:	b1 f3       	breq	.-20     	; 0x2062 <__divsf3+0x1e>
    2076:	55 23       	and	r21, r21
    2078:	91 f3       	breq	.-28     	; 0x205e <__divsf3+0x1a>
    207a:	95 1b       	sub	r25, r21
    207c:	55 0b       	sbc	r21, r21
    207e:	bb 27       	eor	r27, r27
    2080:	aa 27       	eor	r26, r26
    2082:	62 17       	cp	r22, r18
    2084:	73 07       	cpc	r23, r19
    2086:	84 07       	cpc	r24, r20
    2088:	38 f0       	brcs	.+14     	; 0x2098 <__divsf3_pse+0x26>
    208a:	9f 5f       	subi	r25, 0xFF	; 255
    208c:	5f 4f       	sbci	r21, 0xFF	; 255
    208e:	22 0f       	add	r18, r18
    2090:	33 1f       	adc	r19, r19
    2092:	44 1f       	adc	r20, r20
    2094:	aa 1f       	adc	r26, r26
    2096:	a9 f3       	breq	.-22     	; 0x2082 <__divsf3_pse+0x10>
    2098:	35 d0       	rcall	.+106    	; 0x2104 <__divsf3_pse+0x92>
    209a:	0e 2e       	mov	r0, r30
    209c:	3a f0       	brmi	.+14     	; 0x20ac <__divsf3_pse+0x3a>
    209e:	e0 e8       	ldi	r30, 0x80	; 128
    20a0:	32 d0       	rcall	.+100    	; 0x2106 <__divsf3_pse+0x94>
    20a2:	91 50       	subi	r25, 0x01	; 1
    20a4:	50 40       	sbci	r21, 0x00	; 0
    20a6:	e6 95       	lsr	r30
    20a8:	00 1c       	adc	r0, r0
    20aa:	ca f7       	brpl	.-14     	; 0x209e <__divsf3_pse+0x2c>
    20ac:	2b d0       	rcall	.+86     	; 0x2104 <__divsf3_pse+0x92>
    20ae:	fe 2f       	mov	r31, r30
    20b0:	29 d0       	rcall	.+82     	; 0x2104 <__divsf3_pse+0x92>
    20b2:	66 0f       	add	r22, r22
    20b4:	77 1f       	adc	r23, r23
    20b6:	88 1f       	adc	r24, r24
    20b8:	bb 1f       	adc	r27, r27
    20ba:	26 17       	cp	r18, r22
    20bc:	37 07       	cpc	r19, r23
    20be:	48 07       	cpc	r20, r24
    20c0:	ab 07       	cpc	r26, r27
    20c2:	b0 e8       	ldi	r27, 0x80	; 128
    20c4:	09 f0       	breq	.+2      	; 0x20c8 <__divsf3_pse+0x56>
    20c6:	bb 0b       	sbc	r27, r27
    20c8:	80 2d       	mov	r24, r0
    20ca:	bf 01       	movw	r22, r30
    20cc:	ff 27       	eor	r31, r31
    20ce:	93 58       	subi	r25, 0x83	; 131
    20d0:	5f 4f       	sbci	r21, 0xFF	; 255
    20d2:	3a f0       	brmi	.+14     	; 0x20e2 <__divsf3_pse+0x70>
    20d4:	9e 3f       	cpi	r25, 0xFE	; 254
    20d6:	51 05       	cpc	r21, r1
    20d8:	78 f0       	brcs	.+30     	; 0x20f8 <__divsf3_pse+0x86>
    20da:	0c 94 00 11 	jmp	0x2200	; 0x2200 <__fp_inf>
    20de:	0c 94 4b 11 	jmp	0x2296	; 0x2296 <__fp_szero>
    20e2:	5f 3f       	cpi	r21, 0xFF	; 255
    20e4:	e4 f3       	brlt	.-8      	; 0x20de <__divsf3_pse+0x6c>
    20e6:	98 3e       	cpi	r25, 0xE8	; 232
    20e8:	d4 f3       	brlt	.-12     	; 0x20de <__divsf3_pse+0x6c>
    20ea:	86 95       	lsr	r24
    20ec:	77 95       	ror	r23
    20ee:	67 95       	ror	r22
    20f0:	b7 95       	ror	r27
    20f2:	f7 95       	ror	r31
    20f4:	9f 5f       	subi	r25, 0xFF	; 255
    20f6:	c9 f7       	brne	.-14     	; 0x20ea <__divsf3_pse+0x78>
    20f8:	88 0f       	add	r24, r24
    20fa:	91 1d       	adc	r25, r1
    20fc:	96 95       	lsr	r25
    20fe:	87 95       	ror	r24
    2100:	97 f9       	bld	r25, 7
    2102:	08 95       	ret
    2104:	e1 e0       	ldi	r30, 0x01	; 1
    2106:	66 0f       	add	r22, r22
    2108:	77 1f       	adc	r23, r23
    210a:	88 1f       	adc	r24, r24
    210c:	bb 1f       	adc	r27, r27
    210e:	62 17       	cp	r22, r18
    2110:	73 07       	cpc	r23, r19
    2112:	84 07       	cpc	r24, r20
    2114:	ba 07       	cpc	r27, r26
    2116:	20 f0       	brcs	.+8      	; 0x2120 <__divsf3_pse+0xae>
    2118:	62 1b       	sub	r22, r18
    211a:	73 0b       	sbc	r23, r19
    211c:	84 0b       	sbc	r24, r20
    211e:	ba 0b       	sbc	r27, r26
    2120:	ee 1f       	adc	r30, r30
    2122:	88 f7       	brcc	.-30     	; 0x2106 <__divsf3_pse+0x94>
    2124:	e0 95       	com	r30
    2126:	08 95       	ret

00002128 <__fixunssfsi>:
    2128:	0e 94 30 11 	call	0x2260	; 0x2260 <__fp_splitA>
    212c:	88 f0       	brcs	.+34     	; 0x2150 <__fixunssfsi+0x28>
    212e:	9f 57       	subi	r25, 0x7F	; 127
    2130:	98 f0       	brcs	.+38     	; 0x2158 <__fixunssfsi+0x30>
    2132:	b9 2f       	mov	r27, r25
    2134:	99 27       	eor	r25, r25
    2136:	b7 51       	subi	r27, 0x17	; 23
    2138:	b0 f0       	brcs	.+44     	; 0x2166 <__fixunssfsi+0x3e>
    213a:	e1 f0       	breq	.+56     	; 0x2174 <__fixunssfsi+0x4c>
    213c:	66 0f       	add	r22, r22
    213e:	77 1f       	adc	r23, r23
    2140:	88 1f       	adc	r24, r24
    2142:	99 1f       	adc	r25, r25
    2144:	1a f0       	brmi	.+6      	; 0x214c <__fixunssfsi+0x24>
    2146:	ba 95       	dec	r27
    2148:	c9 f7       	brne	.-14     	; 0x213c <__fixunssfsi+0x14>
    214a:	14 c0       	rjmp	.+40     	; 0x2174 <__fixunssfsi+0x4c>
    214c:	b1 30       	cpi	r27, 0x01	; 1
    214e:	91 f0       	breq	.+36     	; 0x2174 <__fixunssfsi+0x4c>
    2150:	0e 94 4a 11 	call	0x2294	; 0x2294 <__fp_zero>
    2154:	b1 e0       	ldi	r27, 0x01	; 1
    2156:	08 95       	ret
    2158:	0c 94 4a 11 	jmp	0x2294	; 0x2294 <__fp_zero>
    215c:	67 2f       	mov	r22, r23
    215e:	78 2f       	mov	r23, r24
    2160:	88 27       	eor	r24, r24
    2162:	b8 5f       	subi	r27, 0xF8	; 248
    2164:	39 f0       	breq	.+14     	; 0x2174 <__fixunssfsi+0x4c>
    2166:	b9 3f       	cpi	r27, 0xF9	; 249
    2168:	cc f3       	brlt	.-14     	; 0x215c <__fixunssfsi+0x34>
    216a:	86 95       	lsr	r24
    216c:	77 95       	ror	r23
    216e:	67 95       	ror	r22
    2170:	b3 95       	inc	r27
    2172:	d9 f7       	brne	.-10     	; 0x216a <__fixunssfsi+0x42>
    2174:	3e f4       	brtc	.+14     	; 0x2184 <__fixunssfsi+0x5c>
    2176:	90 95       	com	r25
    2178:	80 95       	com	r24
    217a:	70 95       	com	r23
    217c:	61 95       	neg	r22
    217e:	7f 4f       	sbci	r23, 0xFF	; 255
    2180:	8f 4f       	sbci	r24, 0xFF	; 255
    2182:	9f 4f       	sbci	r25, 0xFF	; 255
    2184:	08 95       	ret

00002186 <__floatunsisf>:
    2186:	e8 94       	clt
    2188:	09 c0       	rjmp	.+18     	; 0x219c <__floatsisf+0x12>

0000218a <__floatsisf>:
    218a:	97 fb       	bst	r25, 7
    218c:	3e f4       	brtc	.+14     	; 0x219c <__floatsisf+0x12>
    218e:	90 95       	com	r25
    2190:	80 95       	com	r24
    2192:	70 95       	com	r23
    2194:	61 95       	neg	r22
    2196:	7f 4f       	sbci	r23, 0xFF	; 255
    2198:	8f 4f       	sbci	r24, 0xFF	; 255
    219a:	9f 4f       	sbci	r25, 0xFF	; 255
    219c:	99 23       	and	r25, r25
    219e:	a9 f0       	breq	.+42     	; 0x21ca <__floatsisf+0x40>
    21a0:	f9 2f       	mov	r31, r25
    21a2:	96 e9       	ldi	r25, 0x96	; 150
    21a4:	bb 27       	eor	r27, r27
    21a6:	93 95       	inc	r25
    21a8:	f6 95       	lsr	r31
    21aa:	87 95       	ror	r24
    21ac:	77 95       	ror	r23
    21ae:	67 95       	ror	r22
    21b0:	b7 95       	ror	r27
    21b2:	f1 11       	cpse	r31, r1
    21b4:	f8 cf       	rjmp	.-16     	; 0x21a6 <__floatsisf+0x1c>
    21b6:	fa f4       	brpl	.+62     	; 0x21f6 <__floatsisf+0x6c>
    21b8:	bb 0f       	add	r27, r27
    21ba:	11 f4       	brne	.+4      	; 0x21c0 <__floatsisf+0x36>
    21bc:	60 ff       	sbrs	r22, 0
    21be:	1b c0       	rjmp	.+54     	; 0x21f6 <__floatsisf+0x6c>
    21c0:	6f 5f       	subi	r22, 0xFF	; 255
    21c2:	7f 4f       	sbci	r23, 0xFF	; 255
    21c4:	8f 4f       	sbci	r24, 0xFF	; 255
    21c6:	9f 4f       	sbci	r25, 0xFF	; 255
    21c8:	16 c0       	rjmp	.+44     	; 0x21f6 <__floatsisf+0x6c>
    21ca:	88 23       	and	r24, r24
    21cc:	11 f0       	breq	.+4      	; 0x21d2 <__floatsisf+0x48>
    21ce:	96 e9       	ldi	r25, 0x96	; 150
    21d0:	11 c0       	rjmp	.+34     	; 0x21f4 <__floatsisf+0x6a>
    21d2:	77 23       	and	r23, r23
    21d4:	21 f0       	breq	.+8      	; 0x21de <__floatsisf+0x54>
    21d6:	9e e8       	ldi	r25, 0x8E	; 142
    21d8:	87 2f       	mov	r24, r23
    21da:	76 2f       	mov	r23, r22
    21dc:	05 c0       	rjmp	.+10     	; 0x21e8 <__floatsisf+0x5e>
    21de:	66 23       	and	r22, r22
    21e0:	71 f0       	breq	.+28     	; 0x21fe <__floatsisf+0x74>
    21e2:	96 e8       	ldi	r25, 0x86	; 134
    21e4:	86 2f       	mov	r24, r22
    21e6:	70 e0       	ldi	r23, 0x00	; 0
    21e8:	60 e0       	ldi	r22, 0x00	; 0
    21ea:	2a f0       	brmi	.+10     	; 0x21f6 <__floatsisf+0x6c>
    21ec:	9a 95       	dec	r25
    21ee:	66 0f       	add	r22, r22
    21f0:	77 1f       	adc	r23, r23
    21f2:	88 1f       	adc	r24, r24
    21f4:	da f7       	brpl	.-10     	; 0x21ec <__floatsisf+0x62>
    21f6:	88 0f       	add	r24, r24
    21f8:	96 95       	lsr	r25
    21fa:	87 95       	ror	r24
    21fc:	97 f9       	bld	r25, 7
    21fe:	08 95       	ret

00002200 <__fp_inf>:
    2200:	97 f9       	bld	r25, 7
    2202:	9f 67       	ori	r25, 0x7F	; 127
    2204:	80 e8       	ldi	r24, 0x80	; 128
    2206:	70 e0       	ldi	r23, 0x00	; 0
    2208:	60 e0       	ldi	r22, 0x00	; 0
    220a:	08 95       	ret

0000220c <__fp_nan>:
    220c:	9f ef       	ldi	r25, 0xFF	; 255
    220e:	80 ec       	ldi	r24, 0xC0	; 192
    2210:	08 95       	ret

00002212 <__fp_pscA>:
    2212:	00 24       	eor	r0, r0
    2214:	0a 94       	dec	r0
    2216:	16 16       	cp	r1, r22
    2218:	17 06       	cpc	r1, r23
    221a:	18 06       	cpc	r1, r24
    221c:	09 06       	cpc	r0, r25
    221e:	08 95       	ret

00002220 <__fp_pscB>:
    2220:	00 24       	eor	r0, r0
    2222:	0a 94       	dec	r0
    2224:	12 16       	cp	r1, r18
    2226:	13 06       	cpc	r1, r19
    2228:	14 06       	cpc	r1, r20
    222a:	05 06       	cpc	r0, r21
    222c:	08 95       	ret

0000222e <__fp_round>:
    222e:	09 2e       	mov	r0, r25
    2230:	03 94       	inc	r0
    2232:	00 0c       	add	r0, r0
    2234:	11 f4       	brne	.+4      	; 0x223a <__fp_round+0xc>
    2236:	88 23       	and	r24, r24
    2238:	52 f0       	brmi	.+20     	; 0x224e <__fp_round+0x20>
    223a:	bb 0f       	add	r27, r27
    223c:	40 f4       	brcc	.+16     	; 0x224e <__fp_round+0x20>
    223e:	bf 2b       	or	r27, r31
    2240:	11 f4       	brne	.+4      	; 0x2246 <__fp_round+0x18>
    2242:	60 ff       	sbrs	r22, 0
    2244:	04 c0       	rjmp	.+8      	; 0x224e <__fp_round+0x20>
    2246:	6f 5f       	subi	r22, 0xFF	; 255
    2248:	7f 4f       	sbci	r23, 0xFF	; 255
    224a:	8f 4f       	sbci	r24, 0xFF	; 255
    224c:	9f 4f       	sbci	r25, 0xFF	; 255
    224e:	08 95       	ret

00002250 <__fp_split3>:
    2250:	57 fd       	sbrc	r21, 7
    2252:	90 58       	subi	r25, 0x80	; 128
    2254:	44 0f       	add	r20, r20
    2256:	55 1f       	adc	r21, r21
    2258:	59 f0       	breq	.+22     	; 0x2270 <__fp_splitA+0x10>
    225a:	5f 3f       	cpi	r21, 0xFF	; 255
    225c:	71 f0       	breq	.+28     	; 0x227a <__fp_splitA+0x1a>
    225e:	47 95       	ror	r20

00002260 <__fp_splitA>:
    2260:	88 0f       	add	r24, r24
    2262:	97 fb       	bst	r25, 7
    2264:	99 1f       	adc	r25, r25
    2266:	61 f0       	breq	.+24     	; 0x2280 <__fp_splitA+0x20>
    2268:	9f 3f       	cpi	r25, 0xFF	; 255
    226a:	79 f0       	breq	.+30     	; 0x228a <__fp_splitA+0x2a>
    226c:	87 95       	ror	r24
    226e:	08 95       	ret
    2270:	12 16       	cp	r1, r18
    2272:	13 06       	cpc	r1, r19
    2274:	14 06       	cpc	r1, r20
    2276:	55 1f       	adc	r21, r21
    2278:	f2 cf       	rjmp	.-28     	; 0x225e <__fp_split3+0xe>
    227a:	46 95       	lsr	r20
    227c:	f1 df       	rcall	.-30     	; 0x2260 <__fp_splitA>
    227e:	08 c0       	rjmp	.+16     	; 0x2290 <__fp_splitA+0x30>
    2280:	16 16       	cp	r1, r22
    2282:	17 06       	cpc	r1, r23
    2284:	18 06       	cpc	r1, r24
    2286:	99 1f       	adc	r25, r25
    2288:	f1 cf       	rjmp	.-30     	; 0x226c <__fp_splitA+0xc>
    228a:	86 95       	lsr	r24
    228c:	71 05       	cpc	r23, r1
    228e:	61 05       	cpc	r22, r1
    2290:	08 94       	sec
    2292:	08 95       	ret

00002294 <__fp_zero>:
    2294:	e8 94       	clt

00002296 <__fp_szero>:
    2296:	bb 27       	eor	r27, r27
    2298:	66 27       	eor	r22, r22
    229a:	77 27       	eor	r23, r23
    229c:	cb 01       	movw	r24, r22
    229e:	97 f9       	bld	r25, 7
    22a0:	08 95       	ret

000022a2 <memcpy>:
    22a2:	fb 01       	movw	r30, r22
    22a4:	dc 01       	movw	r26, r24
    22a6:	02 c0       	rjmp	.+4      	; 0x22ac <memcpy+0xa>
    22a8:	01 90       	ld	r0, Z+
    22aa:	0d 92       	st	X+, r0
    22ac:	41 50       	subi	r20, 0x01	; 1
    22ae:	50 40       	sbci	r21, 0x00	; 0
    22b0:	d8 f7       	brcc	.-10     	; 0x22a8 <memcpy+0x6>
    22b2:	08 95       	ret

000022b4 <itoa>:
    22b4:	45 32       	cpi	r20, 0x25	; 37
    22b6:	51 05       	cpc	r21, r1
    22b8:	20 f4       	brcc	.+8      	; 0x22c2 <itoa+0xe>
    22ba:	42 30       	cpi	r20, 0x02	; 2
    22bc:	10 f0       	brcs	.+4      	; 0x22c2 <itoa+0xe>
    22be:	0c 94 65 11 	jmp	0x22ca	; 0x22ca <__itoa_ncheck>
    22c2:	fb 01       	movw	r30, r22
    22c4:	10 82       	st	Z, r1
    22c6:	cb 01       	movw	r24, r22
    22c8:	08 95       	ret

000022ca <__itoa_ncheck>:
    22ca:	bb 27       	eor	r27, r27
    22cc:	4a 30       	cpi	r20, 0x0A	; 10
    22ce:	31 f4       	brne	.+12     	; 0x22dc <__itoa_ncheck+0x12>
    22d0:	99 23       	and	r25, r25
    22d2:	22 f4       	brpl	.+8      	; 0x22dc <__itoa_ncheck+0x12>
    22d4:	bd e2       	ldi	r27, 0x2D	; 45
    22d6:	90 95       	com	r25
    22d8:	81 95       	neg	r24
    22da:	9f 4f       	sbci	r25, 0xFF	; 255
    22dc:	0c 94 71 11 	jmp	0x22e2	; 0x22e2 <__utoa_common>

000022e0 <__utoa_ncheck>:
    22e0:	bb 27       	eor	r27, r27

000022e2 <__utoa_common>:
    22e2:	fb 01       	movw	r30, r22
    22e4:	55 27       	eor	r21, r21
    22e6:	aa 27       	eor	r26, r26
    22e8:	88 0f       	add	r24, r24
    22ea:	99 1f       	adc	r25, r25
    22ec:	aa 1f       	adc	r26, r26
    22ee:	a4 17       	cp	r26, r20
    22f0:	10 f0       	brcs	.+4      	; 0x22f6 <__utoa_common+0x14>
    22f2:	a4 1b       	sub	r26, r20
    22f4:	83 95       	inc	r24
    22f6:	50 51       	subi	r21, 0x10	; 16
    22f8:	b9 f7       	brne	.-18     	; 0x22e8 <__utoa_common+0x6>
    22fa:	a0 5d       	subi	r26, 0xD0	; 208
    22fc:	aa 33       	cpi	r26, 0x3A	; 58
    22fe:	08 f0       	brcs	.+2      	; 0x2302 <__utoa_common+0x20>
    2300:	a9 5d       	subi	r26, 0xD9	; 217
    2302:	a1 93       	st	Z+, r26
    2304:	00 97       	sbiw	r24, 0x00	; 0
    2306:	79 f7       	brne	.-34     	; 0x22e6 <__utoa_common+0x4>
    2308:	b1 11       	cpse	r27, r1
    230a:	b1 93       	st	Z+, r27
    230c:	11 92       	st	Z+, r1
    230e:	cb 01       	movw	r24, r22
    2310:	0c 94 8a 11 	jmp	0x2314	; 0x2314 <strrev>

00002314 <strrev>:
    2314:	dc 01       	movw	r26, r24
    2316:	fc 01       	movw	r30, r24
    2318:	67 2f       	mov	r22, r23
    231a:	71 91       	ld	r23, Z+
    231c:	77 23       	and	r23, r23
    231e:	e1 f7       	brne	.-8      	; 0x2318 <strrev+0x4>
    2320:	32 97       	sbiw	r30, 0x02	; 2
    2322:	04 c0       	rjmp	.+8      	; 0x232c <strrev+0x18>
    2324:	7c 91       	ld	r23, X
    2326:	6d 93       	st	X+, r22
    2328:	70 83       	st	Z, r23
    232a:	62 91       	ld	r22, -Z
    232c:	ae 17       	cp	r26, r30
    232e:	bf 07       	cpc	r27, r31
    2330:	c8 f3       	brcs	.-14     	; 0x2324 <strrev+0x10>
    2332:	08 95       	ret

00002334 <_exit>:
    2334:	f8 94       	cli

00002336 <__stop_program>:
    2336:	ff cf       	rjmp	.-2      	; 0x2336 <__stop_program>
