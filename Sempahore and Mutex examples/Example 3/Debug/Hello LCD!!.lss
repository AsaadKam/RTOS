
Hello LCD!!.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001b60  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000036  00800060  00001b60  00001bf4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000682  00800096  00800096  00001c2a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001c2a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001c5c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003e0  00000000  00000000  00001c98  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004f49  00000000  00000000  00002078  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000012a8  00000000  00000000  00006fc1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003065  00000000  00000000  00008269  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b34  00000000  00000000  0000b2d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000017f8  00000000  00000000  0000be04  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000507c  00000000  00000000  0000d5fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000458  00000000  00000000  00012678  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 f3 05 	jmp	0xbe6	; 0xbe6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e6       	ldi	r30, 0x60	; 96
      68:	fb e1       	ldi	r31, 0x1B	; 27
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a6 39       	cpi	r26, 0x96	; 150
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a6 e9       	ldi	r26, 0x96	; 150
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 31       	cpi	r26, 0x18	; 24
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <main>
      8a:	0c 94 ae 0d 	jmp	0x1b5c	; 0x1b5c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <System_Init>:
/***********************PROTOTYPE_IMPLEMENTATION*******************************/
void System_Init (void *Pv_Parameter)            /**     No  Periodicity         -- Priority is 3**/
{
    uinteg8_t gu8_LCD_Status=0;

	vTaskSuspend(LCD_Handler);
      92:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <LCD_Handler>
      96:	90 91 98 00 	lds	r25, 0x0098	; 0x800098 <LCD_Handler+0x1>
      9a:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vTaskSuspend>
	vTaskSuspend(String_transmiting_Handler);
      9e:	80 91 9d 00 	lds	r24, 0x009D	; 0x80009d <String_transmiting_Handler>
      a2:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <String_transmiting_Handler+0x1>
      a6:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vTaskSuspend>
	vTaskSuspend(Switch_Handler);
      aa:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <Switch_Handler>
      ae:	90 91 9a 00 	lds	r25, 0x009A	; 0x80009a <Switch_Handler+0x1>
      b2:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vTaskSuspend>
		
	while(1)
	{
	    LCD_init();
      b6:	0e 94 62 02 	call	0x4c4	; 0x4c4 <LCD_init>
		vTaskResume(LCD_Handler);
      ba:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <LCD_Handler>
      be:	90 91 98 00 	lds	r25, 0x0098	; 0x800098 <LCD_Handler+0x1>
      c2:	0e 94 39 0a 	call	0x1472	; 0x1472 <vTaskResume>
		vTaskResume(String_transmiting_Handler);
      c6:	80 91 9d 00 	lds	r24, 0x009D	; 0x80009d <String_transmiting_Handler>
      ca:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <String_transmiting_Handler+0x1>
      ce:	0e 94 39 0a 	call	0x1472	; 0x1472 <vTaskResume>
		vTaskResume(Switch_Handler);		
      d2:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <Switch_Handler>
      d6:	90 91 9a 00 	lds	r25, 0x009A	; 0x80009a <Switch_Handler+0x1>
      da:	0e 94 39 0a 	call	0x1472	; 0x1472 <vTaskResume>
		vTaskSuspend(SYS_Handler);
      de:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <SYS_Handler>
      e2:	90 91 9c 00 	lds	r25, 0x009C	; 0x80009c <SYS_Handler+0x1>
      e6:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vTaskSuspend>
      ea:	e5 cf       	rjmp	.-54     	; 0xb6 <System_Init+0x24>

000000ec <Check_Switch>:
	}
}

void Check_Switch(void*Pv_Parameter)             /** Periodicity 50 milisecond   -- Priority is 2**/
{
      ec:	cf 93       	push	r28
      ee:	df 93       	push	r29
      f0:	00 d0       	rcall	.+0      	; 0xf2 <Check_Switch+0x6>
      f2:	1f 92       	push	r1
      f4:	cd b7       	in	r28, 0x3d	; 61
      f6:	de b7       	in	r29, 0x3e	; 62
    Debug_By_Toggle(23);		
      f8:	87 e1       	ldi	r24, 0x17	; 23
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	0e 94 08 04 	call	0x810	; 0x810 <Debug_By_Toggle>

	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 50;
    Switch_Couting_Semaphore=xSemaphoreCreateCounting(4,0);		
     100:	60 e0       	ldi	r22, 0x00	; 0
     102:	84 e0       	ldi	r24, 0x04	; 4
     104:	0e 94 40 07 	call	0xe80	; 0xe80 <xQueueCreateCountingSemaphore>
     108:	90 93 0f 07 	sts	0x070F, r25	; 0x80070f <Switch_Couting_Semaphore+0x1>
     10c:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <Switch_Couting_Semaphore>

	
	while(1)
	{

		xLastWakeTime=xTaskGetTickCount();
     110:	0e 94 b8 0a 	call	0x1570	; 0x1570 <xTaskGetTickCount>
     114:	9a 83       	std	Y+2, r25	; 0x02
     116:	89 83       	std	Y+1, r24	; 0x01
		vTaskDelayUntil( &xLastWakeTime, xFrequency );	
     118:	62 e3       	ldi	r22, 0x32	; 50
     11a:	70 e0       	ldi	r23, 0x00	; 0
     11c:	ce 01       	movw	r24, r28
     11e:	01 96       	adiw	r24, 0x01	; 1
     120:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <vTaskDelayUntil>
		/*Read switch 0 */
		Read_Switch(switch0,&u8_value_of_switch);
     124:	be 01       	movw	r22, r28
     126:	6d 5f       	subi	r22, 0xFD	; 253
     128:	7f 4f       	sbci	r23, 0xFF	; 255
     12a:	80 e0       	ldi	r24, 0x00	; 0
     12c:	0e 94 64 03 	call	0x6c8	; 0x6c8 <DIO_Read_Pin>
		/*if it is high increment the global variable */
		if(u8_value_of_switch==HIGH)
     130:	8b 81       	ldd	r24, Y+3	; 0x03
     132:	81 30       	cpi	r24, 0x01	; 1
     134:	69 f7       	brne	.-38     	; 0x110 <Check_Switch+0x24>
		{
			if(uxSemaphoreGetCount(Switch_Couting_Semaphore)<4)
     136:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <Switch_Couting_Semaphore>
     13a:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <Switch_Couting_Semaphore+0x1>
     13e:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <uxQueueMessagesWaiting>
     142:	84 30       	cpi	r24, 0x04	; 4
     144:	58 f4       	brcc	.+22     	; 0x15c <Check_Switch+0x70>
			{
				/*Increment counting semaphore*/
				xSemaphoreGive(Switch_Couting_Semaphore);
     146:	20 e0       	ldi	r18, 0x00	; 0
     148:	40 e0       	ldi	r20, 0x00	; 0
     14a:	50 e0       	ldi	r21, 0x00	; 0
     14c:	60 e0       	ldi	r22, 0x00	; 0
     14e:	70 e0       	ldi	r23, 0x00	; 0
     150:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <Switch_Couting_Semaphore>
     154:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <Switch_Couting_Semaphore+0x1>
     158:	0e 94 4c 07 	call	0xe98	; 0xe98 <xQueueGenericSend>
			}
			Debug_By_Toggle(23);
     15c:	87 e1       	ldi	r24, 0x17	; 23
     15e:	90 e0       	ldi	r25, 0x00	; 0
     160:	0e 94 08 04 	call	0x810	; 0x810 <Debug_By_Toggle>
     164:	d5 cf       	rjmp	.-86     	; 0x110 <Check_Switch+0x24>

00000166 <String_transmiting_Task>:
		}
	}
}

void String_transmiting_Task(void *Pv_Parameter) /** Periodicity 400 milisecond  -- Priority is 1**/
{
     166:	cf 93       	push	r28
     168:	df 93       	push	r29
     16a:	00 d0       	rcall	.+0      	; 0x16c <String_transmiting_Task+0x6>
     16c:	cd b7       	in	r28, 0x3d	; 61
     16e:	de b7       	in	r29, 0x3e	; 62
    Debug_By_Toggle(24);	
     170:	88 e1       	ldi	r24, 0x18	; 24
     172:	90 e0       	ldi	r25, 0x00	; 0
     174:	0e 94 08 04 	call	0x810	; 0x810 <Debug_By_Toggle>

	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 400;

    vSemaphoreCreateBinary(String_Row_1_Semaphore);	
     178:	43 e0       	ldi	r20, 0x03	; 3
     17a:	60 e0       	ldi	r22, 0x00	; 0
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	0e 94 13 07 	call	0xe26	; 0xe26 <xQueueGenericCreate>
     182:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <String_Row_1_Semaphore+0x1>
     186:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <String_Row_1_Semaphore>
     18a:	00 97       	sbiw	r24, 0x00	; 0
     18c:	39 f0       	breq	.+14     	; 0x19c <String_transmiting_Task+0x36>
     18e:	20 e0       	ldi	r18, 0x00	; 0
     190:	40 e0       	ldi	r20, 0x00	; 0
     192:	50 e0       	ldi	r21, 0x00	; 0
     194:	60 e0       	ldi	r22, 0x00	; 0
     196:	70 e0       	ldi	r23, 0x00	; 0
     198:	0e 94 4c 07 	call	0xe98	; 0xe98 <xQueueGenericSend>
    vSemaphoreCreateBinary(String_Row_2_Semaphore);	
     19c:	43 e0       	ldi	r20, 0x03	; 3
     19e:	60 e0       	ldi	r22, 0x00	; 0
     1a0:	81 e0       	ldi	r24, 0x01	; 1
     1a2:	0e 94 13 07 	call	0xe26	; 0xe26 <xQueueGenericCreate>
     1a6:	90 93 13 07 	sts	0x0713, r25	; 0x800713 <String_Row_2_Semaphore+0x1>
     1aa:	80 93 12 07 	sts	0x0712, r24	; 0x800712 <String_Row_2_Semaphore>
     1ae:	00 97       	sbiw	r24, 0x00	; 0
     1b0:	39 f0       	breq	.+14     	; 0x1c0 <String_transmiting_Task+0x5a>
     1b2:	20 e0       	ldi	r18, 0x00	; 0
     1b4:	40 e0       	ldi	r20, 0x00	; 0
     1b6:	50 e0       	ldi	r21, 0x00	; 0
     1b8:	60 e0       	ldi	r22, 0x00	; 0
     1ba:	70 e0       	ldi	r23, 0x00	; 0
     1bc:	0e 94 4c 07 	call	0xe98	; 0xe98 <xQueueGenericSend>
		xLastWakeTime=xTaskGetTickCount();
		vTaskDelayUntil( &xLastWakeTime, xFrequency );		
		xSemaphoreTake( String_Row_1_Semaphore, ( TickType_t ) 0 );
		/*Transferring from one array to another array*/
        u8_LCD_ROW_0_index=0;		
        while(Transmitted_Row_0_Array[u8_LCD_ROW_0_index])
     1c0:	0f 2e       	mov	r0, r31
     1c2:	f1 e7       	ldi	r31, 0x71	; 113
     1c4:	ef 2e       	mov	r14, r31
     1c6:	f0 e0       	ldi	r31, 0x00	; 0
     1c8:	ff 2e       	mov	r15, r31
     1ca:	f0 2d       	mov	r31, r0
		xSemaphoreGive(String_Row_1_Semaphore);
				
		xSemaphoreTake( String_Row_2_Semaphore, ( TickType_t ) 0 );	
		/*Transferring from one array to another array*/		
		u8_LCD_ROW_1_index=0;			
        while(Transmitted_Row_1_Array[u8_LCD_ROW_1_index])
     1cc:	01 e6       	ldi	r16, 0x61	; 97
     1ce:	10 e0       	ldi	r17, 0x00	; 0
    uinteg8_t u8_LCD_ROW_0_index=0,u8_LCD_ROW_1_index=0;
	
	while(1)
	{

		xLastWakeTime=xTaskGetTickCount();
     1d0:	0e 94 b8 0a 	call	0x1570	; 0x1570 <xTaskGetTickCount>
     1d4:	9a 83       	std	Y+2, r25	; 0x02
     1d6:	89 83       	std	Y+1, r24	; 0x01
		vTaskDelayUntil( &xLastWakeTime, xFrequency );		
     1d8:	60 e9       	ldi	r22, 0x90	; 144
     1da:	71 e0       	ldi	r23, 0x01	; 1
     1dc:	ce 01       	movw	r24, r28
     1de:	01 96       	adiw	r24, 0x01	; 1
     1e0:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <vTaskDelayUntil>
		xSemaphoreTake( String_Row_1_Semaphore, ( TickType_t ) 0 );
     1e4:	60 e0       	ldi	r22, 0x00	; 0
     1e6:	70 e0       	ldi	r23, 0x00	; 0
     1e8:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <String_Row_1_Semaphore>
     1ec:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <String_Row_1_Semaphore+0x1>
     1f0:	0e 94 ed 07 	call	0xfda	; 0xfda <xQueueSemaphoreTake>
		/*Transferring from one array to another array*/
        u8_LCD_ROW_0_index=0;		
        while(Transmitted_Row_0_Array[u8_LCD_ROW_0_index])
     1f4:	f7 01       	movw	r30, r14
     1f6:	20 81       	ld	r18, Z
     1f8:	22 23       	and	r18, r18
     1fa:	81 f0       	breq	.+32     	; 0x21c <String_transmiting_Task+0xb6>
     1fc:	80 e0       	ldi	r24, 0x00	; 0
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	30 e0       	ldi	r19, 0x00	; 0
		{
			LCD_Row_0_Array[u8_LCD_ROW_0_index]=Transmitted_Row_0_Array[u8_LCD_ROW_0_index];
     202:	fc 01       	movw	r30, r24
     204:	e1 55       	subi	r30, 0x51	; 81
     206:	ff 4f       	sbci	r31, 0xFF	; 255
     208:	20 83       	st	Z, r18
			u8_LCD_ROW_0_index++;
     20a:	3f 5f       	subi	r19, 0xFF	; 255
		xLastWakeTime=xTaskGetTickCount();
		vTaskDelayUntil( &xLastWakeTime, xFrequency );		
		xSemaphoreTake( String_Row_1_Semaphore, ( TickType_t ) 0 );
		/*Transferring from one array to another array*/
        u8_LCD_ROW_0_index=0;		
        while(Transmitted_Row_0_Array[u8_LCD_ROW_0_index])
     20c:	83 2f       	mov	r24, r19
     20e:	90 e0       	ldi	r25, 0x00	; 0
     210:	fc 01       	movw	r30, r24
     212:	ef 58       	subi	r30, 0x8F	; 143
     214:	ff 4f       	sbci	r31, 0xFF	; 255
     216:	20 81       	ld	r18, Z
     218:	21 11       	cpse	r18, r1
     21a:	f3 cf       	rjmp	.-26     	; 0x202 <String_transmiting_Task+0x9c>
		{
			LCD_Row_0_Array[u8_LCD_ROW_0_index]=Transmitted_Row_0_Array[u8_LCD_ROW_0_index];
			u8_LCD_ROW_0_index++;
		}

		xSemaphoreGive(String_Row_1_Semaphore);
     21c:	20 e0       	ldi	r18, 0x00	; 0
     21e:	40 e0       	ldi	r20, 0x00	; 0
     220:	50 e0       	ldi	r21, 0x00	; 0
     222:	60 e0       	ldi	r22, 0x00	; 0
     224:	70 e0       	ldi	r23, 0x00	; 0
     226:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <String_Row_1_Semaphore>
     22a:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <String_Row_1_Semaphore+0x1>
     22e:	0e 94 4c 07 	call	0xe98	; 0xe98 <xQueueGenericSend>
				
		xSemaphoreTake( String_Row_2_Semaphore, ( TickType_t ) 0 );	
     232:	60 e0       	ldi	r22, 0x00	; 0
     234:	70 e0       	ldi	r23, 0x00	; 0
     236:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <String_Row_2_Semaphore>
     23a:	90 91 13 07 	lds	r25, 0x0713	; 0x800713 <String_Row_2_Semaphore+0x1>
     23e:	0e 94 ed 07 	call	0xfda	; 0xfda <xQueueSemaphoreTake>
		/*Transferring from one array to another array*/		
		u8_LCD_ROW_1_index=0;			
        while(Transmitted_Row_1_Array[u8_LCD_ROW_1_index])
     242:	f8 01       	movw	r30, r16
     244:	20 81       	ld	r18, Z
     246:	22 23       	and	r18, r18
     248:	81 f0       	breq	.+32     	; 0x26a <String_transmiting_Task+0x104>
     24a:	80 e0       	ldi	r24, 0x00	; 0
     24c:	90 e0       	ldi	r25, 0x00	; 0
     24e:	30 e0       	ldi	r19, 0x00	; 0
        {
	        LCD_Row_1_Array[u8_LCD_ROW_1_index]=Transmitted_Row_1_Array[u8_LCD_ROW_1_index];
     250:	fc 01       	movw	r30, r24
     252:	e1 56       	subi	r30, 0x61	; 97
     254:	ff 4f       	sbci	r31, 0xFF	; 255
     256:	20 83       	st	Z, r18
	        u8_LCD_ROW_1_index++;
     258:	3f 5f       	subi	r19, 0xFF	; 255
		xSemaphoreGive(String_Row_1_Semaphore);
				
		xSemaphoreTake( String_Row_2_Semaphore, ( TickType_t ) 0 );	
		/*Transferring from one array to another array*/		
		u8_LCD_ROW_1_index=0;			
        while(Transmitted_Row_1_Array[u8_LCD_ROW_1_index])
     25a:	83 2f       	mov	r24, r19
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	fc 01       	movw	r30, r24
     260:	ef 59       	subi	r30, 0x9F	; 159
     262:	ff 4f       	sbci	r31, 0xFF	; 255
     264:	20 81       	ld	r18, Z
     266:	21 11       	cpse	r18, r1
     268:	f3 cf       	rjmp	.-26     	; 0x250 <String_transmiting_Task+0xea>
        {
	        LCD_Row_1_Array[u8_LCD_ROW_1_index]=Transmitted_Row_1_Array[u8_LCD_ROW_1_index];
	        u8_LCD_ROW_1_index++;
        }
		 
		xSemaphoreGive(String_Row_2_Semaphore);			
     26a:	20 e0       	ldi	r18, 0x00	; 0
     26c:	40 e0       	ldi	r20, 0x00	; 0
     26e:	50 e0       	ldi	r21, 0x00	; 0
     270:	60 e0       	ldi	r22, 0x00	; 0
     272:	70 e0       	ldi	r23, 0x00	; 0
     274:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <String_Row_2_Semaphore>
     278:	90 91 13 07 	lds	r25, 0x0713	; 0x800713 <String_Row_2_Semaphore+0x1>
     27c:	0e 94 4c 07 	call	0xe98	; 0xe98 <xQueueGenericSend>
	}
     280:	a7 cf       	rjmp	.-178    	; 0x1d0 <String_transmiting_Task+0x6a>

00000282 <LCD_DISP>:
}

void LCD_DISP(void *Pv_Paramaeter)               /** Periodicity 200 milisecond  -- Priority is 0**/
{
     282:	cf 93       	push	r28
     284:	df 93       	push	r29
     286:	00 d0       	rcall	.+0      	; 0x288 <LCD_DISP+0x6>
     288:	cd b7       	in	r28, 0x3d	; 61
     28a:	de b7       	in	r29, 0x3e	; 62
		    }
	    }
	    else
	    {
		    /**Here i am going to clear,then i am going to write again**/
		    su8_Write_New_String_Flag=1;
     28c:	01 e0       	ldi	r16, 0x01	; 1
	static uinteg8_t su8_Write_New_String_Flag=1;
	       uinteg8_t  u8_Switch_Sempahore_Count_Buffer=0; 
		    
	while(1)
	{
		xLastWakeTime=xTaskGetTickCount();
     28e:	0e 94 b8 0a 	call	0x1570	; 0x1570 <xTaskGetTickCount>
     292:	9a 83       	std	Y+2, r25	; 0x02
     294:	89 83       	std	Y+1, r24	; 0x01
		/*Get count of semaphore*/
		u8_Switch_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch_Couting_Semaphore);
     296:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <Switch_Couting_Semaphore>
     29a:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <Switch_Couting_Semaphore+0x1>
     29e:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <uxQueueMessagesWaiting>
     2a2:	18 2f       	mov	r17, r24
		/*Decrement counting semaphore*/
		while(uxSemaphoreGetCount(Switch_Couting_Semaphore)!=0)
     2a4:	08 c0       	rjmp	.+16     	; 0x2b6 <LCD_DISP+0x34>
		{
			xSemaphoreTake( Switch_Couting_Semaphore, ( TickType_t ) 0 );
     2a6:	60 e0       	ldi	r22, 0x00	; 0
     2a8:	70 e0       	ldi	r23, 0x00	; 0
     2aa:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <Switch_Couting_Semaphore>
     2ae:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <Switch_Couting_Semaphore+0x1>
     2b2:	0e 94 ed 07 	call	0xfda	; 0xfda <xQueueSemaphoreTake>
	{
		xLastWakeTime=xTaskGetTickCount();
		/*Get count of semaphore*/
		u8_Switch_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch_Couting_Semaphore);
		/*Decrement counting semaphore*/
		while(uxSemaphoreGetCount(Switch_Couting_Semaphore)!=0)
     2b6:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <Switch_Couting_Semaphore>
     2ba:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <Switch_Couting_Semaphore+0x1>
     2be:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <uxQueueMessagesWaiting>
     2c2:	81 11       	cpse	r24, r1
     2c4:	f0 cf       	rjmp	.-32     	; 0x2a6 <LCD_DISP+0x24>
		{
			xSemaphoreTake( Switch_Couting_Semaphore, ( TickType_t ) 0 );
		}
		
	    if(u8_Switch_Sempahore_Count_Buffer>=2)
     2c6:	12 30       	cpi	r17, 0x02	; 2
     2c8:	10 f1       	brcs	.+68     	; 0x30e <LCD_DISP+0x8c>
	    {
		    if(su8_Write_New_String_Flag==1)
     2ca:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     2ce:	81 30       	cpi	r24, 0x01	; 1
     2d0:	d9 f5       	brne	.+118    	; 0x348 <LCD_DISP+0xc6>
		    {
			    su8_Write_New_String_Flag=0;
     2d2:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__data_start>
		        /**Protection with semaphore*/				
				xSemaphoreTake(String_Row_2_Semaphore, ( TickType_t ) 0 );
     2d6:	60 e0       	ldi	r22, 0x00	; 0
     2d8:	70 e0       	ldi	r23, 0x00	; 0
     2da:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <String_Row_2_Semaphore>
     2de:	90 91 13 07 	lds	r25, 0x0713	; 0x800713 <String_Row_2_Semaphore+0x1>
     2e2:	0e 94 ed 07 	call	0xfda	; 0xfda <xQueueSemaphoreTake>
				
			    LCD_displayStringRowColumn(2,0,LCD_Row_1_Array);
     2e6:	4f e9       	ldi	r20, 0x9F	; 159
     2e8:	50 e0       	ldi	r21, 0x00	; 0
     2ea:	60 e0       	ldi	r22, 0x00	; 0
     2ec:	70 e0       	ldi	r23, 0x00	; 0
     2ee:	82 e0       	ldi	r24, 0x02	; 2
     2f0:	90 e0       	ldi	r25, 0x00	; 0
     2f2:	0e 94 c3 02 	call	0x586	; 0x586 <LCD_displayStringRowColumn>
				
			    xSemaphoreGive(String_Row_2_Semaphore);
     2f6:	20 e0       	ldi	r18, 0x00	; 0
     2f8:	40 e0       	ldi	r20, 0x00	; 0
     2fa:	50 e0       	ldi	r21, 0x00	; 0
     2fc:	60 e0       	ldi	r22, 0x00	; 0
     2fe:	70 e0       	ldi	r23, 0x00	; 0
     300:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <String_Row_2_Semaphore>
     304:	90 91 13 07 	lds	r25, 0x0713	; 0x800713 <String_Row_2_Semaphore+0x1>
     308:	0e 94 4c 07 	call	0xe98	; 0xe98 <xQueueGenericSend>
     30c:	1d c0       	rjmp	.+58     	; 0x348 <LCD_DISP+0xc6>
		    }
	    }
	    else
	    {
		    /**Here i am going to clear,then i am going to write again**/
		    su8_Write_New_String_Flag=1;
     30e:	00 93 60 00 	sts	0x0060, r16	; 0x800060 <__data_start>
		    
		    xSemaphoreTake(String_Row_2_Semaphore, ( TickType_t ) 0 );
     312:	60 e0       	ldi	r22, 0x00	; 0
     314:	70 e0       	ldi	r23, 0x00	; 0
     316:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <String_Row_2_Semaphore>
     31a:	90 91 13 07 	lds	r25, 0x0713	; 0x800713 <String_Row_2_Semaphore+0x1>
     31e:	0e 94 ed 07 	call	0xfda	; 0xfda <xQueueSemaphoreTake>
		    
		    LCD_displayStringRowColumn(2,0,"               ");
     322:	41 e8       	ldi	r20, 0x81	; 129
     324:	50 e0       	ldi	r21, 0x00	; 0
     326:	60 e0       	ldi	r22, 0x00	; 0
     328:	70 e0       	ldi	r23, 0x00	; 0
     32a:	82 e0       	ldi	r24, 0x02	; 2
     32c:	90 e0       	ldi	r25, 0x00	; 0
     32e:	0e 94 c3 02 	call	0x586	; 0x586 <LCD_displayStringRowColumn>
		    
		    xSemaphoreGive(String_Row_2_Semaphore);
     332:	20 e0       	ldi	r18, 0x00	; 0
     334:	40 e0       	ldi	r20, 0x00	; 0
     336:	50 e0       	ldi	r21, 0x00	; 0
     338:	60 e0       	ldi	r22, 0x00	; 0
     33a:	70 e0       	ldi	r23, 0x00	; 0
     33c:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <String_Row_2_Semaphore>
     340:	90 91 13 07 	lds	r25, 0x0713	; 0x800713 <String_Row_2_Semaphore+0x1>
     344:	0e 94 4c 07 	call	0xe98	; 0xe98 <xQueueGenericSend>
	    }

		/**Dispatch row 2 that is related to switch state*/
		if(su8_Flag==0)
     348:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <__data_end>
     34c:	81 11       	cpse	r24, r1
     34e:	1e c0       	rjmp	.+60     	; 0x38c <LCD_DISP+0x10a>
		{
			/**Protection with semaphore*/
			xSemaphoreTake(String_Row_1_Semaphore, ( TickType_t ) 0 );
     350:	60 e0       	ldi	r22, 0x00	; 0
     352:	70 e0       	ldi	r23, 0x00	; 0
     354:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <String_Row_1_Semaphore>
     358:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <String_Row_1_Semaphore+0x1>
     35c:	0e 94 ed 07 	call	0xfda	; 0xfda <xQueueSemaphoreTake>
			
			LCD_displayStringRowColumn(1,0,LCD_Row_0_Array);
     360:	4f ea       	ldi	r20, 0xAF	; 175
     362:	50 e0       	ldi	r21, 0x00	; 0
     364:	60 e0       	ldi	r22, 0x00	; 0
     366:	70 e0       	ldi	r23, 0x00	; 0
     368:	81 e0       	ldi	r24, 0x01	; 1
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	0e 94 c3 02 	call	0x586	; 0x586 <LCD_displayStringRowColumn>
		
			xSemaphoreGive(String_Row_1_Semaphore);  
     370:	20 e0       	ldi	r18, 0x00	; 0
     372:	40 e0       	ldi	r20, 0x00	; 0
     374:	50 e0       	ldi	r21, 0x00	; 0
     376:	60 e0       	ldi	r22, 0x00	; 0
     378:	70 e0       	ldi	r23, 0x00	; 0
     37a:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <String_Row_1_Semaphore>
     37e:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <String_Row_1_Semaphore+0x1>
     382:	0e 94 4c 07 	call	0xe98	; 0xe98 <xQueueGenericSend>
			su8_Flag=1;	
     386:	00 93 96 00 	sts	0x0096, r16	; 0x800096 <__data_end>
     38a:	1d c0       	rjmp	.+58     	; 0x3c6 <LCD_DISP+0x144>
		}
		else if(su8_Flag)
		{
			/**Protection with semaphore*/			
			xSemaphoreTake(String_Row_1_Semaphore, ( TickType_t ) 0 );
     38c:	60 e0       	ldi	r22, 0x00	; 0
     38e:	70 e0       	ldi	r23, 0x00	; 0
     390:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <String_Row_1_Semaphore>
     394:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <String_Row_1_Semaphore+0x1>
     398:	0e 94 ed 07 	call	0xfda	; 0xfda <xQueueSemaphoreTake>
						
			/**Here i am going to clear,then i am going to write again**/			
			LCD_displayStringRowColumn(1,0,"               ");
     39c:	41 e8       	ldi	r20, 0x81	; 129
     39e:	50 e0       	ldi	r21, 0x00	; 0
     3a0:	60 e0       	ldi	r22, 0x00	; 0
     3a2:	70 e0       	ldi	r23, 0x00	; 0
     3a4:	81 e0       	ldi	r24, 0x01	; 1
     3a6:	90 e0       	ldi	r25, 0x00	; 0
     3a8:	0e 94 c3 02 	call	0x586	; 0x586 <LCD_displayStringRowColumn>
			
			xSemaphoreGive(String_Row_1_Semaphore); 
     3ac:	20 e0       	ldi	r18, 0x00	; 0
     3ae:	40 e0       	ldi	r20, 0x00	; 0
     3b0:	50 e0       	ldi	r21, 0x00	; 0
     3b2:	60 e0       	ldi	r22, 0x00	; 0
     3b4:	70 e0       	ldi	r23, 0x00	; 0
     3b6:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <String_Row_1_Semaphore>
     3ba:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <String_Row_1_Semaphore+0x1>
     3be:	0e 94 4c 07 	call	0xe98	; 0xe98 <xQueueGenericSend>
			su8_Flag=0; 			
     3c2:	10 92 96 00 	sts	0x0096, r1	; 0x800096 <__data_end>
		}
        else
		{
			/*Do Nothing*/
		}		
		vTaskDelayUntil( &xLastWakeTime, xFrequency );					
     3c6:	68 ec       	ldi	r22, 0xC8	; 200
     3c8:	70 e0       	ldi	r23, 0x00	; 0
     3ca:	ce 01       	movw	r24, r28
     3cc:	01 96       	adiw	r24, 0x01	; 1
     3ce:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <vTaskDelayUntil>
	}
     3d2:	5d cf       	rjmp	.-326    	; 0x28e <LCD_DISP+0xc>

000003d4 <main>:
}

int main(void)
{
     3d4:	ef 92       	push	r14
     3d6:	ff 92       	push	r15
     3d8:	0f 93       	push	r16
    /**Create the task of System_Init where it uses 100 word from stack and has priority 3*/
    xTaskCreate(System_Init,NULL,100,NULL,1,&SYS_Handler);
     3da:	0f 2e       	mov	r0, r31
     3dc:	fb e9       	ldi	r31, 0x9B	; 155
     3de:	ef 2e       	mov	r14, r31
     3e0:	f0 e0       	ldi	r31, 0x00	; 0
     3e2:	ff 2e       	mov	r15, r31
     3e4:	f0 2d       	mov	r31, r0
     3e6:	01 e0       	ldi	r16, 0x01	; 1
     3e8:	20 e0       	ldi	r18, 0x00	; 0
     3ea:	30 e0       	ldi	r19, 0x00	; 0
     3ec:	44 e6       	ldi	r20, 0x64	; 100
     3ee:	50 e0       	ldi	r21, 0x00	; 0
     3f0:	60 e0       	ldi	r22, 0x00	; 0
     3f2:	70 e0       	ldi	r23, 0x00	; 0
     3f4:	89 e4       	ldi	r24, 0x49	; 73
     3f6:	90 e0       	ldi	r25, 0x00	; 0
     3f8:	0e 94 25 09 	call	0x124a	; 0x124a <xTaskCreate>
    /**Create the task of Check_Switch where it uses 100 word from stack and has priority 2*/
    xTaskCreate(Check_Switch,NULL,100,NULL,2,&Switch_Handler);
     3fc:	0f 2e       	mov	r0, r31
     3fe:	f9 e9       	ldi	r31, 0x99	; 153
     400:	ef 2e       	mov	r14, r31
     402:	f0 e0       	ldi	r31, 0x00	; 0
     404:	ff 2e       	mov	r15, r31
     406:	f0 2d       	mov	r31, r0
     408:	02 e0       	ldi	r16, 0x02	; 2
     40a:	20 e0       	ldi	r18, 0x00	; 0
     40c:	30 e0       	ldi	r19, 0x00	; 0
     40e:	44 e6       	ldi	r20, 0x64	; 100
     410:	50 e0       	ldi	r21, 0x00	; 0
     412:	60 e0       	ldi	r22, 0x00	; 0
     414:	70 e0       	ldi	r23, 0x00	; 0
     416:	86 e7       	ldi	r24, 0x76	; 118
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	0e 94 25 09 	call	0x124a	; 0x124a <xTaskCreate>
    /**Create the task of String_transmiting_Task where it uses 100 word from stack and has priority 1*/
    xTaskCreate(String_transmiting_Task,NULL,100,NULL,1,&String_transmiting_Handler);   	
     41e:	0f 2e       	mov	r0, r31
     420:	fd e9       	ldi	r31, 0x9D	; 157
     422:	ef 2e       	mov	r14, r31
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	ff 2e       	mov	r15, r31
     428:	f0 2d       	mov	r31, r0
     42a:	01 e0       	ldi	r16, 0x01	; 1
     42c:	20 e0       	ldi	r18, 0x00	; 0
     42e:	30 e0       	ldi	r19, 0x00	; 0
     430:	44 e6       	ldi	r20, 0x64	; 100
     432:	50 e0       	ldi	r21, 0x00	; 0
     434:	60 e0       	ldi	r22, 0x00	; 0
     436:	70 e0       	ldi	r23, 0x00	; 0
     438:	83 eb       	ldi	r24, 0xB3	; 179
     43a:	90 e0       	ldi	r25, 0x00	; 0
     43c:	0e 94 25 09 	call	0x124a	; 0x124a <xTaskCreate>
	/*Create the task of LCD_DISP where it uses 100 word from stack and has priority 0*/	
	xTaskCreate(LCD_DISP,NULL,100,NULL,0,&LCD_Handler);
     440:	0f 2e       	mov	r0, r31
     442:	f7 e9       	ldi	r31, 0x97	; 151
     444:	ef 2e       	mov	r14, r31
     446:	f0 e0       	ldi	r31, 0x00	; 0
     448:	ff 2e       	mov	r15, r31
     44a:	f0 2d       	mov	r31, r0
     44c:	00 e0       	ldi	r16, 0x00	; 0
     44e:	20 e0       	ldi	r18, 0x00	; 0
     450:	30 e0       	ldi	r19, 0x00	; 0
     452:	44 e6       	ldi	r20, 0x64	; 100
     454:	50 e0       	ldi	r21, 0x00	; 0
     456:	60 e0       	ldi	r22, 0x00	; 0
     458:	70 e0       	ldi	r23, 0x00	; 0
     45a:	81 e4       	ldi	r24, 0x41	; 65
     45c:	91 e0       	ldi	r25, 0x01	; 1
     45e:	0e 94 25 09 	call	0x124a	; 0x124a <xTaskCreate>

	/*Os start  */
	vTaskStartScheduler();
     462:	0e 94 88 0a 	call	0x1510	; 0x1510 <vTaskStartScheduler>
}
     466:	80 e0       	ldi	r24, 0x00	; 0
     468:	90 e0       	ldi	r25, 0x00	; 0
     46a:	0f 91       	pop	r16
     46c:	ff 90       	pop	r15
     46e:	ef 90       	pop	r14
     470:	08 95       	ret

00000472 <LCD_sendCommand>:
  }
}

void LCD_clearScreen(void)
{
	LCD_sendCommand(CLEAR_COMMAND); //clear display
     472:	cf 93       	push	r28
     474:	c8 2f       	mov	r28, r24
     476:	d9 98       	cbi	0x1b, 1	; 27
     478:	da 98       	cbi	0x1b, 2	; 27
     47a:	db 9a       	sbi	0x1b, 3	; 27
     47c:	82 e0       	ldi	r24, 0x02	; 2
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	0e 94 3a 0c 	call	0x1874	; 0x1874 <vTaskDelay>
     484:	8b b3       	in	r24, 0x1b	; 27
     486:	8f 70       	andi	r24, 0x0F	; 15
     488:	9c 2f       	mov	r25, r28
     48a:	90 7f       	andi	r25, 0xF0	; 240
     48c:	89 2b       	or	r24, r25
     48e:	8b bb       	out	0x1b, r24	; 27
     490:	db 98       	cbi	0x1b, 3	; 27
     492:	82 e0       	ldi	r24, 0x02	; 2
     494:	90 e0       	ldi	r25, 0x00	; 0
     496:	0e 94 3a 0c 	call	0x1874	; 0x1874 <vTaskDelay>
     49a:	db 9a       	sbi	0x1b, 3	; 27
     49c:	82 e0       	ldi	r24, 0x02	; 2
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	0e 94 3a 0c 	call	0x1874	; 0x1874 <vTaskDelay>
     4a4:	8b b3       	in	r24, 0x1b	; 27
     4a6:	28 2f       	mov	r18, r24
     4a8:	2f 70       	andi	r18, 0x0F	; 15
     4aa:	30 e1       	ldi	r19, 0x10	; 16
     4ac:	c3 9f       	mul	r28, r19
     4ae:	c0 01       	movw	r24, r0
     4b0:	11 24       	eor	r1, r1
     4b2:	82 2b       	or	r24, r18
     4b4:	8b bb       	out	0x1b, r24	; 27
     4b6:	db 98       	cbi	0x1b, 3	; 27
     4b8:	82 e0       	ldi	r24, 0x02	; 2
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	0e 94 3a 0c 	call	0x1874	; 0x1874 <vTaskDelay>
     4c0:	cf 91       	pop	r28
     4c2:	08 95       	ret

000004c4 <LCD_init>:
     4c4:	8a b3       	in	r24, 0x1a	; 26
     4c6:	8e 60       	ori	r24, 0x0E	; 14
     4c8:	8a bb       	out	0x1a, r24	; 26
     4ca:	8a b3       	in	r24, 0x1a	; 26
     4cc:	80 6f       	ori	r24, 0xF0	; 240
     4ce:	8a bb       	out	0x1a, r24	; 26
     4d0:	82 e0       	ldi	r24, 0x02	; 2
     4d2:	0e 94 39 02 	call	0x472	; 0x472 <LCD_sendCommand>
     4d6:	88 e2       	ldi	r24, 0x28	; 40
     4d8:	0e 94 39 02 	call	0x472	; 0x472 <LCD_sendCommand>
     4dc:	8c e0       	ldi	r24, 0x0C	; 12
     4de:	0e 94 39 02 	call	0x472	; 0x472 <LCD_sendCommand>
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	0e 94 39 02 	call	0x472	; 0x472 <LCD_sendCommand>
     4e8:	08 95       	ret

000004ea <LCD_displayCharacter>:
     4ea:	cf 93       	push	r28
     4ec:	c8 2f       	mov	r28, r24
     4ee:	d9 9a       	sbi	0x1b, 1	; 27
     4f0:	da 98       	cbi	0x1b, 2	; 27
     4f2:	db 9a       	sbi	0x1b, 3	; 27
     4f4:	81 e0       	ldi	r24, 0x01	; 1
     4f6:	90 e0       	ldi	r25, 0x00	; 0
     4f8:	0e 94 3a 0c 	call	0x1874	; 0x1874 <vTaskDelay>
     4fc:	8b b3       	in	r24, 0x1b	; 27
     4fe:	8f 70       	andi	r24, 0x0F	; 15
     500:	9c 2f       	mov	r25, r28
     502:	90 7f       	andi	r25, 0xF0	; 240
     504:	89 2b       	or	r24, r25
     506:	8b bb       	out	0x1b, r24	; 27
     508:	db 98       	cbi	0x1b, 3	; 27
     50a:	81 e0       	ldi	r24, 0x01	; 1
     50c:	90 e0       	ldi	r25, 0x00	; 0
     50e:	0e 94 3a 0c 	call	0x1874	; 0x1874 <vTaskDelay>
     512:	db 9a       	sbi	0x1b, 3	; 27
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	0e 94 3a 0c 	call	0x1874	; 0x1874 <vTaskDelay>
     51c:	8b b3       	in	r24, 0x1b	; 27
     51e:	28 2f       	mov	r18, r24
     520:	2f 70       	andi	r18, 0x0F	; 15
     522:	30 e1       	ldi	r19, 0x10	; 16
     524:	c3 9f       	mul	r28, r19
     526:	c0 01       	movw	r24, r0
     528:	11 24       	eor	r1, r1
     52a:	82 2b       	or	r24, r18
     52c:	8b bb       	out	0x1b, r24	; 27
     52e:	db 98       	cbi	0x1b, 3	; 27
     530:	81 e0       	ldi	r24, 0x01	; 1
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	0e 94 3a 0c 	call	0x1874	; 0x1874 <vTaskDelay>
     538:	80 e0       	ldi	r24, 0x00	; 0
     53a:	cf 91       	pop	r28
     53c:	08 95       	ret

0000053e <LCD_displayString>:
     53e:	0f 93       	push	r16
     540:	1f 93       	push	r17
     542:	cf 93       	push	r28
     544:	fc 01       	movw	r30, r24
     546:	80 81       	ld	r24, Z
     548:	88 23       	and	r24, r24
     54a:	59 f0       	breq	.+22     	; 0x562 <LCD_displayString+0x24>
     54c:	8f 01       	movw	r16, r30
     54e:	c0 e0       	ldi	r28, 0x00	; 0
     550:	0e 94 75 02 	call	0x4ea	; 0x4ea <LCD_displayCharacter>
     554:	cf 5f       	subi	r28, 0xFF	; 255
     556:	f8 01       	movw	r30, r16
     558:	ec 0f       	add	r30, r28
     55a:	f1 1d       	adc	r31, r1
     55c:	80 81       	ld	r24, Z
     55e:	81 11       	cpse	r24, r1
     560:	f7 cf       	rjmp	.-18     	; 0x550 <LCD_displayString+0x12>
     562:	cf 91       	pop	r28
     564:	1f 91       	pop	r17
     566:	0f 91       	pop	r16
     568:	08 95       	ret

0000056a <LCD_goToRowColumn>:
}

void LCD_goToRowColumn(uinteg8_t row, uinteg8_t col)
{
	uinteg8_t address;
	switch(row)
     56a:	81 30       	cpi	r24, 0x01	; 1
     56c:	19 f0       	breq	.+6      	; 0x574 <LCD_goToRowColumn+0xa>
     56e:	82 30       	cpi	r24, 0x02	; 2
     570:	21 f0       	breq	.+8      	; 0x57a <LCD_goToRowColumn+0x10>
     572:	05 c0       	rjmp	.+10     	; 0x57e <LCD_goToRowColumn+0x14>
	{
		case 1:
			address = 0x80 + col;
     574:	90 e8       	ldi	r25, 0x80	; 128
     576:	96 0f       	add	r25, r22
			//OR LCD_sendCommand(0x80).
			break;
     578:	02 c0       	rjmp	.+4      	; 0x57e <LCD_goToRowColumn+0x14>
		case 2:
			address = 0xC0 + col;
     57a:	90 ec       	ldi	r25, 0xC0	; 192
     57c:	96 0f       	add	r25, r22
		default:
			break;
			//Nothing.
	}

    LCD_sendCommand(address | 0b100000000);
     57e:	89 2f       	mov	r24, r25
     580:	0e 94 39 02 	call	0x472	; 0x472 <LCD_sendCommand>
     584:	08 95       	ret

00000586 <LCD_displayStringRowColumn>:

}

void LCD_displayStringRowColumn(uinteg8_t row,uinteg8_t col,const uinteg8_t *Str)
{
     586:	cf 93       	push	r28
     588:	df 93       	push	r29
     58a:	ea 01       	movw	r28, r20
	
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
     58c:	0e 94 b5 02 	call	0x56a	; 0x56a <LCD_goToRowColumn>
	LCD_displayString(Str);
     590:	ce 01       	movw	r24, r28
     592:	0e 94 9f 02 	call	0x53e	; 0x53e <LCD_displayString>

}
     596:	df 91       	pop	r29
     598:	cf 91       	pop	r28
     59a:	08 95       	ret

0000059c <DIO_Init_Pin>:
		default :
		return DIO_ERROR_NOK;
		break;
		}
return DIO_ERROR_OK;
}
     59c:	80 32       	cpi	r24, 0x20	; 32
     59e:	08 f0       	brcs	.+2      	; 0x5a2 <DIO_Init_Pin+0x6>
     5a0:	8f c0       	rjmp	.+286    	; 0x6c0 <DIO_Init_Pin+0x124>
     5a2:	98 2f       	mov	r25, r24
     5a4:	97 70       	andi	r25, 0x07	; 7
     5a6:	86 95       	lsr	r24
     5a8:	86 95       	lsr	r24
     5aa:	86 95       	lsr	r24
     5ac:	8f 5b       	subi	r24, 0xBF	; 191
     5ae:	82 34       	cpi	r24, 0x42	; 66
     5b0:	51 f1       	breq	.+84     	; 0x606 <DIO_Init_Pin+0x6a>
     5b2:	18 f4       	brcc	.+6      	; 0x5ba <DIO_Init_Pin+0x1e>
     5b4:	81 34       	cpi	r24, 0x41	; 65
     5b6:	41 f0       	breq	.+16     	; 0x5c8 <DIO_Init_Pin+0x2c>
     5b8:	85 c0       	rjmp	.+266    	; 0x6c4 <DIO_Init_Pin+0x128>
     5ba:	83 34       	cpi	r24, 0x43	; 67
     5bc:	09 f4       	brne	.+2      	; 0x5c0 <DIO_Init_Pin+0x24>
     5be:	42 c0       	rjmp	.+132    	; 0x644 <DIO_Init_Pin+0xa8>
     5c0:	84 34       	cpi	r24, 0x44	; 68
     5c2:	09 f4       	brne	.+2      	; 0x5c6 <DIO_Init_Pin+0x2a>
     5c4:	5e c0       	rjmp	.+188    	; 0x682 <DIO_Init_Pin+0xe6>
     5c6:	7e c0       	rjmp	.+252    	; 0x6c4 <DIO_Init_Pin+0x128>
     5c8:	61 11       	cpse	r22, r1
     5ca:	0f c0       	rjmp	.+30     	; 0x5ea <DIO_Init_Pin+0x4e>
     5cc:	4a b3       	in	r20, 0x1a	; 26
     5ce:	21 e0       	ldi	r18, 0x01	; 1
     5d0:	30 e0       	ldi	r19, 0x00	; 0
     5d2:	b9 01       	movw	r22, r18
     5d4:	02 c0       	rjmp	.+4      	; 0x5da <DIO_Init_Pin+0x3e>
     5d6:	66 0f       	add	r22, r22
     5d8:	77 1f       	adc	r23, r23
     5da:	9a 95       	dec	r25
     5dc:	e2 f7       	brpl	.-8      	; 0x5d6 <DIO_Init_Pin+0x3a>
     5de:	cb 01       	movw	r24, r22
     5e0:	80 95       	com	r24
     5e2:	84 23       	and	r24, r20
     5e4:	8a bb       	out	0x1a, r24	; 26
     5e6:	80 e0       	ldi	r24, 0x00	; 0
     5e8:	08 95       	ret
     5ea:	4a b3       	in	r20, 0x1a	; 26
     5ec:	21 e0       	ldi	r18, 0x01	; 1
     5ee:	30 e0       	ldi	r19, 0x00	; 0
     5f0:	b9 01       	movw	r22, r18
     5f2:	02 c0       	rjmp	.+4      	; 0x5f8 <DIO_Init_Pin+0x5c>
     5f4:	66 0f       	add	r22, r22
     5f6:	77 1f       	adc	r23, r23
     5f8:	9a 95       	dec	r25
     5fa:	e2 f7       	brpl	.-8      	; 0x5f4 <DIO_Init_Pin+0x58>
     5fc:	cb 01       	movw	r24, r22
     5fe:	84 2b       	or	r24, r20
     600:	8a bb       	out	0x1a, r24	; 26
     602:	80 e0       	ldi	r24, 0x00	; 0
     604:	08 95       	ret
     606:	61 11       	cpse	r22, r1
     608:	0f c0       	rjmp	.+30     	; 0x628 <DIO_Init_Pin+0x8c>
     60a:	47 b3       	in	r20, 0x17	; 23
     60c:	21 e0       	ldi	r18, 0x01	; 1
     60e:	30 e0       	ldi	r19, 0x00	; 0
     610:	b9 01       	movw	r22, r18
     612:	02 c0       	rjmp	.+4      	; 0x618 <DIO_Init_Pin+0x7c>
     614:	66 0f       	add	r22, r22
     616:	77 1f       	adc	r23, r23
     618:	9a 95       	dec	r25
     61a:	e2 f7       	brpl	.-8      	; 0x614 <DIO_Init_Pin+0x78>
     61c:	cb 01       	movw	r24, r22
     61e:	80 95       	com	r24
     620:	84 23       	and	r24, r20
     622:	87 bb       	out	0x17, r24	; 23
     624:	80 e0       	ldi	r24, 0x00	; 0
     626:	08 95       	ret
     628:	47 b3       	in	r20, 0x17	; 23
     62a:	21 e0       	ldi	r18, 0x01	; 1
     62c:	30 e0       	ldi	r19, 0x00	; 0
     62e:	b9 01       	movw	r22, r18
     630:	02 c0       	rjmp	.+4      	; 0x636 <DIO_Init_Pin+0x9a>
     632:	66 0f       	add	r22, r22
     634:	77 1f       	adc	r23, r23
     636:	9a 95       	dec	r25
     638:	e2 f7       	brpl	.-8      	; 0x632 <DIO_Init_Pin+0x96>
     63a:	cb 01       	movw	r24, r22
     63c:	84 2b       	or	r24, r20
     63e:	87 bb       	out	0x17, r24	; 23
     640:	80 e0       	ldi	r24, 0x00	; 0
     642:	08 95       	ret
     644:	61 11       	cpse	r22, r1
     646:	0f c0       	rjmp	.+30     	; 0x666 <DIO_Init_Pin+0xca>
     648:	44 b3       	in	r20, 0x14	; 20
     64a:	21 e0       	ldi	r18, 0x01	; 1
     64c:	30 e0       	ldi	r19, 0x00	; 0
     64e:	b9 01       	movw	r22, r18
     650:	02 c0       	rjmp	.+4      	; 0x656 <DIO_Init_Pin+0xba>
     652:	66 0f       	add	r22, r22
     654:	77 1f       	adc	r23, r23
     656:	9a 95       	dec	r25
     658:	e2 f7       	brpl	.-8      	; 0x652 <DIO_Init_Pin+0xb6>
     65a:	cb 01       	movw	r24, r22
     65c:	80 95       	com	r24
     65e:	84 23       	and	r24, r20
     660:	84 bb       	out	0x14, r24	; 20
     662:	80 e0       	ldi	r24, 0x00	; 0
     664:	08 95       	ret
     666:	44 b3       	in	r20, 0x14	; 20
     668:	21 e0       	ldi	r18, 0x01	; 1
     66a:	30 e0       	ldi	r19, 0x00	; 0
     66c:	b9 01       	movw	r22, r18
     66e:	02 c0       	rjmp	.+4      	; 0x674 <DIO_Init_Pin+0xd8>
     670:	66 0f       	add	r22, r22
     672:	77 1f       	adc	r23, r23
     674:	9a 95       	dec	r25
     676:	e2 f7       	brpl	.-8      	; 0x670 <DIO_Init_Pin+0xd4>
     678:	cb 01       	movw	r24, r22
     67a:	84 2b       	or	r24, r20
     67c:	84 bb       	out	0x14, r24	; 20
     67e:	80 e0       	ldi	r24, 0x00	; 0
     680:	08 95       	ret
     682:	61 11       	cpse	r22, r1
     684:	0f c0       	rjmp	.+30     	; 0x6a4 <DIO_Init_Pin+0x108>
     686:	41 b3       	in	r20, 0x11	; 17
     688:	21 e0       	ldi	r18, 0x01	; 1
     68a:	30 e0       	ldi	r19, 0x00	; 0
     68c:	b9 01       	movw	r22, r18
     68e:	02 c0       	rjmp	.+4      	; 0x694 <DIO_Init_Pin+0xf8>
     690:	66 0f       	add	r22, r22
     692:	77 1f       	adc	r23, r23
     694:	9a 95       	dec	r25
     696:	e2 f7       	brpl	.-8      	; 0x690 <DIO_Init_Pin+0xf4>
     698:	cb 01       	movw	r24, r22
     69a:	80 95       	com	r24
     69c:	84 23       	and	r24, r20
     69e:	81 bb       	out	0x11, r24	; 17
     6a0:	80 e0       	ldi	r24, 0x00	; 0
     6a2:	08 95       	ret
     6a4:	41 b3       	in	r20, 0x11	; 17
     6a6:	21 e0       	ldi	r18, 0x01	; 1
     6a8:	30 e0       	ldi	r19, 0x00	; 0
     6aa:	b9 01       	movw	r22, r18
     6ac:	02 c0       	rjmp	.+4      	; 0x6b2 <DIO_Init_Pin+0x116>
     6ae:	66 0f       	add	r22, r22
     6b0:	77 1f       	adc	r23, r23
     6b2:	9a 95       	dec	r25
     6b4:	e2 f7       	brpl	.-8      	; 0x6ae <DIO_Init_Pin+0x112>
     6b6:	cb 01       	movw	r24, r22
     6b8:	84 2b       	or	r24, r20
     6ba:	81 bb       	out	0x11, r24	; 17
     6bc:	80 e0       	ldi	r24, 0x00	; 0
     6be:	08 95       	ret
     6c0:	81 e0       	ldi	r24, 0x01	; 1
     6c2:	08 95       	ret
     6c4:	81 e0       	ldi	r24, 0x01	; 1
     6c6:	08 95       	ret

000006c8 <DIO_Read_Pin>:
     6c8:	80 32       	cpi	r24, 0x20	; 32
     6ca:	08 f0       	brcs	.+2      	; 0x6ce <DIO_Read_Pin+0x6>
     6cc:	4d c0       	rjmp	.+154    	; 0x768 <DIO_Read_Pin+0xa0>
     6ce:	98 2f       	mov	r25, r24
     6d0:	97 70       	andi	r25, 0x07	; 7
     6d2:	86 95       	lsr	r24
     6d4:	86 95       	lsr	r24
     6d6:	86 95       	lsr	r24
     6d8:	8f 5b       	subi	r24, 0xBF	; 191
     6da:	82 34       	cpi	r24, 0x42	; 66
     6dc:	c1 f0       	breq	.+48     	; 0x70e <DIO_Read_Pin+0x46>
     6de:	18 f4       	brcc	.+6      	; 0x6e6 <DIO_Read_Pin+0x1e>
     6e0:	81 34       	cpi	r24, 0x41	; 65
     6e2:	31 f0       	breq	.+12     	; 0x6f0 <DIO_Read_Pin+0x28>
     6e4:	43 c0       	rjmp	.+134    	; 0x76c <DIO_Read_Pin+0xa4>
     6e6:	83 34       	cpi	r24, 0x43	; 67
     6e8:	09 f1       	breq	.+66     	; 0x72c <DIO_Read_Pin+0x64>
     6ea:	84 34       	cpi	r24, 0x44	; 68
     6ec:	71 f1       	breq	.+92     	; 0x74a <DIO_Read_Pin+0x82>
     6ee:	3e c0       	rjmp	.+124    	; 0x76c <DIO_Read_Pin+0xa4>
     6f0:	89 b3       	in	r24, 0x19	; 25
     6f2:	28 2f       	mov	r18, r24
     6f4:	30 e0       	ldi	r19, 0x00	; 0
     6f6:	a9 01       	movw	r20, r18
     6f8:	02 c0       	rjmp	.+4      	; 0x6fe <DIO_Read_Pin+0x36>
     6fa:	55 95       	asr	r21
     6fc:	47 95       	ror	r20
     6fe:	9a 95       	dec	r25
     700:	e2 f7       	brpl	.-8      	; 0x6fa <DIO_Read_Pin+0x32>
     702:	ca 01       	movw	r24, r20
     704:	81 70       	andi	r24, 0x01	; 1
     706:	fb 01       	movw	r30, r22
     708:	80 83       	st	Z, r24
     70a:	80 e0       	ldi	r24, 0x00	; 0
     70c:	08 95       	ret
     70e:	86 b3       	in	r24, 0x16	; 22
     710:	28 2f       	mov	r18, r24
     712:	30 e0       	ldi	r19, 0x00	; 0
     714:	a9 01       	movw	r20, r18
     716:	02 c0       	rjmp	.+4      	; 0x71c <DIO_Read_Pin+0x54>
     718:	55 95       	asr	r21
     71a:	47 95       	ror	r20
     71c:	9a 95       	dec	r25
     71e:	e2 f7       	brpl	.-8      	; 0x718 <DIO_Read_Pin+0x50>
     720:	ca 01       	movw	r24, r20
     722:	81 70       	andi	r24, 0x01	; 1
     724:	fb 01       	movw	r30, r22
     726:	80 83       	st	Z, r24
     728:	80 e0       	ldi	r24, 0x00	; 0
     72a:	08 95       	ret
     72c:	83 b3       	in	r24, 0x13	; 19
     72e:	28 2f       	mov	r18, r24
     730:	30 e0       	ldi	r19, 0x00	; 0
     732:	a9 01       	movw	r20, r18
     734:	02 c0       	rjmp	.+4      	; 0x73a <DIO_Read_Pin+0x72>
     736:	55 95       	asr	r21
     738:	47 95       	ror	r20
     73a:	9a 95       	dec	r25
     73c:	e2 f7       	brpl	.-8      	; 0x736 <DIO_Read_Pin+0x6e>
     73e:	ca 01       	movw	r24, r20
     740:	81 70       	andi	r24, 0x01	; 1
     742:	fb 01       	movw	r30, r22
     744:	80 83       	st	Z, r24
     746:	80 e0       	ldi	r24, 0x00	; 0
     748:	08 95       	ret
     74a:	80 b3       	in	r24, 0x10	; 16
     74c:	28 2f       	mov	r18, r24
     74e:	30 e0       	ldi	r19, 0x00	; 0
     750:	a9 01       	movw	r20, r18
     752:	02 c0       	rjmp	.+4      	; 0x758 <DIO_Read_Pin+0x90>
     754:	55 95       	asr	r21
     756:	47 95       	ror	r20
     758:	9a 95       	dec	r25
     75a:	e2 f7       	brpl	.-8      	; 0x754 <DIO_Read_Pin+0x8c>
     75c:	ca 01       	movw	r24, r20
     75e:	81 70       	andi	r24, 0x01	; 1
     760:	fb 01       	movw	r30, r22
     762:	80 83       	st	Z, r24
     764:	80 e0       	ldi	r24, 0x00	; 0
     766:	08 95       	ret
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	08 95       	ret
     76c:	81 e0       	ldi	r24, 0x01	; 1
     76e:	08 95       	ret

00000770 <DIO_toggle_Pin>:
uinteg8_t DIO_toggle_Pin(uinteg8_t pin)
{
	uinteg8_t por;
	if(pin>=PinsNeeded || pin>=No_of_pins ) return DIO_ERROR_NOK;
     770:	80 32       	cpi	r24, 0x20	; 32
     772:	08 f0       	brcs	.+2      	; 0x776 <DIO_toggle_Pin+0x6>
     774:	49 c0       	rjmp	.+146    	; 0x808 <DIO_toggle_Pin+0x98>
	else
	{
		por='A'+pin/PortSize;
		pin=pin%PortSize;
     776:	98 2f       	mov	r25, r24
     778:	97 70       	andi	r25, 0x07	; 7
	}
	
	switch(por)
     77a:	86 95       	lsr	r24
     77c:	86 95       	lsr	r24
     77e:	86 95       	lsr	r24
     780:	8f 5b       	subi	r24, 0xBF	; 191
     782:	82 34       	cpi	r24, 0x42	; 66
     784:	b9 f0       	breq	.+46     	; 0x7b4 <DIO_toggle_Pin+0x44>
     786:	18 f4       	brcc	.+6      	; 0x78e <DIO_toggle_Pin+0x1e>
     788:	81 34       	cpi	r24, 0x41	; 65
     78a:	31 f0       	breq	.+12     	; 0x798 <DIO_toggle_Pin+0x28>
     78c:	3f c0       	rjmp	.+126    	; 0x80c <DIO_toggle_Pin+0x9c>
     78e:	83 34       	cpi	r24, 0x43	; 67
     790:	f9 f0       	breq	.+62     	; 0x7d0 <DIO_toggle_Pin+0x60>
     792:	84 34       	cpi	r24, 0x44	; 68
     794:	59 f1       	breq	.+86     	; 0x7ec <DIO_toggle_Pin+0x7c>
     796:	3a c0       	rjmp	.+116    	; 0x80c <DIO_toggle_Pin+0x9c>
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
     798:	4b b3       	in	r20, 0x1b	; 27
     79a:	21 e0       	ldi	r18, 0x01	; 1
     79c:	30 e0       	ldi	r19, 0x00	; 0
     79e:	b9 01       	movw	r22, r18
     7a0:	02 c0       	rjmp	.+4      	; 0x7a6 <DIO_toggle_Pin+0x36>
     7a2:	66 0f       	add	r22, r22
     7a4:	77 1f       	adc	r23, r23
     7a6:	9a 95       	dec	r25
     7a8:	e2 f7       	brpl	.-8      	; 0x7a2 <DIO_toggle_Pin+0x32>
     7aa:	cb 01       	movw	r24, r22
     7ac:	84 27       	eor	r24, r20
     7ae:	8b bb       	out	0x1b, r24	; 27
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     7b0:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	switch(por)
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
     7b2:	08 95       	ret
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
     7b4:	48 b3       	in	r20, 0x18	; 24
     7b6:	21 e0       	ldi	r18, 0x01	; 1
     7b8:	30 e0       	ldi	r19, 0x00	; 0
     7ba:	b9 01       	movw	r22, r18
     7bc:	02 c0       	rjmp	.+4      	; 0x7c2 <DIO_toggle_Pin+0x52>
     7be:	66 0f       	add	r22, r22
     7c0:	77 1f       	adc	r23, r23
     7c2:	9a 95       	dec	r25
     7c4:	e2 f7       	brpl	.-8      	; 0x7be <DIO_toggle_Pin+0x4e>
     7c6:	cb 01       	movw	r24, r22
     7c8:	84 27       	eor	r24, r20
     7ca:	88 bb       	out	0x18, r24	; 24
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     7cc:	80 e0       	ldi	r24, 0x00	; 0
	switch(por)
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
     7ce:	08 95       	ret
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
     7d0:	45 b3       	in	r20, 0x15	; 21
     7d2:	21 e0       	ldi	r18, 0x01	; 1
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	b9 01       	movw	r22, r18
     7d8:	02 c0       	rjmp	.+4      	; 0x7de <DIO_toggle_Pin+0x6e>
     7da:	66 0f       	add	r22, r22
     7dc:	77 1f       	adc	r23, r23
     7de:	9a 95       	dec	r25
     7e0:	e2 f7       	brpl	.-8      	; 0x7da <DIO_toggle_Pin+0x6a>
     7e2:	cb 01       	movw	r24, r22
     7e4:	84 27       	eor	r24, r20
     7e6:	85 bb       	out	0x15, r24	; 21
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     7e8:	80 e0       	ldi	r24, 0x00	; 0
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
			 break;
     7ea:	08 95       	ret
		case 'D':TOGGLE_BIT(WriteRegisterD,pin);
     7ec:	42 b3       	in	r20, 0x12	; 18
     7ee:	21 e0       	ldi	r18, 0x01	; 1
     7f0:	30 e0       	ldi	r19, 0x00	; 0
     7f2:	b9 01       	movw	r22, r18
     7f4:	02 c0       	rjmp	.+4      	; 0x7fa <DIO_toggle_Pin+0x8a>
     7f6:	66 0f       	add	r22, r22
     7f8:	77 1f       	adc	r23, r23
     7fa:	9a 95       	dec	r25
     7fc:	e2 f7       	brpl	.-8      	; 0x7f6 <DIO_toggle_Pin+0x86>
     7fe:	cb 01       	movw	r24, r22
     800:	84 27       	eor	r24, r20
     802:	82 bb       	out	0x12, r24	; 18
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     804:	80 e0       	ldi	r24, 0x00	; 0
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
			 break;
		case 'D':TOGGLE_BIT(WriteRegisterD,pin);
			 break;
     806:	08 95       	ret
return DIO_ERROR_OK;
}
uinteg8_t DIO_toggle_Pin(uinteg8_t pin)
{
	uinteg8_t por;
	if(pin>=PinsNeeded || pin>=No_of_pins ) return DIO_ERROR_NOK;
     808:	81 e0       	ldi	r24, 0x01	; 1
     80a:	08 95       	ret
			 break;
		case 'G':TOGGLE_BIT(PORTG,pin);
			 break;
#endif
		default :
		return DIO_ERROR_NOK;
     80c:	81 e0       	ldi	r24, 0x01	; 1
		break;
		
	}
	return DIO_ERROR_OK;
}
     80e:	08 95       	ret

00000810 <Debug_By_Toggle>:
#define Debug_By_Toggle_State_Other_times 1
#define Debug_By_Toggle_State_Nothing     2


void Debug_By_Toggle(uinteg8_t u8_Pin)
{
     810:	cf 93       	push	r28
     812:	c8 2f       	mov	r28, r24
	DIO_Init_Pin(u8_Pin,1);
     814:	61 e0       	ldi	r22, 0x01	; 1
     816:	0e 94 ce 02 	call	0x59c	; 0x59c <DIO_Init_Pin>
	DIO_toggle_Pin(u8_Pin);
     81a:	8c 2f       	mov	r24, r28
     81c:	0e 94 b8 03 	call	0x770	; 0x770 <DIO_toggle_Pin>
     820:	cf 91       	pop	r28
     822:	08 95       	ret

00000824 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     824:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     826:	03 96       	adiw	r24, 0x03	; 3
     828:	92 83       	std	Z+2, r25	; 0x02
     82a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     82c:	2f ef       	ldi	r18, 0xFF	; 255
     82e:	3f ef       	ldi	r19, 0xFF	; 255
     830:	34 83       	std	Z+4, r19	; 0x04
     832:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     834:	96 83       	std	Z+6, r25	; 0x06
     836:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     838:	90 87       	std	Z+8, r25	; 0x08
     83a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     83c:	10 82       	st	Z, r1
     83e:	08 95       	ret

00000840 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     840:	fc 01       	movw	r30, r24
     842:	11 86       	std	Z+9, r1	; 0x09
     844:	10 86       	std	Z+8, r1	; 0x08
     846:	08 95       	ret

00000848 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     848:	cf 93       	push	r28
     84a:	df 93       	push	r29
     84c:	9c 01       	movw	r18, r24
     84e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     850:	dc 01       	movw	r26, r24
     852:	11 96       	adiw	r26, 0x01	; 1
     854:	cd 91       	ld	r28, X+
     856:	dc 91       	ld	r29, X
     858:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     85a:	d3 83       	std	Z+3, r29	; 0x03
     85c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     85e:	8c 81       	ldd	r24, Y+4	; 0x04
     860:	9d 81       	ldd	r25, Y+5	; 0x05
     862:	95 83       	std	Z+5, r25	; 0x05
     864:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     866:	8c 81       	ldd	r24, Y+4	; 0x04
     868:	9d 81       	ldd	r25, Y+5	; 0x05
     86a:	dc 01       	movw	r26, r24
     86c:	13 96       	adiw	r26, 0x03	; 3
     86e:	7c 93       	st	X, r23
     870:	6e 93       	st	-X, r22
     872:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     874:	7d 83       	std	Y+5, r23	; 0x05
     876:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     878:	31 87       	std	Z+9, r19	; 0x09
     87a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     87c:	f9 01       	movw	r30, r18
     87e:	80 81       	ld	r24, Z
     880:	8f 5f       	subi	r24, 0xFF	; 255
     882:	80 83       	st	Z, r24
}
     884:	df 91       	pop	r29
     886:	cf 91       	pop	r28
     888:	08 95       	ret

0000088a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     88a:	cf 93       	push	r28
     88c:	df 93       	push	r29
     88e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     890:	48 81       	ld	r20, Y
     892:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     894:	4f 3f       	cpi	r20, 0xFF	; 255
     896:	2f ef       	ldi	r18, 0xFF	; 255
     898:	52 07       	cpc	r21, r18
     89a:	21 f4       	brne	.+8      	; 0x8a4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     89c:	fc 01       	movw	r30, r24
     89e:	a7 81       	ldd	r26, Z+7	; 0x07
     8a0:	b0 85       	ldd	r27, Z+8	; 0x08
     8a2:	0d c0       	rjmp	.+26     	; 0x8be <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     8a4:	dc 01       	movw	r26, r24
     8a6:	13 96       	adiw	r26, 0x03	; 3
     8a8:	01 c0       	rjmp	.+2      	; 0x8ac <vListInsert+0x22>
     8aa:	df 01       	movw	r26, r30
     8ac:	12 96       	adiw	r26, 0x02	; 2
     8ae:	ed 91       	ld	r30, X+
     8b0:	fc 91       	ld	r31, X
     8b2:	13 97       	sbiw	r26, 0x03	; 3
     8b4:	20 81       	ld	r18, Z
     8b6:	31 81       	ldd	r19, Z+1	; 0x01
     8b8:	42 17       	cp	r20, r18
     8ba:	53 07       	cpc	r21, r19
     8bc:	b0 f7       	brcc	.-20     	; 0x8aa <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     8be:	12 96       	adiw	r26, 0x02	; 2
     8c0:	ed 91       	ld	r30, X+
     8c2:	fc 91       	ld	r31, X
     8c4:	13 97       	sbiw	r26, 0x03	; 3
     8c6:	fb 83       	std	Y+3, r31	; 0x03
     8c8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     8ca:	d5 83       	std	Z+5, r29	; 0x05
     8cc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     8ce:	bd 83       	std	Y+5, r27	; 0x05
     8d0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     8d2:	13 96       	adiw	r26, 0x03	; 3
     8d4:	dc 93       	st	X, r29
     8d6:	ce 93       	st	-X, r28
     8d8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     8da:	99 87       	std	Y+9, r25	; 0x09
     8dc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8de:	fc 01       	movw	r30, r24
     8e0:	20 81       	ld	r18, Z
     8e2:	2f 5f       	subi	r18, 0xFF	; 255
     8e4:	20 83       	st	Z, r18
}
     8e6:	df 91       	pop	r29
     8e8:	cf 91       	pop	r28
     8ea:	08 95       	ret

000008ec <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     8ec:	cf 93       	push	r28
     8ee:	df 93       	push	r29
     8f0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     8f2:	a0 85       	ldd	r26, Z+8	; 0x08
     8f4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     8f6:	c2 81       	ldd	r28, Z+2	; 0x02
     8f8:	d3 81       	ldd	r29, Z+3	; 0x03
     8fa:	84 81       	ldd	r24, Z+4	; 0x04
     8fc:	95 81       	ldd	r25, Z+5	; 0x05
     8fe:	9d 83       	std	Y+5, r25	; 0x05
     900:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     902:	c4 81       	ldd	r28, Z+4	; 0x04
     904:	d5 81       	ldd	r29, Z+5	; 0x05
     906:	82 81       	ldd	r24, Z+2	; 0x02
     908:	93 81       	ldd	r25, Z+3	; 0x03
     90a:	9b 83       	std	Y+3, r25	; 0x03
     90c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     90e:	11 96       	adiw	r26, 0x01	; 1
     910:	8d 91       	ld	r24, X+
     912:	9c 91       	ld	r25, X
     914:	12 97       	sbiw	r26, 0x02	; 2
     916:	e8 17       	cp	r30, r24
     918:	f9 07       	cpc	r31, r25
     91a:	31 f4       	brne	.+12     	; 0x928 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     91c:	84 81       	ldd	r24, Z+4	; 0x04
     91e:	95 81       	ldd	r25, Z+5	; 0x05
     920:	12 96       	adiw	r26, 0x02	; 2
     922:	9c 93       	st	X, r25
     924:	8e 93       	st	-X, r24
     926:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     928:	11 86       	std	Z+9, r1	; 0x09
     92a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     92c:	8c 91       	ld	r24, X
     92e:	81 50       	subi	r24, 0x01	; 1
     930:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     932:	8c 91       	ld	r24, X
}
     934:	df 91       	pop	r29
     936:	cf 91       	pop	r28
     938:	08 95       	ret

0000093a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     93a:	31 e1       	ldi	r19, 0x11	; 17
     93c:	fc 01       	movw	r30, r24
     93e:	30 83       	st	Z, r19
     940:	31 97       	sbiw	r30, 0x01	; 1
     942:	22 e2       	ldi	r18, 0x22	; 34
     944:	20 83       	st	Z, r18
     946:	31 97       	sbiw	r30, 0x01	; 1
     948:	a3 e3       	ldi	r26, 0x33	; 51
     94a:	a0 83       	st	Z, r26
     94c:	31 97       	sbiw	r30, 0x01	; 1
     94e:	60 83       	st	Z, r22
     950:	31 97       	sbiw	r30, 0x01	; 1
     952:	70 83       	st	Z, r23
     954:	31 97       	sbiw	r30, 0x01	; 1
     956:	10 82       	st	Z, r1
     958:	31 97       	sbiw	r30, 0x01	; 1
     95a:	60 e8       	ldi	r22, 0x80	; 128
     95c:	60 83       	st	Z, r22
     95e:	31 97       	sbiw	r30, 0x01	; 1
     960:	10 82       	st	Z, r1
     962:	31 97       	sbiw	r30, 0x01	; 1
     964:	62 e0       	ldi	r22, 0x02	; 2
     966:	60 83       	st	Z, r22
     968:	31 97       	sbiw	r30, 0x01	; 1
     96a:	63 e0       	ldi	r22, 0x03	; 3
     96c:	60 83       	st	Z, r22
     96e:	31 97       	sbiw	r30, 0x01	; 1
     970:	64 e0       	ldi	r22, 0x04	; 4
     972:	60 83       	st	Z, r22
     974:	31 97       	sbiw	r30, 0x01	; 1
     976:	65 e0       	ldi	r22, 0x05	; 5
     978:	60 83       	st	Z, r22
     97a:	31 97       	sbiw	r30, 0x01	; 1
     97c:	66 e0       	ldi	r22, 0x06	; 6
     97e:	60 83       	st	Z, r22
     980:	31 97       	sbiw	r30, 0x01	; 1
     982:	67 e0       	ldi	r22, 0x07	; 7
     984:	60 83       	st	Z, r22
     986:	31 97       	sbiw	r30, 0x01	; 1
     988:	68 e0       	ldi	r22, 0x08	; 8
     98a:	60 83       	st	Z, r22
     98c:	31 97       	sbiw	r30, 0x01	; 1
     98e:	69 e0       	ldi	r22, 0x09	; 9
     990:	60 83       	st	Z, r22
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	60 e1       	ldi	r22, 0x10	; 16
     996:	60 83       	st	Z, r22
     998:	31 97       	sbiw	r30, 0x01	; 1
     99a:	30 83       	st	Z, r19
     99c:	31 97       	sbiw	r30, 0x01	; 1
     99e:	32 e1       	ldi	r19, 0x12	; 18
     9a0:	30 83       	st	Z, r19
     9a2:	31 97       	sbiw	r30, 0x01	; 1
     9a4:	33 e1       	ldi	r19, 0x13	; 19
     9a6:	30 83       	st	Z, r19
     9a8:	31 97       	sbiw	r30, 0x01	; 1
     9aa:	34 e1       	ldi	r19, 0x14	; 20
     9ac:	30 83       	st	Z, r19
     9ae:	31 97       	sbiw	r30, 0x01	; 1
     9b0:	35 e1       	ldi	r19, 0x15	; 21
     9b2:	30 83       	st	Z, r19
     9b4:	31 97       	sbiw	r30, 0x01	; 1
     9b6:	36 e1       	ldi	r19, 0x16	; 22
     9b8:	30 83       	st	Z, r19
     9ba:	31 97       	sbiw	r30, 0x01	; 1
     9bc:	37 e1       	ldi	r19, 0x17	; 23
     9be:	30 83       	st	Z, r19
     9c0:	31 97       	sbiw	r30, 0x01	; 1
     9c2:	38 e1       	ldi	r19, 0x18	; 24
     9c4:	30 83       	st	Z, r19
     9c6:	31 97       	sbiw	r30, 0x01	; 1
     9c8:	39 e1       	ldi	r19, 0x19	; 25
     9ca:	30 83       	st	Z, r19
     9cc:	31 97       	sbiw	r30, 0x01	; 1
     9ce:	30 e2       	ldi	r19, 0x20	; 32
     9d0:	30 83       	st	Z, r19
     9d2:	31 97       	sbiw	r30, 0x01	; 1
     9d4:	31 e2       	ldi	r19, 0x21	; 33
     9d6:	30 83       	st	Z, r19
     9d8:	31 97       	sbiw	r30, 0x01	; 1
     9da:	20 83       	st	Z, r18
     9dc:	31 97       	sbiw	r30, 0x01	; 1
     9de:	23 e2       	ldi	r18, 0x23	; 35
     9e0:	20 83       	st	Z, r18
     9e2:	31 97       	sbiw	r30, 0x01	; 1
     9e4:	40 83       	st	Z, r20
     9e6:	31 97       	sbiw	r30, 0x01	; 1
     9e8:	50 83       	st	Z, r21
     9ea:	31 97       	sbiw	r30, 0x01	; 1
     9ec:	26 e2       	ldi	r18, 0x26	; 38
     9ee:	20 83       	st	Z, r18
     9f0:	31 97       	sbiw	r30, 0x01	; 1
     9f2:	27 e2       	ldi	r18, 0x27	; 39
     9f4:	20 83       	st	Z, r18
     9f6:	31 97       	sbiw	r30, 0x01	; 1
     9f8:	28 e2       	ldi	r18, 0x28	; 40
     9fa:	20 83       	st	Z, r18
     9fc:	31 97       	sbiw	r30, 0x01	; 1
     9fe:	29 e2       	ldi	r18, 0x29	; 41
     a00:	20 83       	st	Z, r18
     a02:	31 97       	sbiw	r30, 0x01	; 1
     a04:	20 e3       	ldi	r18, 0x30	; 48
     a06:	20 83       	st	Z, r18
     a08:	31 97       	sbiw	r30, 0x01	; 1
     a0a:	21 e3       	ldi	r18, 0x31	; 49
     a0c:	20 83       	st	Z, r18
     a0e:	86 97       	sbiw	r24, 0x26	; 38
     a10:	08 95       	ret

00000a12 <xPortStartScheduler>:
     a12:	1b bc       	out	0x2b, r1	; 43
     a14:	8c e7       	ldi	r24, 0x7C	; 124
     a16:	8a bd       	out	0x2a, r24	; 42
     a18:	8b e0       	ldi	r24, 0x0B	; 11
     a1a:	8e bd       	out	0x2e, r24	; 46
     a1c:	89 b7       	in	r24, 0x39	; 57
     a1e:	80 61       	ori	r24, 0x10	; 16
     a20:	89 bf       	out	0x39, r24	; 57
     a22:	a0 91 0c 07 	lds	r26, 0x070C	; 0x80070c <pxCurrentTCB>
     a26:	b0 91 0d 07 	lds	r27, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
     a2a:	cd 91       	ld	r28, X+
     a2c:	cd bf       	out	0x3d, r28	; 61
     a2e:	dd 91       	ld	r29, X+
     a30:	de bf       	out	0x3e, r29	; 62
     a32:	ff 91       	pop	r31
     a34:	ef 91       	pop	r30
     a36:	df 91       	pop	r29
     a38:	cf 91       	pop	r28
     a3a:	bf 91       	pop	r27
     a3c:	af 91       	pop	r26
     a3e:	9f 91       	pop	r25
     a40:	8f 91       	pop	r24
     a42:	7f 91       	pop	r23
     a44:	6f 91       	pop	r22
     a46:	5f 91       	pop	r21
     a48:	4f 91       	pop	r20
     a4a:	3f 91       	pop	r19
     a4c:	2f 91       	pop	r18
     a4e:	1f 91       	pop	r17
     a50:	0f 91       	pop	r16
     a52:	ff 90       	pop	r15
     a54:	ef 90       	pop	r14
     a56:	df 90       	pop	r13
     a58:	cf 90       	pop	r12
     a5a:	bf 90       	pop	r11
     a5c:	af 90       	pop	r10
     a5e:	9f 90       	pop	r9
     a60:	8f 90       	pop	r8
     a62:	7f 90       	pop	r7
     a64:	6f 90       	pop	r6
     a66:	5f 90       	pop	r5
     a68:	4f 90       	pop	r4
     a6a:	3f 90       	pop	r3
     a6c:	2f 90       	pop	r2
     a6e:	1f 90       	pop	r1
     a70:	0f 90       	pop	r0
     a72:	0f be       	out	0x3f, r0	; 63
     a74:	0f 90       	pop	r0
     a76:	08 95       	ret
     a78:	81 e0       	ldi	r24, 0x01	; 1
     a7a:	08 95       	ret

00000a7c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     a7c:	0f 92       	push	r0
     a7e:	0f b6       	in	r0, 0x3f	; 63
     a80:	f8 94       	cli
     a82:	0f 92       	push	r0
     a84:	1f 92       	push	r1
     a86:	11 24       	eor	r1, r1
     a88:	2f 92       	push	r2
     a8a:	3f 92       	push	r3
     a8c:	4f 92       	push	r4
     a8e:	5f 92       	push	r5
     a90:	6f 92       	push	r6
     a92:	7f 92       	push	r7
     a94:	8f 92       	push	r8
     a96:	9f 92       	push	r9
     a98:	af 92       	push	r10
     a9a:	bf 92       	push	r11
     a9c:	cf 92       	push	r12
     a9e:	df 92       	push	r13
     aa0:	ef 92       	push	r14
     aa2:	ff 92       	push	r15
     aa4:	0f 93       	push	r16
     aa6:	1f 93       	push	r17
     aa8:	2f 93       	push	r18
     aaa:	3f 93       	push	r19
     aac:	4f 93       	push	r20
     aae:	5f 93       	push	r21
     ab0:	6f 93       	push	r22
     ab2:	7f 93       	push	r23
     ab4:	8f 93       	push	r24
     ab6:	9f 93       	push	r25
     ab8:	af 93       	push	r26
     aba:	bf 93       	push	r27
     abc:	cf 93       	push	r28
     abe:	df 93       	push	r29
     ac0:	ef 93       	push	r30
     ac2:	ff 93       	push	r31
     ac4:	a0 91 0c 07 	lds	r26, 0x070C	; 0x80070c <pxCurrentTCB>
     ac8:	b0 91 0d 07 	lds	r27, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
     acc:	0d b6       	in	r0, 0x3d	; 61
     ace:	0d 92       	st	X+, r0
     ad0:	0e b6       	in	r0, 0x3e	; 62
     ad2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     ad4:	0e 94 4e 0c 	call	0x189c	; 0x189c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ad8:	a0 91 0c 07 	lds	r26, 0x070C	; 0x80070c <pxCurrentTCB>
     adc:	b0 91 0d 07 	lds	r27, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
     ae0:	cd 91       	ld	r28, X+
     ae2:	cd bf       	out	0x3d, r28	; 61
     ae4:	dd 91       	ld	r29, X+
     ae6:	de bf       	out	0x3e, r29	; 62
     ae8:	ff 91       	pop	r31
     aea:	ef 91       	pop	r30
     aec:	df 91       	pop	r29
     aee:	cf 91       	pop	r28
     af0:	bf 91       	pop	r27
     af2:	af 91       	pop	r26
     af4:	9f 91       	pop	r25
     af6:	8f 91       	pop	r24
     af8:	7f 91       	pop	r23
     afa:	6f 91       	pop	r22
     afc:	5f 91       	pop	r21
     afe:	4f 91       	pop	r20
     b00:	3f 91       	pop	r19
     b02:	2f 91       	pop	r18
     b04:	1f 91       	pop	r17
     b06:	0f 91       	pop	r16
     b08:	ff 90       	pop	r15
     b0a:	ef 90       	pop	r14
     b0c:	df 90       	pop	r13
     b0e:	cf 90       	pop	r12
     b10:	bf 90       	pop	r11
     b12:	af 90       	pop	r10
     b14:	9f 90       	pop	r9
     b16:	8f 90       	pop	r8
     b18:	7f 90       	pop	r7
     b1a:	6f 90       	pop	r6
     b1c:	5f 90       	pop	r5
     b1e:	4f 90       	pop	r4
     b20:	3f 90       	pop	r3
     b22:	2f 90       	pop	r2
     b24:	1f 90       	pop	r1
     b26:	0f 90       	pop	r0
     b28:	0f be       	out	0x3f, r0	; 63
     b2a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b2c:	08 95       	ret

00000b2e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     b2e:	0f 92       	push	r0
     b30:	0f b6       	in	r0, 0x3f	; 63
     b32:	f8 94       	cli
     b34:	0f 92       	push	r0
     b36:	1f 92       	push	r1
     b38:	11 24       	eor	r1, r1
     b3a:	2f 92       	push	r2
     b3c:	3f 92       	push	r3
     b3e:	4f 92       	push	r4
     b40:	5f 92       	push	r5
     b42:	6f 92       	push	r6
     b44:	7f 92       	push	r7
     b46:	8f 92       	push	r8
     b48:	9f 92       	push	r9
     b4a:	af 92       	push	r10
     b4c:	bf 92       	push	r11
     b4e:	cf 92       	push	r12
     b50:	df 92       	push	r13
     b52:	ef 92       	push	r14
     b54:	ff 92       	push	r15
     b56:	0f 93       	push	r16
     b58:	1f 93       	push	r17
     b5a:	2f 93       	push	r18
     b5c:	3f 93       	push	r19
     b5e:	4f 93       	push	r20
     b60:	5f 93       	push	r21
     b62:	6f 93       	push	r22
     b64:	7f 93       	push	r23
     b66:	8f 93       	push	r24
     b68:	9f 93       	push	r25
     b6a:	af 93       	push	r26
     b6c:	bf 93       	push	r27
     b6e:	cf 93       	push	r28
     b70:	df 93       	push	r29
     b72:	ef 93       	push	r30
     b74:	ff 93       	push	r31
     b76:	a0 91 0c 07 	lds	r26, 0x070C	; 0x80070c <pxCurrentTCB>
     b7a:	b0 91 0d 07 	lds	r27, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
     b7e:	0d b6       	in	r0, 0x3d	; 61
     b80:	0d 92       	st	X+, r0
     b82:	0e b6       	in	r0, 0x3e	; 62
     b84:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     b86:	0e 94 c2 0a 	call	0x1584	; 0x1584 <xTaskIncrementTick>
     b8a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     b8c:	0e 94 4e 0c 	call	0x189c	; 0x189c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     b90:	a0 91 0c 07 	lds	r26, 0x070C	; 0x80070c <pxCurrentTCB>
     b94:	b0 91 0d 07 	lds	r27, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
     b98:	cd 91       	ld	r28, X+
     b9a:	cd bf       	out	0x3d, r28	; 61
     b9c:	dd 91       	ld	r29, X+
     b9e:	de bf       	out	0x3e, r29	; 62
     ba0:	ff 91       	pop	r31
     ba2:	ef 91       	pop	r30
     ba4:	df 91       	pop	r29
     ba6:	cf 91       	pop	r28
     ba8:	bf 91       	pop	r27
     baa:	af 91       	pop	r26
     bac:	9f 91       	pop	r25
     bae:	8f 91       	pop	r24
     bb0:	7f 91       	pop	r23
     bb2:	6f 91       	pop	r22
     bb4:	5f 91       	pop	r21
     bb6:	4f 91       	pop	r20
     bb8:	3f 91       	pop	r19
     bba:	2f 91       	pop	r18
     bbc:	1f 91       	pop	r17
     bbe:	0f 91       	pop	r16
     bc0:	ff 90       	pop	r15
     bc2:	ef 90       	pop	r14
     bc4:	df 90       	pop	r13
     bc6:	cf 90       	pop	r12
     bc8:	bf 90       	pop	r11
     bca:	af 90       	pop	r10
     bcc:	9f 90       	pop	r9
     bce:	8f 90       	pop	r8
     bd0:	7f 90       	pop	r7
     bd2:	6f 90       	pop	r6
     bd4:	5f 90       	pop	r5
     bd6:	4f 90       	pop	r4
     bd8:	3f 90       	pop	r3
     bda:	2f 90       	pop	r2
     bdc:	1f 90       	pop	r1
     bde:	0f 90       	pop	r0
     be0:	0f be       	out	0x3f, r0	; 63
     be2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     be4:	08 95       	ret

00000be6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
     be6:	0e 94 97 05 	call	0xb2e	; 0xb2e <vPortYieldFromTick>
		asm volatile ( "reti" );
     bea:	18 95       	reti

00000bec <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     bec:	cf 93       	push	r28
     bee:	df 93       	push	r29
     bf0:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     bf2:	0e 94 b2 0a 	call	0x1564	; 0x1564 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     bf6:	80 91 bf 00 	lds	r24, 0x00BF	; 0x8000bf <pucAlignedHeap.2084>
     bfa:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <pucAlignedHeap.2084+0x1>
     bfe:	89 2b       	or	r24, r25
     c00:	31 f4       	brne	.+12     	; 0xc0e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     c02:	84 ec       	ldi	r24, 0xC4	; 196
     c04:	90 e0       	ldi	r25, 0x00	; 0
     c06:	90 93 c0 00 	sts	0x00C0, r25	; 0x8000c0 <pucAlignedHeap.2084+0x1>
     c0a:	80 93 bf 00 	sts	0x00BF, r24	; 0x8000bf <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     c0e:	20 91 c1 00 	lds	r18, 0x00C1	; 0x8000c1 <xNextFreeByte>
     c12:	30 91 c2 00 	lds	r19, 0x00C2	; 0x8000c2 <xNextFreeByte+0x1>
     c16:	c9 01       	movw	r24, r18
     c18:	8c 0f       	add	r24, r28
     c1a:	9d 1f       	adc	r25, r29
     c1c:	8b 3d       	cpi	r24, 0xDB	; 219
     c1e:	45 e0       	ldi	r20, 0x05	; 5
     c20:	94 07       	cpc	r25, r20
     c22:	70 f4       	brcc	.+28     	; 0xc40 <pvPortMalloc+0x54>
     c24:	28 17       	cp	r18, r24
     c26:	39 07       	cpc	r19, r25
     c28:	70 f4       	brcc	.+28     	; 0xc46 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     c2a:	c0 91 bf 00 	lds	r28, 0x00BF	; 0x8000bf <pucAlignedHeap.2084>
     c2e:	d0 91 c0 00 	lds	r29, 0x00C0	; 0x8000c0 <pucAlignedHeap.2084+0x1>
     c32:	c2 0f       	add	r28, r18
     c34:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     c36:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <xNextFreeByte+0x1>
     c3a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <xNextFreeByte>
     c3e:	05 c0       	rjmp	.+10     	; 0xc4a <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     c40:	c0 e0       	ldi	r28, 0x00	; 0
     c42:	d0 e0       	ldi	r29, 0x00	; 0
     c44:	02 c0       	rjmp	.+4      	; 0xc4a <pvPortMalloc+0x5e>
     c46:	c0 e0       	ldi	r28, 0x00	; 0
     c48:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     c4a:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     c4e:	ce 01       	movw	r24, r28
     c50:	df 91       	pop	r29
     c52:	cf 91       	pop	r28
     c54:	08 95       	ret

00000c56 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     c56:	08 95       	ret

00000c58 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     c58:	0f b6       	in	r0, 0x3f	; 63
     c5a:	f8 94       	cli
     c5c:	0f 92       	push	r0
     c5e:	fc 01       	movw	r30, r24
     c60:	92 8d       	ldd	r25, Z+26	; 0x1a
     c62:	0f 90       	pop	r0
     c64:	0f be       	out	0x3f, r0	; 63
     c66:	81 e0       	ldi	r24, 0x01	; 1
     c68:	91 11       	cpse	r25, r1
     c6a:	80 e0       	ldi	r24, 0x00	; 0
     c6c:	08 95       	ret

00000c6e <prvCopyDataToQueue>:
     c6e:	0f 93       	push	r16
     c70:	1f 93       	push	r17
     c72:	cf 93       	push	r28
     c74:	df 93       	push	r29
     c76:	ec 01       	movw	r28, r24
     c78:	04 2f       	mov	r16, r20
     c7a:	1a 8d       	ldd	r17, Y+26	; 0x1a
     c7c:	4c 8d       	ldd	r20, Y+28	; 0x1c
     c7e:	44 23       	and	r20, r20
     c80:	b9 f1       	breq	.+110    	; 0xcf0 <prvCopyDataToQueue+0x82>
     c82:	01 11       	cpse	r16, r1
     c84:	16 c0       	rjmp	.+44     	; 0xcb2 <prvCopyDataToQueue+0x44>
     c86:	50 e0       	ldi	r21, 0x00	; 0
     c88:	8a 81       	ldd	r24, Y+2	; 0x02
     c8a:	9b 81       	ldd	r25, Y+3	; 0x03
     c8c:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <memcpy>
     c90:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c92:	8a 81       	ldd	r24, Y+2	; 0x02
     c94:	9b 81       	ldd	r25, Y+3	; 0x03
     c96:	82 0f       	add	r24, r18
     c98:	91 1d       	adc	r25, r1
     c9a:	9b 83       	std	Y+3, r25	; 0x03
     c9c:	8a 83       	std	Y+2, r24	; 0x02
     c9e:	2c 81       	ldd	r18, Y+4	; 0x04
     ca0:	3d 81       	ldd	r19, Y+5	; 0x05
     ca2:	82 17       	cp	r24, r18
     ca4:	93 07       	cpc	r25, r19
     ca6:	20 f1       	brcs	.+72     	; 0xcf0 <prvCopyDataToQueue+0x82>
     ca8:	88 81       	ld	r24, Y
     caa:	99 81       	ldd	r25, Y+1	; 0x01
     cac:	9b 83       	std	Y+3, r25	; 0x03
     cae:	8a 83       	std	Y+2, r24	; 0x02
     cb0:	1f c0       	rjmp	.+62     	; 0xcf0 <prvCopyDataToQueue+0x82>
     cb2:	50 e0       	ldi	r21, 0x00	; 0
     cb4:	8e 81       	ldd	r24, Y+6	; 0x06
     cb6:	9f 81       	ldd	r25, Y+7	; 0x07
     cb8:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <memcpy>
     cbc:	8c 8d       	ldd	r24, Y+28	; 0x1c
     cbe:	90 e0       	ldi	r25, 0x00	; 0
     cc0:	91 95       	neg	r25
     cc2:	81 95       	neg	r24
     cc4:	91 09       	sbc	r25, r1
     cc6:	2e 81       	ldd	r18, Y+6	; 0x06
     cc8:	3f 81       	ldd	r19, Y+7	; 0x07
     cca:	28 0f       	add	r18, r24
     ccc:	39 1f       	adc	r19, r25
     cce:	3f 83       	std	Y+7, r19	; 0x07
     cd0:	2e 83       	std	Y+6, r18	; 0x06
     cd2:	48 81       	ld	r20, Y
     cd4:	59 81       	ldd	r21, Y+1	; 0x01
     cd6:	24 17       	cp	r18, r20
     cd8:	35 07       	cpc	r19, r21
     cda:	30 f4       	brcc	.+12     	; 0xce8 <prvCopyDataToQueue+0x7a>
     cdc:	2c 81       	ldd	r18, Y+4	; 0x04
     cde:	3d 81       	ldd	r19, Y+5	; 0x05
     ce0:	82 0f       	add	r24, r18
     ce2:	93 1f       	adc	r25, r19
     ce4:	9f 83       	std	Y+7, r25	; 0x07
     ce6:	8e 83       	std	Y+6, r24	; 0x06
     ce8:	02 30       	cpi	r16, 0x02	; 2
     cea:	11 f4       	brne	.+4      	; 0xcf0 <prvCopyDataToQueue+0x82>
     cec:	11 11       	cpse	r17, r1
     cee:	11 50       	subi	r17, 0x01	; 1
     cf0:	1f 5f       	subi	r17, 0xFF	; 255
     cf2:	1a 8f       	std	Y+26, r17	; 0x1a
     cf4:	80 e0       	ldi	r24, 0x00	; 0
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	1f 91       	pop	r17
     cfc:	0f 91       	pop	r16
     cfe:	08 95       	ret

00000d00 <prvUnlockQueue>:
     d00:	ef 92       	push	r14
     d02:	ff 92       	push	r15
     d04:	0f 93       	push	r16
     d06:	1f 93       	push	r17
     d08:	cf 93       	push	r28
     d0a:	8c 01       	movw	r16, r24
     d0c:	0f b6       	in	r0, 0x3f	; 63
     d0e:	f8 94       	cli
     d10:	0f 92       	push	r0
     d12:	fc 01       	movw	r30, r24
     d14:	c6 8d       	ldd	r28, Z+30	; 0x1e
     d16:	1c 16       	cp	r1, r28
     d18:	ac f4       	brge	.+42     	; 0xd44 <prvUnlockQueue+0x44>
     d1a:	81 89       	ldd	r24, Z+17	; 0x11
     d1c:	81 11       	cpse	r24, r1
     d1e:	06 c0       	rjmp	.+12     	; 0xd2c <prvUnlockQueue+0x2c>
     d20:	11 c0       	rjmp	.+34     	; 0xd44 <prvUnlockQueue+0x44>
     d22:	f8 01       	movw	r30, r16
     d24:	81 89       	ldd	r24, Z+17	; 0x11
     d26:	81 11       	cpse	r24, r1
     d28:	05 c0       	rjmp	.+10     	; 0xd34 <prvUnlockQueue+0x34>
     d2a:	0c c0       	rjmp	.+24     	; 0xd44 <prvUnlockQueue+0x44>
     d2c:	78 01       	movw	r14, r16
     d2e:	f1 e1       	ldi	r31, 0x11	; 17
     d30:	ef 0e       	add	r14, r31
     d32:	f1 1c       	adc	r15, r1
     d34:	c7 01       	movw	r24, r14
     d36:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <xTaskRemoveFromEventList>
     d3a:	81 11       	cpse	r24, r1
     d3c:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <vTaskMissedYield>
     d40:	c1 50       	subi	r28, 0x01	; 1
     d42:	79 f7       	brne	.-34     	; 0xd22 <prvUnlockQueue+0x22>
     d44:	8f ef       	ldi	r24, 0xFF	; 255
     d46:	f8 01       	movw	r30, r16
     d48:	86 8f       	std	Z+30, r24	; 0x1e
     d4a:	0f 90       	pop	r0
     d4c:	0f be       	out	0x3f, r0	; 63
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	0f 92       	push	r0
     d54:	c5 8d       	ldd	r28, Z+29	; 0x1d
     d56:	1c 16       	cp	r1, r28
     d58:	ac f4       	brge	.+42     	; 0xd84 <prvUnlockQueue+0x84>
     d5a:	80 85       	ldd	r24, Z+8	; 0x08
     d5c:	81 11       	cpse	r24, r1
     d5e:	06 c0       	rjmp	.+12     	; 0xd6c <prvUnlockQueue+0x6c>
     d60:	11 c0       	rjmp	.+34     	; 0xd84 <prvUnlockQueue+0x84>
     d62:	f8 01       	movw	r30, r16
     d64:	80 85       	ldd	r24, Z+8	; 0x08
     d66:	81 11       	cpse	r24, r1
     d68:	05 c0       	rjmp	.+10     	; 0xd74 <prvUnlockQueue+0x74>
     d6a:	0c c0       	rjmp	.+24     	; 0xd84 <prvUnlockQueue+0x84>
     d6c:	78 01       	movw	r14, r16
     d6e:	f8 e0       	ldi	r31, 0x08	; 8
     d70:	ef 0e       	add	r14, r31
     d72:	f1 1c       	adc	r15, r1
     d74:	c7 01       	movw	r24, r14
     d76:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <xTaskRemoveFromEventList>
     d7a:	81 11       	cpse	r24, r1
     d7c:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <vTaskMissedYield>
     d80:	c1 50       	subi	r28, 0x01	; 1
     d82:	79 f7       	brne	.-34     	; 0xd62 <prvUnlockQueue+0x62>
     d84:	8f ef       	ldi	r24, 0xFF	; 255
     d86:	f8 01       	movw	r30, r16
     d88:	85 8f       	std	Z+29, r24	; 0x1d
     d8a:	0f 90       	pop	r0
     d8c:	0f be       	out	0x3f, r0	; 63
     d8e:	cf 91       	pop	r28
     d90:	1f 91       	pop	r17
     d92:	0f 91       	pop	r16
     d94:	ff 90       	pop	r15
     d96:	ef 90       	pop	r14
     d98:	08 95       	ret

00000d9a <xQueueGenericReset>:
     d9a:	cf 93       	push	r28
     d9c:	df 93       	push	r29
     d9e:	ec 01       	movw	r28, r24
     da0:	0f b6       	in	r0, 0x3f	; 63
     da2:	f8 94       	cli
     da4:	0f 92       	push	r0
     da6:	e8 81       	ld	r30, Y
     da8:	f9 81       	ldd	r31, Y+1	; 0x01
     daa:	8b 8d       	ldd	r24, Y+27	; 0x1b
     dac:	2c 8d       	ldd	r18, Y+28	; 0x1c
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	30 e0       	ldi	r19, 0x00	; 0
     db2:	82 9f       	mul	r24, r18
     db4:	a0 01       	movw	r20, r0
     db6:	83 9f       	mul	r24, r19
     db8:	50 0d       	add	r21, r0
     dba:	92 9f       	mul	r25, r18
     dbc:	50 0d       	add	r21, r0
     dbe:	11 24       	eor	r1, r1
     dc0:	4e 0f       	add	r20, r30
     dc2:	5f 1f       	adc	r21, r31
     dc4:	5d 83       	std	Y+5, r21	; 0x05
     dc6:	4c 83       	std	Y+4, r20	; 0x04
     dc8:	1a 8e       	std	Y+26, r1	; 0x1a
     dca:	fb 83       	std	Y+3, r31	; 0x03
     dcc:	ea 83       	std	Y+2, r30	; 0x02
     dce:	01 97       	sbiw	r24, 0x01	; 1
     dd0:	82 9f       	mul	r24, r18
     dd2:	a0 01       	movw	r20, r0
     dd4:	83 9f       	mul	r24, r19
     dd6:	50 0d       	add	r21, r0
     dd8:	92 9f       	mul	r25, r18
     dda:	50 0d       	add	r21, r0
     ddc:	11 24       	eor	r1, r1
     dde:	cf 01       	movw	r24, r30
     de0:	84 0f       	add	r24, r20
     de2:	95 1f       	adc	r25, r21
     de4:	9f 83       	std	Y+7, r25	; 0x07
     de6:	8e 83       	std	Y+6, r24	; 0x06
     de8:	8f ef       	ldi	r24, 0xFF	; 255
     dea:	8d 8f       	std	Y+29, r24	; 0x1d
     dec:	8e 8f       	std	Y+30, r24	; 0x1e
     dee:	61 11       	cpse	r22, r1
     df0:	0c c0       	rjmp	.+24     	; 0xe0a <xQueueGenericReset+0x70>
     df2:	88 85       	ldd	r24, Y+8	; 0x08
     df4:	88 23       	and	r24, r24
     df6:	89 f0       	breq	.+34     	; 0xe1a <xQueueGenericReset+0x80>
     df8:	ce 01       	movw	r24, r28
     dfa:	08 96       	adiw	r24, 0x08	; 8
     dfc:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <xTaskRemoveFromEventList>
     e00:	88 23       	and	r24, r24
     e02:	59 f0       	breq	.+22     	; 0xe1a <xQueueGenericReset+0x80>
     e04:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
     e08:	08 c0       	rjmp	.+16     	; 0xe1a <xQueueGenericReset+0x80>
     e0a:	ce 01       	movw	r24, r28
     e0c:	08 96       	adiw	r24, 0x08	; 8
     e0e:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
     e12:	ce 01       	movw	r24, r28
     e14:	41 96       	adiw	r24, 0x11	; 17
     e16:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
     e1a:	0f 90       	pop	r0
     e1c:	0f be       	out	0x3f, r0	; 63
     e1e:	81 e0       	ldi	r24, 0x01	; 1
     e20:	df 91       	pop	r29
     e22:	cf 91       	pop	r28
     e24:	08 95       	ret

00000e26 <xQueueGenericCreate>:
     e26:	0f 93       	push	r16
     e28:	1f 93       	push	r17
     e2a:	cf 93       	push	r28
     e2c:	df 93       	push	r29
     e2e:	08 2f       	mov	r16, r24
     e30:	16 2f       	mov	r17, r22
     e32:	66 23       	and	r22, r22
     e34:	c1 f0       	breq	.+48     	; 0xe66 <xQueueGenericCreate+0x40>
     e36:	86 9f       	mul	r24, r22
     e38:	c0 01       	movw	r24, r0
     e3a:	11 24       	eor	r1, r1
     e3c:	4f 96       	adiw	r24, 0x1f	; 31
     e3e:	0e 94 f6 05 	call	0xbec	; 0xbec <pvPortMalloc>
     e42:	ec 01       	movw	r28, r24
     e44:	00 97       	sbiw	r24, 0x00	; 0
     e46:	41 f4       	brne	.+16     	; 0xe58 <xQueueGenericCreate+0x32>
     e48:	15 c0       	rjmp	.+42     	; 0xe74 <xQueueGenericCreate+0x4e>
     e4a:	0b 8f       	std	Y+27, r16	; 0x1b
     e4c:	1c 8f       	std	Y+28, r17	; 0x1c
     e4e:	61 e0       	ldi	r22, 0x01	; 1
     e50:	ce 01       	movw	r24, r28
     e52:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xQueueGenericReset>
     e56:	0e c0       	rjmp	.+28     	; 0xe74 <xQueueGenericCreate+0x4e>
     e58:	4f 96       	adiw	r24, 0x1f	; 31
     e5a:	99 83       	std	Y+1, r25	; 0x01
     e5c:	88 83       	st	Y, r24
     e5e:	f5 cf       	rjmp	.-22     	; 0xe4a <xQueueGenericCreate+0x24>
     e60:	d9 83       	std	Y+1, r29	; 0x01
     e62:	c8 83       	st	Y, r28
     e64:	f2 cf       	rjmp	.-28     	; 0xe4a <xQueueGenericCreate+0x24>
     e66:	8f e1       	ldi	r24, 0x1F	; 31
     e68:	90 e0       	ldi	r25, 0x00	; 0
     e6a:	0e 94 f6 05 	call	0xbec	; 0xbec <pvPortMalloc>
     e6e:	ec 01       	movw	r28, r24
     e70:	89 2b       	or	r24, r25
     e72:	b1 f7       	brne	.-20     	; 0xe60 <xQueueGenericCreate+0x3a>
     e74:	ce 01       	movw	r24, r28
     e76:	df 91       	pop	r29
     e78:	cf 91       	pop	r28
     e7a:	1f 91       	pop	r17
     e7c:	0f 91       	pop	r16
     e7e:	08 95       	ret

00000e80 <xQueueCreateCountingSemaphore>:
     e80:	cf 93       	push	r28
     e82:	c6 2f       	mov	r28, r22
     e84:	42 e0       	ldi	r20, 0x02	; 2
     e86:	60 e0       	ldi	r22, 0x00	; 0
     e88:	0e 94 13 07 	call	0xe26	; 0xe26 <xQueueGenericCreate>
     e8c:	00 97       	sbiw	r24, 0x00	; 0
     e8e:	11 f0       	breq	.+4      	; 0xe94 <xQueueCreateCountingSemaphore+0x14>
     e90:	fc 01       	movw	r30, r24
     e92:	c2 8f       	std	Z+26, r28	; 0x1a
     e94:	cf 91       	pop	r28
     e96:	08 95       	ret

00000e98 <xQueueGenericSend>:
     e98:	9f 92       	push	r9
     e9a:	af 92       	push	r10
     e9c:	bf 92       	push	r11
     e9e:	cf 92       	push	r12
     ea0:	df 92       	push	r13
     ea2:	ef 92       	push	r14
     ea4:	ff 92       	push	r15
     ea6:	0f 93       	push	r16
     ea8:	1f 93       	push	r17
     eaa:	cf 93       	push	r28
     eac:	df 93       	push	r29
     eae:	00 d0       	rcall	.+0      	; 0xeb0 <xQueueGenericSend+0x18>
     eb0:	00 d0       	rcall	.+0      	; 0xeb2 <xQueueGenericSend+0x1a>
     eb2:	1f 92       	push	r1
     eb4:	cd b7       	in	r28, 0x3d	; 61
     eb6:	de b7       	in	r29, 0x3e	; 62
     eb8:	8c 01       	movw	r16, r24
     eba:	6b 01       	movw	r12, r22
     ebc:	5d 83       	std	Y+5, r21	; 0x05
     ebe:	4c 83       	std	Y+4, r20	; 0x04
     ec0:	a2 2e       	mov	r10, r18
     ec2:	b1 2c       	mov	r11, r1
     ec4:	99 24       	eor	r9, r9
     ec6:	93 94       	inc	r9
     ec8:	7c 01       	movw	r14, r24
     eca:	88 e0       	ldi	r24, 0x08	; 8
     ecc:	e8 0e       	add	r14, r24
     ece:	f1 1c       	adc	r15, r1
     ed0:	0f b6       	in	r0, 0x3f	; 63
     ed2:	f8 94       	cli
     ed4:	0f 92       	push	r0
     ed6:	f8 01       	movw	r30, r16
     ed8:	92 8d       	ldd	r25, Z+26	; 0x1a
     eda:	83 8d       	ldd	r24, Z+27	; 0x1b
     edc:	98 17       	cp	r25, r24
     ede:	18 f0       	brcs	.+6      	; 0xee6 <xQueueGenericSend+0x4e>
     ee0:	f2 e0       	ldi	r31, 0x02	; 2
     ee2:	af 12       	cpse	r10, r31
     ee4:	19 c0       	rjmp	.+50     	; 0xf18 <xQueueGenericSend+0x80>
     ee6:	4a 2d       	mov	r20, r10
     ee8:	b6 01       	movw	r22, r12
     eea:	c8 01       	movw	r24, r16
     eec:	0e 94 37 06 	call	0xc6e	; 0xc6e <prvCopyDataToQueue>
     ef0:	f8 01       	movw	r30, r16
     ef2:	91 89       	ldd	r25, Z+17	; 0x11
     ef4:	99 23       	and	r25, r25
     ef6:	49 f0       	breq	.+18     	; 0xf0a <xQueueGenericSend+0x72>
     ef8:	c8 01       	movw	r24, r16
     efa:	41 96       	adiw	r24, 0x11	; 17
     efc:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <xTaskRemoveFromEventList>
     f00:	88 23       	and	r24, r24
     f02:	31 f0       	breq	.+12     	; 0xf10 <xQueueGenericSend+0x78>
     f04:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
     f08:	03 c0       	rjmp	.+6      	; 0xf10 <xQueueGenericSend+0x78>
     f0a:	81 11       	cpse	r24, r1
     f0c:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
     f10:	0f 90       	pop	r0
     f12:	0f be       	out	0x3f, r0	; 63
     f14:	81 e0       	ldi	r24, 0x01	; 1
     f16:	50 c0       	rjmp	.+160    	; 0xfb8 <xQueueGenericSend+0x120>
     f18:	8c 81       	ldd	r24, Y+4	; 0x04
     f1a:	9d 81       	ldd	r25, Y+5	; 0x05
     f1c:	89 2b       	or	r24, r25
     f1e:	21 f4       	brne	.+8      	; 0xf28 <xQueueGenericSend+0x90>
     f20:	0f 90       	pop	r0
     f22:	0f be       	out	0x3f, r0	; 63
     f24:	80 e0       	ldi	r24, 0x00	; 0
     f26:	48 c0       	rjmp	.+144    	; 0xfb8 <xQueueGenericSend+0x120>
     f28:	b1 10       	cpse	r11, r1
     f2a:	05 c0       	rjmp	.+10     	; 0xf36 <xQueueGenericSend+0x9e>
     f2c:	ce 01       	movw	r24, r28
     f2e:	01 96       	adiw	r24, 0x01	; 1
     f30:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <vTaskInternalSetTimeOutState>
     f34:	b9 2c       	mov	r11, r9
     f36:	0f 90       	pop	r0
     f38:	0f be       	out	0x3f, r0	; 63
     f3a:	0e 94 b2 0a 	call	0x1564	; 0x1564 <vTaskSuspendAll>
     f3e:	0f b6       	in	r0, 0x3f	; 63
     f40:	f8 94       	cli
     f42:	0f 92       	push	r0
     f44:	f8 01       	movw	r30, r16
     f46:	85 8d       	ldd	r24, Z+29	; 0x1d
     f48:	8f 3f       	cpi	r24, 0xFF	; 255
     f4a:	09 f4       	brne	.+2      	; 0xf4e <xQueueGenericSend+0xb6>
     f4c:	15 8e       	std	Z+29, r1	; 0x1d
     f4e:	f8 01       	movw	r30, r16
     f50:	86 8d       	ldd	r24, Z+30	; 0x1e
     f52:	8f 3f       	cpi	r24, 0xFF	; 255
     f54:	09 f4       	brne	.+2      	; 0xf58 <xQueueGenericSend+0xc0>
     f56:	16 8e       	std	Z+30, r1	; 0x1e
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63
     f5c:	be 01       	movw	r22, r28
     f5e:	6c 5f       	subi	r22, 0xFC	; 252
     f60:	7f 4f       	sbci	r23, 0xFF	; 255
     f62:	ce 01       	movw	r24, r28
     f64:	01 96       	adiw	r24, 0x01	; 1
     f66:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <xTaskCheckForTimeOut>
     f6a:	81 11       	cpse	r24, r1
     f6c:	1f c0       	rjmp	.+62     	; 0xfac <xQueueGenericSend+0x114>
     f6e:	0f b6       	in	r0, 0x3f	; 63
     f70:	f8 94       	cli
     f72:	0f 92       	push	r0
     f74:	f8 01       	movw	r30, r16
     f76:	92 8d       	ldd	r25, Z+26	; 0x1a
     f78:	0f 90       	pop	r0
     f7a:	0f be       	out	0x3f, r0	; 63
     f7c:	83 8d       	ldd	r24, Z+27	; 0x1b
     f7e:	98 13       	cpse	r25, r24
     f80:	0f c0       	rjmp	.+30     	; 0xfa0 <xQueueGenericSend+0x108>
     f82:	6c 81       	ldd	r22, Y+4	; 0x04
     f84:	7d 81       	ldd	r23, Y+5	; 0x05
     f86:	c7 01       	movw	r24, r14
     f88:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <vTaskPlaceOnEventList>
     f8c:	c8 01       	movw	r24, r16
     f8e:	0e 94 80 06 	call	0xd00	; 0xd00 <prvUnlockQueue>
     f92:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskResumeAll>
     f96:	81 11       	cpse	r24, r1
     f98:	9b cf       	rjmp	.-202    	; 0xed0 <xQueueGenericSend+0x38>
     f9a:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
     f9e:	98 cf       	rjmp	.-208    	; 0xed0 <xQueueGenericSend+0x38>
     fa0:	c8 01       	movw	r24, r16
     fa2:	0e 94 80 06 	call	0xd00	; 0xd00 <prvUnlockQueue>
     fa6:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskResumeAll>
     faa:	92 cf       	rjmp	.-220    	; 0xed0 <xQueueGenericSend+0x38>
     fac:	c8 01       	movw	r24, r16
     fae:	0e 94 80 06 	call	0xd00	; 0xd00 <prvUnlockQueue>
     fb2:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskResumeAll>
     fb6:	80 e0       	ldi	r24, 0x00	; 0
     fb8:	0f 90       	pop	r0
     fba:	0f 90       	pop	r0
     fbc:	0f 90       	pop	r0
     fbe:	0f 90       	pop	r0
     fc0:	0f 90       	pop	r0
     fc2:	df 91       	pop	r29
     fc4:	cf 91       	pop	r28
     fc6:	1f 91       	pop	r17
     fc8:	0f 91       	pop	r16
     fca:	ff 90       	pop	r15
     fcc:	ef 90       	pop	r14
     fce:	df 90       	pop	r13
     fd0:	cf 90       	pop	r12
     fd2:	bf 90       	pop	r11
     fd4:	af 90       	pop	r10
     fd6:	9f 90       	pop	r9
     fd8:	08 95       	ret

00000fda <xQueueSemaphoreTake>:
     fda:	cf 92       	push	r12
     fdc:	df 92       	push	r13
     fde:	ef 92       	push	r14
     fe0:	ff 92       	push	r15
     fe2:	0f 93       	push	r16
     fe4:	1f 93       	push	r17
     fe6:	cf 93       	push	r28
     fe8:	df 93       	push	r29
     fea:	00 d0       	rcall	.+0      	; 0xfec <xQueueSemaphoreTake+0x12>
     fec:	00 d0       	rcall	.+0      	; 0xfee <xQueueSemaphoreTake+0x14>
     fee:	1f 92       	push	r1
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
     ff4:	8c 01       	movw	r16, r24
     ff6:	7d 83       	std	Y+5, r23	; 0x05
     ff8:	6c 83       	std	Y+4, r22	; 0x04
     ffa:	d1 2c       	mov	r13, r1
     ffc:	cc 24       	eor	r12, r12
     ffe:	c3 94       	inc	r12
    1000:	7c 01       	movw	r14, r24
    1002:	81 e1       	ldi	r24, 0x11	; 17
    1004:	e8 0e       	add	r14, r24
    1006:	f1 1c       	adc	r15, r1
    1008:	0f b6       	in	r0, 0x3f	; 63
    100a:	f8 94       	cli
    100c:	0f 92       	push	r0
    100e:	f8 01       	movw	r30, r16
    1010:	82 8d       	ldd	r24, Z+26	; 0x1a
    1012:	88 23       	and	r24, r24
    1014:	81 f0       	breq	.+32     	; 0x1036 <xQueueSemaphoreTake+0x5c>
    1016:	81 50       	subi	r24, 0x01	; 1
    1018:	82 8f       	std	Z+26, r24	; 0x1a
    101a:	80 85       	ldd	r24, Z+8	; 0x08
    101c:	88 23       	and	r24, r24
    101e:	39 f0       	breq	.+14     	; 0x102e <xQueueSemaphoreTake+0x54>
    1020:	c8 01       	movw	r24, r16
    1022:	08 96       	adiw	r24, 0x08	; 8
    1024:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <xTaskRemoveFromEventList>
    1028:	81 11       	cpse	r24, r1
    102a:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
    102e:	0f 90       	pop	r0
    1030:	0f be       	out	0x3f, r0	; 63
    1032:	81 e0       	ldi	r24, 0x01	; 1
    1034:	51 c0       	rjmp	.+162    	; 0x10d8 <xQueueSemaphoreTake+0xfe>
    1036:	8c 81       	ldd	r24, Y+4	; 0x04
    1038:	9d 81       	ldd	r25, Y+5	; 0x05
    103a:	89 2b       	or	r24, r25
    103c:	21 f4       	brne	.+8      	; 0x1046 <xQueueSemaphoreTake+0x6c>
    103e:	0f 90       	pop	r0
    1040:	0f be       	out	0x3f, r0	; 63
    1042:	80 e0       	ldi	r24, 0x00	; 0
    1044:	49 c0       	rjmp	.+146    	; 0x10d8 <xQueueSemaphoreTake+0xfe>
    1046:	d1 10       	cpse	r13, r1
    1048:	05 c0       	rjmp	.+10     	; 0x1054 <xQueueSemaphoreTake+0x7a>
    104a:	ce 01       	movw	r24, r28
    104c:	01 96       	adiw	r24, 0x01	; 1
    104e:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <vTaskInternalSetTimeOutState>
    1052:	dc 2c       	mov	r13, r12
    1054:	0f 90       	pop	r0
    1056:	0f be       	out	0x3f, r0	; 63
    1058:	0e 94 b2 0a 	call	0x1564	; 0x1564 <vTaskSuspendAll>
    105c:	0f b6       	in	r0, 0x3f	; 63
    105e:	f8 94       	cli
    1060:	0f 92       	push	r0
    1062:	f8 01       	movw	r30, r16
    1064:	85 8d       	ldd	r24, Z+29	; 0x1d
    1066:	8f 3f       	cpi	r24, 0xFF	; 255
    1068:	09 f4       	brne	.+2      	; 0x106c <xQueueSemaphoreTake+0x92>
    106a:	15 8e       	std	Z+29, r1	; 0x1d
    106c:	f8 01       	movw	r30, r16
    106e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1070:	8f 3f       	cpi	r24, 0xFF	; 255
    1072:	09 f4       	brne	.+2      	; 0x1076 <xQueueSemaphoreTake+0x9c>
    1074:	16 8e       	std	Z+30, r1	; 0x1e
    1076:	0f 90       	pop	r0
    1078:	0f be       	out	0x3f, r0	; 63
    107a:	be 01       	movw	r22, r28
    107c:	6c 5f       	subi	r22, 0xFC	; 252
    107e:	7f 4f       	sbci	r23, 0xFF	; 255
    1080:	ce 01       	movw	r24, r28
    1082:	01 96       	adiw	r24, 0x01	; 1
    1084:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <xTaskCheckForTimeOut>
    1088:	81 11       	cpse	r24, r1
    108a:	1a c0       	rjmp	.+52     	; 0x10c0 <xQueueSemaphoreTake+0xe6>
    108c:	c8 01       	movw	r24, r16
    108e:	0e 94 2c 06 	call	0xc58	; 0xc58 <prvIsQueueEmpty>
    1092:	88 23       	and	r24, r24
    1094:	79 f0       	breq	.+30     	; 0x10b4 <xQueueSemaphoreTake+0xda>
    1096:	6c 81       	ldd	r22, Y+4	; 0x04
    1098:	7d 81       	ldd	r23, Y+5	; 0x05
    109a:	c7 01       	movw	r24, r14
    109c:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <vTaskPlaceOnEventList>
    10a0:	c8 01       	movw	r24, r16
    10a2:	0e 94 80 06 	call	0xd00	; 0xd00 <prvUnlockQueue>
    10a6:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskResumeAll>
    10aa:	81 11       	cpse	r24, r1
    10ac:	ad cf       	rjmp	.-166    	; 0x1008 <xQueueSemaphoreTake+0x2e>
    10ae:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
    10b2:	aa cf       	rjmp	.-172    	; 0x1008 <xQueueSemaphoreTake+0x2e>
    10b4:	c8 01       	movw	r24, r16
    10b6:	0e 94 80 06 	call	0xd00	; 0xd00 <prvUnlockQueue>
    10ba:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskResumeAll>
    10be:	a4 cf       	rjmp	.-184    	; 0x1008 <xQueueSemaphoreTake+0x2e>
    10c0:	c8 01       	movw	r24, r16
    10c2:	0e 94 80 06 	call	0xd00	; 0xd00 <prvUnlockQueue>
    10c6:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskResumeAll>
    10ca:	c8 01       	movw	r24, r16
    10cc:	0e 94 2c 06 	call	0xc58	; 0xc58 <prvIsQueueEmpty>
    10d0:	88 23       	and	r24, r24
    10d2:	09 f4       	brne	.+2      	; 0x10d6 <xQueueSemaphoreTake+0xfc>
    10d4:	99 cf       	rjmp	.-206    	; 0x1008 <xQueueSemaphoreTake+0x2e>
    10d6:	80 e0       	ldi	r24, 0x00	; 0
    10d8:	0f 90       	pop	r0
    10da:	0f 90       	pop	r0
    10dc:	0f 90       	pop	r0
    10de:	0f 90       	pop	r0
    10e0:	0f 90       	pop	r0
    10e2:	df 91       	pop	r29
    10e4:	cf 91       	pop	r28
    10e6:	1f 91       	pop	r17
    10e8:	0f 91       	pop	r16
    10ea:	ff 90       	pop	r15
    10ec:	ef 90       	pop	r14
    10ee:	df 90       	pop	r13
    10f0:	cf 90       	pop	r12
    10f2:	08 95       	ret

000010f4 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    10f4:	0f b6       	in	r0, 0x3f	; 63
    10f6:	f8 94       	cli
    10f8:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    10fa:	fc 01       	movw	r30, r24
    10fc:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    10fe:	0f 90       	pop	r0
    1100:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1102:	08 95       	ret

00001104 <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    1104:	e0 91 cb 06 	lds	r30, 0x06CB	; 0x8006cb <pxDelayedTaskList>
    1108:	f0 91 cc 06 	lds	r31, 0x06CC	; 0x8006cc <pxDelayedTaskList+0x1>
    110c:	80 81       	ld	r24, Z
    110e:	81 11       	cpse	r24, r1
    1110:	07 c0       	rjmp	.+14     	; 0x1120 <prvResetNextTaskUnblockTime+0x1c>
    1112:	8f ef       	ldi	r24, 0xFF	; 255
    1114:	9f ef       	ldi	r25, 0xFF	; 255
    1116:	90 93 a3 06 	sts	0x06A3, r25	; 0x8006a3 <xNextTaskUnblockTime+0x1>
    111a:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <xNextTaskUnblockTime>
    111e:	08 95       	ret
    1120:	e0 91 cb 06 	lds	r30, 0x06CB	; 0x8006cb <pxDelayedTaskList>
    1124:	f0 91 cc 06 	lds	r31, 0x06CC	; 0x8006cc <pxDelayedTaskList+0x1>
    1128:	05 80       	ldd	r0, Z+5	; 0x05
    112a:	f6 81       	ldd	r31, Z+6	; 0x06
    112c:	e0 2d       	mov	r30, r0
    112e:	06 80       	ldd	r0, Z+6	; 0x06
    1130:	f7 81       	ldd	r31, Z+7	; 0x07
    1132:	e0 2d       	mov	r30, r0
    1134:	82 81       	ldd	r24, Z+2	; 0x02
    1136:	93 81       	ldd	r25, Z+3	; 0x03
    1138:	90 93 a3 06 	sts	0x06A3, r25	; 0x8006a3 <xNextTaskUnblockTime+0x1>
    113c:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <xNextTaskUnblockTime>
    1140:	08 95       	ret

00001142 <prvIdleTask>:
    1142:	07 eb       	ldi	r16, 0xB7	; 183
    1144:	16 e0       	ldi	r17, 0x06	; 6
    1146:	80 91 b6 06 	lds	r24, 0x06B6	; 0x8006b6 <uxDeletedTasksWaitingCleanUp>
    114a:	88 23       	and	r24, r24
    114c:	e1 f3       	breq	.-8      	; 0x1146 <prvIdleTask+0x4>
    114e:	0f b6       	in	r0, 0x3f	; 63
    1150:	f8 94       	cli
    1152:	0f 92       	push	r0
    1154:	d8 01       	movw	r26, r16
    1156:	15 96       	adiw	r26, 0x05	; 5
    1158:	ed 91       	ld	r30, X+
    115a:	fc 91       	ld	r31, X
    115c:	16 97       	sbiw	r26, 0x06	; 6
    115e:	c6 81       	ldd	r28, Z+6	; 0x06
    1160:	d7 81       	ldd	r29, Z+7	; 0x07
    1162:	ce 01       	movw	r24, r28
    1164:	02 96       	adiw	r24, 0x02	; 2
    1166:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
    116a:	80 91 ac 06 	lds	r24, 0x06AC	; 0x8006ac <uxCurrentNumberOfTasks>
    116e:	81 50       	subi	r24, 0x01	; 1
    1170:	80 93 ac 06 	sts	0x06AC, r24	; 0x8006ac <uxCurrentNumberOfTasks>
    1174:	80 91 b6 06 	lds	r24, 0x06B6	; 0x8006b6 <uxDeletedTasksWaitingCleanUp>
    1178:	81 50       	subi	r24, 0x01	; 1
    117a:	80 93 b6 06 	sts	0x06B6, r24	; 0x8006b6 <uxDeletedTasksWaitingCleanUp>
    117e:	0f 90       	pop	r0
    1180:	0f be       	out	0x3f, r0	; 63
    1182:	8f 89       	ldd	r24, Y+23	; 0x17
    1184:	98 8d       	ldd	r25, Y+24	; 0x18
    1186:	0e 94 2b 06 	call	0xc56	; 0xc56 <vPortFree>
    118a:	ce 01       	movw	r24, r28
    118c:	0e 94 2b 06 	call	0xc56	; 0xc56 <vPortFree>
    1190:	80 91 b6 06 	lds	r24, 0x06B6	; 0x8006b6 <uxDeletedTasksWaitingCleanUp>
    1194:	81 11       	cpse	r24, r1
    1196:	db cf       	rjmp	.-74     	; 0x114e <prvIdleTask+0xc>
    1198:	d6 cf       	rjmp	.-84     	; 0x1146 <prvIdleTask+0x4>

0000119a <prvAddCurrentTaskToDelayedList>:
    119a:	ff 92       	push	r15
    119c:	0f 93       	push	r16
    119e:	1f 93       	push	r17
    11a0:	cf 93       	push	r28
    11a2:	df 93       	push	r29
    11a4:	ec 01       	movw	r28, r24
    11a6:	f6 2e       	mov	r15, r22
    11a8:	00 91 aa 06 	lds	r16, 0x06AA	; 0x8006aa <xTickCount>
    11ac:	10 91 ab 06 	lds	r17, 0x06AB	; 0x8006ab <xTickCount+0x1>
    11b0:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <pxCurrentTCB>
    11b4:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    11b8:	02 96       	adiw	r24, 0x02	; 2
    11ba:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
    11be:	cf 3f       	cpi	r28, 0xFF	; 255
    11c0:	8f ef       	ldi	r24, 0xFF	; 255
    11c2:	d8 07       	cpc	r29, r24
    11c4:	69 f4       	brne	.+26     	; 0x11e0 <prvAddCurrentTaskToDelayedList+0x46>
    11c6:	ff 20       	and	r15, r15
    11c8:	59 f0       	breq	.+22     	; 0x11e0 <prvAddCurrentTaskToDelayedList+0x46>
    11ca:	60 91 0c 07 	lds	r22, 0x070C	; 0x80070c <pxCurrentTCB>
    11ce:	70 91 0d 07 	lds	r23, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    11d2:	6e 5f       	subi	r22, 0xFE	; 254
    11d4:	7f 4f       	sbci	r23, 0xFF	; 255
    11d6:	8d ea       	ldi	r24, 0xAD	; 173
    11d8:	96 e0       	ldi	r25, 0x06	; 6
    11da:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    11de:	2f c0       	rjmp	.+94     	; 0x123e <prvAddCurrentTaskToDelayedList+0xa4>
    11e0:	c0 0f       	add	r28, r16
    11e2:	d1 1f       	adc	r29, r17
    11e4:	e0 91 0c 07 	lds	r30, 0x070C	; 0x80070c <pxCurrentTCB>
    11e8:	f0 91 0d 07 	lds	r31, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    11ec:	d3 83       	std	Z+3, r29	; 0x03
    11ee:	c2 83       	std	Z+2, r28	; 0x02
    11f0:	c0 17       	cp	r28, r16
    11f2:	d1 07       	cpc	r29, r17
    11f4:	68 f4       	brcc	.+26     	; 0x1210 <prvAddCurrentTaskToDelayedList+0x76>
    11f6:	60 91 0c 07 	lds	r22, 0x070C	; 0x80070c <pxCurrentTCB>
    11fa:	70 91 0d 07 	lds	r23, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    11fe:	80 91 c9 06 	lds	r24, 0x06C9	; 0x8006c9 <pxOverflowDelayedTaskList>
    1202:	90 91 ca 06 	lds	r25, 0x06CA	; 0x8006ca <pxOverflowDelayedTaskList+0x1>
    1206:	6e 5f       	subi	r22, 0xFE	; 254
    1208:	7f 4f       	sbci	r23, 0xFF	; 255
    120a:	0e 94 45 04 	call	0x88a	; 0x88a <vListInsert>
    120e:	17 c0       	rjmp	.+46     	; 0x123e <prvAddCurrentTaskToDelayedList+0xa4>
    1210:	60 91 0c 07 	lds	r22, 0x070C	; 0x80070c <pxCurrentTCB>
    1214:	70 91 0d 07 	lds	r23, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    1218:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <pxDelayedTaskList>
    121c:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <pxDelayedTaskList+0x1>
    1220:	6e 5f       	subi	r22, 0xFE	; 254
    1222:	7f 4f       	sbci	r23, 0xFF	; 255
    1224:	0e 94 45 04 	call	0x88a	; 0x88a <vListInsert>
    1228:	80 91 a2 06 	lds	r24, 0x06A2	; 0x8006a2 <xNextTaskUnblockTime>
    122c:	90 91 a3 06 	lds	r25, 0x06A3	; 0x8006a3 <xNextTaskUnblockTime+0x1>
    1230:	c8 17       	cp	r28, r24
    1232:	d9 07       	cpc	r29, r25
    1234:	20 f4       	brcc	.+8      	; 0x123e <prvAddCurrentTaskToDelayedList+0xa4>
    1236:	d0 93 a3 06 	sts	0x06A3, r29	; 0x8006a3 <xNextTaskUnblockTime+0x1>
    123a:	c0 93 a2 06 	sts	0x06A2, r28	; 0x8006a2 <xNextTaskUnblockTime>
    123e:	df 91       	pop	r29
    1240:	cf 91       	pop	r28
    1242:	1f 91       	pop	r17
    1244:	0f 91       	pop	r16
    1246:	ff 90       	pop	r15
    1248:	08 95       	ret

0000124a <xTaskCreate>:
    124a:	4f 92       	push	r4
    124c:	5f 92       	push	r5
    124e:	6f 92       	push	r6
    1250:	7f 92       	push	r7
    1252:	8f 92       	push	r8
    1254:	9f 92       	push	r9
    1256:	af 92       	push	r10
    1258:	bf 92       	push	r11
    125a:	cf 92       	push	r12
    125c:	df 92       	push	r13
    125e:	ef 92       	push	r14
    1260:	ff 92       	push	r15
    1262:	0f 93       	push	r16
    1264:	1f 93       	push	r17
    1266:	cf 93       	push	r28
    1268:	df 93       	push	r29
    126a:	4c 01       	movw	r8, r24
    126c:	6b 01       	movw	r12, r22
    126e:	5a 01       	movw	r10, r20
    1270:	29 01       	movw	r4, r18
    1272:	ca 01       	movw	r24, r20
    1274:	0e 94 f6 05 	call	0xbec	; 0xbec <pvPortMalloc>
    1278:	3c 01       	movw	r6, r24
    127a:	89 2b       	or	r24, r25
    127c:	09 f4       	brne	.+2      	; 0x1280 <xTaskCreate+0x36>
    127e:	e7 c0       	rjmp	.+462    	; 0x144e <xTaskCreate+0x204>
    1280:	86 e2       	ldi	r24, 0x26	; 38
    1282:	90 e0       	ldi	r25, 0x00	; 0
    1284:	0e 94 f6 05 	call	0xbec	; 0xbec <pvPortMalloc>
    1288:	ec 01       	movw	r28, r24
    128a:	89 2b       	or	r24, r25
    128c:	59 f0       	breq	.+22     	; 0x12a4 <xTaskCreate+0x5a>
    128e:	78 8e       	std	Y+24, r7	; 0x18
    1290:	6f 8a       	std	Y+23, r6	; 0x17
    1292:	81 e0       	ldi	r24, 0x01	; 1
    1294:	a8 1a       	sub	r10, r24
    1296:	b1 08       	sbc	r11, r1
    1298:	a6 0c       	add	r10, r6
    129a:	b7 1c       	adc	r11, r7
    129c:	c1 14       	cp	r12, r1
    129e:	d1 04       	cpc	r13, r1
    12a0:	29 f4       	brne	.+10     	; 0x12ac <xTaskCreate+0x62>
    12a2:	20 c0       	rjmp	.+64     	; 0x12e4 <xTaskCreate+0x9a>
    12a4:	c3 01       	movw	r24, r6
    12a6:	0e 94 2b 06 	call	0xc56	; 0xc56 <vPortFree>
    12aa:	d1 c0       	rjmp	.+418    	; 0x144e <xTaskCreate+0x204>
    12ac:	d6 01       	movw	r26, r12
    12ae:	8c 91       	ld	r24, X
    12b0:	89 8f       	std	Y+25, r24	; 0x19
    12b2:	8c 91       	ld	r24, X
    12b4:	88 23       	and	r24, r24
    12b6:	a1 f0       	breq	.+40     	; 0x12e0 <xTaskCreate+0x96>
    12b8:	ae 01       	movw	r20, r28
    12ba:	46 5e       	subi	r20, 0xE6	; 230
    12bc:	5f 4f       	sbci	r21, 0xFF	; 255
    12be:	f6 01       	movw	r30, r12
    12c0:	31 96       	adiw	r30, 0x01	; 1
    12c2:	b8 e0       	ldi	r27, 0x08	; 8
    12c4:	cb 0e       	add	r12, r27
    12c6:	d1 1c       	adc	r13, r1
    12c8:	cf 01       	movw	r24, r30
    12ca:	21 91       	ld	r18, Z+
    12cc:	da 01       	movw	r26, r20
    12ce:	2d 93       	st	X+, r18
    12d0:	ad 01       	movw	r20, r26
    12d2:	dc 01       	movw	r26, r24
    12d4:	8c 91       	ld	r24, X
    12d6:	88 23       	and	r24, r24
    12d8:	19 f0       	breq	.+6      	; 0x12e0 <xTaskCreate+0x96>
    12da:	ce 16       	cp	r12, r30
    12dc:	df 06       	cpc	r13, r31
    12de:	a1 f7       	brne	.-24     	; 0x12c8 <xTaskCreate+0x7e>
    12e0:	18 a2       	std	Y+32, r1	; 0x20
    12e2:	01 c0       	rjmp	.+2      	; 0x12e6 <xTaskCreate+0x9c>
    12e4:	19 8e       	std	Y+25, r1	; 0x19
    12e6:	05 30       	cpi	r16, 0x05	; 5
    12e8:	08 f0       	brcs	.+2      	; 0x12ec <xTaskCreate+0xa2>
    12ea:	04 e0       	ldi	r16, 0x04	; 4
    12ec:	0e 8b       	std	Y+22, r16	; 0x16
    12ee:	6e 01       	movw	r12, r28
    12f0:	b2 e0       	ldi	r27, 0x02	; 2
    12f2:	cb 0e       	add	r12, r27
    12f4:	d1 1c       	adc	r13, r1
    12f6:	c6 01       	movw	r24, r12
    12f8:	0e 94 20 04 	call	0x840	; 0x840 <vListInitialiseItem>
    12fc:	ce 01       	movw	r24, r28
    12fe:	0c 96       	adiw	r24, 0x0c	; 12
    1300:	0e 94 20 04 	call	0x840	; 0x840 <vListInitialiseItem>
    1304:	d9 87       	std	Y+9, r29	; 0x09
    1306:	c8 87       	std	Y+8, r28	; 0x08
    1308:	85 e0       	ldi	r24, 0x05	; 5
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	80 1b       	sub	r24, r16
    130e:	91 09       	sbc	r25, r1
    1310:	9d 87       	std	Y+13, r25	; 0x0d
    1312:	8c 87       	std	Y+12, r24	; 0x0c
    1314:	db 8b       	std	Y+19, r29	; 0x13
    1316:	ca 8b       	std	Y+18, r28	; 0x12
    1318:	19 a2       	std	Y+33, r1	; 0x21
    131a:	1a a2       	std	Y+34, r1	; 0x22
    131c:	1b a2       	std	Y+35, r1	; 0x23
    131e:	1c a2       	std	Y+36, r1	; 0x24
    1320:	1d a2       	std	Y+37, r1	; 0x25
    1322:	a2 01       	movw	r20, r4
    1324:	b4 01       	movw	r22, r8
    1326:	c5 01       	movw	r24, r10
    1328:	0e 94 9d 04 	call	0x93a	; 0x93a <pxPortInitialiseStack>
    132c:	99 83       	std	Y+1, r25	; 0x01
    132e:	88 83       	st	Y, r24
    1330:	e1 14       	cp	r14, r1
    1332:	f1 04       	cpc	r15, r1
    1334:	19 f0       	breq	.+6      	; 0x133c <xTaskCreate+0xf2>
    1336:	f7 01       	movw	r30, r14
    1338:	d1 83       	std	Z+1, r29	; 0x01
    133a:	c0 83       	st	Z, r28
    133c:	0f b6       	in	r0, 0x3f	; 63
    133e:	f8 94       	cli
    1340:	0f 92       	push	r0
    1342:	80 91 ac 06 	lds	r24, 0x06AC	; 0x8006ac <uxCurrentNumberOfTasks>
    1346:	8f 5f       	subi	r24, 0xFF	; 255
    1348:	80 93 ac 06 	sts	0x06AC, r24	; 0x8006ac <uxCurrentNumberOfTasks>
    134c:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <pxCurrentTCB>
    1350:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    1354:	89 2b       	or	r24, r25
    1356:	d1 f5       	brne	.+116    	; 0x13cc <xTaskCreate+0x182>
    1358:	d0 93 0d 07 	sts	0x070D, r29	; 0x80070d <pxCurrentTCB+0x1>
    135c:	c0 93 0c 07 	sts	0x070C, r28	; 0x80070c <pxCurrentTCB>
    1360:	80 91 ac 06 	lds	r24, 0x06AC	; 0x8006ac <uxCurrentNumberOfTasks>
    1364:	81 30       	cpi	r24, 0x01	; 1
    1366:	09 f0       	breq	.+2      	; 0x136a <xTaskCreate+0x120>
    1368:	41 c0       	rjmp	.+130    	; 0x13ec <xTaskCreate+0x1a2>
    136a:	0f ed       	ldi	r16, 0xDF	; 223
    136c:	16 e0       	ldi	r17, 0x06	; 6
    136e:	0f 2e       	mov	r0, r31
    1370:	fc e0       	ldi	r31, 0x0C	; 12
    1372:	ef 2e       	mov	r14, r31
    1374:	f7 e0       	ldi	r31, 0x07	; 7
    1376:	ff 2e       	mov	r15, r31
    1378:	f0 2d       	mov	r31, r0
    137a:	c8 01       	movw	r24, r16
    137c:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
    1380:	07 5f       	subi	r16, 0xF7	; 247
    1382:	1f 4f       	sbci	r17, 0xFF	; 255
    1384:	0e 15       	cp	r16, r14
    1386:	1f 05       	cpc	r17, r15
    1388:	c1 f7       	brne	.-16     	; 0x137a <xTaskCreate+0x130>
    138a:	86 ed       	ldi	r24, 0xD6	; 214
    138c:	96 e0       	ldi	r25, 0x06	; 6
    138e:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
    1392:	8d ec       	ldi	r24, 0xCD	; 205
    1394:	96 e0       	ldi	r25, 0x06	; 6
    1396:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
    139a:	80 ec       	ldi	r24, 0xC0	; 192
    139c:	96 e0       	ldi	r25, 0x06	; 6
    139e:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
    13a2:	87 eb       	ldi	r24, 0xB7	; 183
    13a4:	96 e0       	ldi	r25, 0x06	; 6
    13a6:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
    13aa:	8d ea       	ldi	r24, 0xAD	; 173
    13ac:	96 e0       	ldi	r25, 0x06	; 6
    13ae:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
    13b2:	86 ed       	ldi	r24, 0xD6	; 214
    13b4:	96 e0       	ldi	r25, 0x06	; 6
    13b6:	90 93 cc 06 	sts	0x06CC, r25	; 0x8006cc <pxDelayedTaskList+0x1>
    13ba:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <pxDelayedTaskList>
    13be:	8d ec       	ldi	r24, 0xCD	; 205
    13c0:	96 e0       	ldi	r25, 0x06	; 6
    13c2:	90 93 ca 06 	sts	0x06CA, r25	; 0x8006ca <pxOverflowDelayedTaskList+0x1>
    13c6:	80 93 c9 06 	sts	0x06C9, r24	; 0x8006c9 <pxOverflowDelayedTaskList>
    13ca:	10 c0       	rjmp	.+32     	; 0x13ec <xTaskCreate+0x1a2>
    13cc:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <xSchedulerRunning>
    13d0:	81 11       	cpse	r24, r1
    13d2:	0c c0       	rjmp	.+24     	; 0x13ec <xTaskCreate+0x1a2>
    13d4:	e0 91 0c 07 	lds	r30, 0x070C	; 0x80070c <pxCurrentTCB>
    13d8:	f0 91 0d 07 	lds	r31, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    13dc:	96 89       	ldd	r25, Z+22	; 0x16
    13de:	8e 89       	ldd	r24, Y+22	; 0x16
    13e0:	89 17       	cp	r24, r25
    13e2:	20 f0       	brcs	.+8      	; 0x13ec <xTaskCreate+0x1a2>
    13e4:	d0 93 0d 07 	sts	0x070D, r29	; 0x80070d <pxCurrentTCB+0x1>
    13e8:	c0 93 0c 07 	sts	0x070C, r28	; 0x80070c <pxCurrentTCB>
    13ec:	80 91 a4 06 	lds	r24, 0x06A4	; 0x8006a4 <uxTaskNumber>
    13f0:	8f 5f       	subi	r24, 0xFF	; 255
    13f2:	80 93 a4 06 	sts	0x06A4, r24	; 0x8006a4 <uxTaskNumber>
    13f6:	8e 89       	ldd	r24, Y+22	; 0x16
    13f8:	90 91 a9 06 	lds	r25, 0x06A9	; 0x8006a9 <uxTopReadyPriority>
    13fc:	98 17       	cp	r25, r24
    13fe:	10 f4       	brcc	.+4      	; 0x1404 <xTaskCreate+0x1ba>
    1400:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <uxTopReadyPriority>
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	9c 01       	movw	r18, r24
    1408:	22 0f       	add	r18, r18
    140a:	33 1f       	adc	r19, r19
    140c:	22 0f       	add	r18, r18
    140e:	33 1f       	adc	r19, r19
    1410:	22 0f       	add	r18, r18
    1412:	33 1f       	adc	r19, r19
    1414:	82 0f       	add	r24, r18
    1416:	93 1f       	adc	r25, r19
    1418:	b6 01       	movw	r22, r12
    141a:	81 52       	subi	r24, 0x21	; 33
    141c:	99 4f       	sbci	r25, 0xF9	; 249
    141e:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    1422:	0f 90       	pop	r0
    1424:	0f be       	out	0x3f, r0	; 63
    1426:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <xSchedulerRunning>
    142a:	88 23       	and	r24, r24
    142c:	61 f0       	breq	.+24     	; 0x1446 <xTaskCreate+0x1fc>
    142e:	e0 91 0c 07 	lds	r30, 0x070C	; 0x80070c <pxCurrentTCB>
    1432:	f0 91 0d 07 	lds	r31, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    1436:	96 89       	ldd	r25, Z+22	; 0x16
    1438:	8e 89       	ldd	r24, Y+22	; 0x16
    143a:	98 17       	cp	r25, r24
    143c:	30 f4       	brcc	.+12     	; 0x144a <xTaskCreate+0x200>
    143e:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
    1442:	81 e0       	ldi	r24, 0x01	; 1
    1444:	05 c0       	rjmp	.+10     	; 0x1450 <xTaskCreate+0x206>
    1446:	81 e0       	ldi	r24, 0x01	; 1
    1448:	03 c0       	rjmp	.+6      	; 0x1450 <xTaskCreate+0x206>
    144a:	81 e0       	ldi	r24, 0x01	; 1
    144c:	01 c0       	rjmp	.+2      	; 0x1450 <xTaskCreate+0x206>
    144e:	8f ef       	ldi	r24, 0xFF	; 255
    1450:	df 91       	pop	r29
    1452:	cf 91       	pop	r28
    1454:	1f 91       	pop	r17
    1456:	0f 91       	pop	r16
    1458:	ff 90       	pop	r15
    145a:	ef 90       	pop	r14
    145c:	df 90       	pop	r13
    145e:	cf 90       	pop	r12
    1460:	bf 90       	pop	r11
    1462:	af 90       	pop	r10
    1464:	9f 90       	pop	r9
    1466:	8f 90       	pop	r8
    1468:	7f 90       	pop	r7
    146a:	6f 90       	pop	r6
    146c:	5f 90       	pop	r5
    146e:	4f 90       	pop	r4
    1470:	08 95       	ret

00001472 <vTaskResume>:
    1472:	0f 93       	push	r16
    1474:	1f 93       	push	r17
    1476:	cf 93       	push	r28
    1478:	df 93       	push	r29
    147a:	20 91 0c 07 	lds	r18, 0x070C	; 0x80070c <pxCurrentTCB>
    147e:	30 91 0d 07 	lds	r19, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    1482:	82 17       	cp	r24, r18
    1484:	93 07       	cpc	r25, r19
    1486:	09 f4       	brne	.+2      	; 0x148a <vTaskResume+0x18>
    1488:	3e c0       	rjmp	.+124    	; 0x1506 <vTaskResume+0x94>
    148a:	00 97       	sbiw	r24, 0x00	; 0
    148c:	09 f4       	brne	.+2      	; 0x1490 <vTaskResume+0x1e>
    148e:	3b c0       	rjmp	.+118    	; 0x1506 <vTaskResume+0x94>
    1490:	0f b6       	in	r0, 0x3f	; 63
    1492:	f8 94       	cli
    1494:	0f 92       	push	r0
    1496:	fc 01       	movw	r30, r24
    1498:	22 85       	ldd	r18, Z+10	; 0x0a
    149a:	33 85       	ldd	r19, Z+11	; 0x0b
    149c:	2d 5a       	subi	r18, 0xAD	; 173
    149e:	36 40       	sbci	r19, 0x06	; 6
    14a0:	81 f5       	brne	.+96     	; 0x1502 <vTaskResume+0x90>
    14a2:	fc 01       	movw	r30, r24
    14a4:	24 89       	ldd	r18, Z+20	; 0x14
    14a6:	35 89       	ldd	r19, Z+21	; 0x15
    14a8:	f6 e0       	ldi	r31, 0x06	; 6
    14aa:	20 3c       	cpi	r18, 0xC0	; 192
    14ac:	3f 07       	cpc	r19, r31
    14ae:	49 f1       	breq	.+82     	; 0x1502 <vTaskResume+0x90>
    14b0:	23 2b       	or	r18, r19
    14b2:	39 f5       	brne	.+78     	; 0x1502 <vTaskResume+0x90>
    14b4:	ec 01       	movw	r28, r24
    14b6:	8c 01       	movw	r16, r24
    14b8:	0e 5f       	subi	r16, 0xFE	; 254
    14ba:	1f 4f       	sbci	r17, 0xFF	; 255
    14bc:	c8 01       	movw	r24, r16
    14be:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
    14c2:	8e 89       	ldd	r24, Y+22	; 0x16
    14c4:	90 91 a9 06 	lds	r25, 0x06A9	; 0x8006a9 <uxTopReadyPriority>
    14c8:	98 17       	cp	r25, r24
    14ca:	10 f4       	brcc	.+4      	; 0x14d0 <vTaskResume+0x5e>
    14cc:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <uxTopReadyPriority>
    14d0:	90 e0       	ldi	r25, 0x00	; 0
    14d2:	9c 01       	movw	r18, r24
    14d4:	22 0f       	add	r18, r18
    14d6:	33 1f       	adc	r19, r19
    14d8:	22 0f       	add	r18, r18
    14da:	33 1f       	adc	r19, r19
    14dc:	22 0f       	add	r18, r18
    14de:	33 1f       	adc	r19, r19
    14e0:	82 0f       	add	r24, r18
    14e2:	93 1f       	adc	r25, r19
    14e4:	b8 01       	movw	r22, r16
    14e6:	81 52       	subi	r24, 0x21	; 33
    14e8:	99 4f       	sbci	r25, 0xF9	; 249
    14ea:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    14ee:	e0 91 0c 07 	lds	r30, 0x070C	; 0x80070c <pxCurrentTCB>
    14f2:	f0 91 0d 07 	lds	r31, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    14f6:	9e 89       	ldd	r25, Y+22	; 0x16
    14f8:	86 89       	ldd	r24, Z+22	; 0x16
    14fa:	98 17       	cp	r25, r24
    14fc:	10 f0       	brcs	.+4      	; 0x1502 <vTaskResume+0x90>
    14fe:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
    1502:	0f 90       	pop	r0
    1504:	0f be       	out	0x3f, r0	; 63
    1506:	df 91       	pop	r29
    1508:	cf 91       	pop	r28
    150a:	1f 91       	pop	r17
    150c:	0f 91       	pop	r16
    150e:	08 95       	ret

00001510 <vTaskStartScheduler>:
    1510:	ef 92       	push	r14
    1512:	ff 92       	push	r15
    1514:	0f 93       	push	r16
    1516:	0f 2e       	mov	r0, r31
    1518:	f0 ea       	ldi	r31, 0xA0	; 160
    151a:	ef 2e       	mov	r14, r31
    151c:	f6 e0       	ldi	r31, 0x06	; 6
    151e:	ff 2e       	mov	r15, r31
    1520:	f0 2d       	mov	r31, r0
    1522:	00 e0       	ldi	r16, 0x00	; 0
    1524:	20 e0       	ldi	r18, 0x00	; 0
    1526:	30 e0       	ldi	r19, 0x00	; 0
    1528:	45 e5       	ldi	r20, 0x55	; 85
    152a:	50 e0       	ldi	r21, 0x00	; 0
    152c:	61 e9       	ldi	r22, 0x91	; 145
    152e:	70 e0       	ldi	r23, 0x00	; 0
    1530:	81 ea       	ldi	r24, 0xA1	; 161
    1532:	98 e0       	ldi	r25, 0x08	; 8
    1534:	0e 94 25 09 	call	0x124a	; 0x124a <xTaskCreate>
    1538:	81 30       	cpi	r24, 0x01	; 1
    153a:	81 f4       	brne	.+32     	; 0x155c <vTaskStartScheduler+0x4c>
    153c:	f8 94       	cli
    153e:	8f ef       	ldi	r24, 0xFF	; 255
    1540:	9f ef       	ldi	r25, 0xFF	; 255
    1542:	90 93 a3 06 	sts	0x06A3, r25	; 0x8006a3 <xNextTaskUnblockTime+0x1>
    1546:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <xNextTaskUnblockTime>
    154a:	81 e0       	ldi	r24, 0x01	; 1
    154c:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <xSchedulerRunning>
    1550:	10 92 ab 06 	sts	0x06AB, r1	; 0x8006ab <xTickCount+0x1>
    1554:	10 92 aa 06 	sts	0x06AA, r1	; 0x8006aa <xTickCount>
    1558:	0e 94 09 05 	call	0xa12	; 0xa12 <xPortStartScheduler>
    155c:	0f 91       	pop	r16
    155e:	ff 90       	pop	r15
    1560:	ef 90       	pop	r14
    1562:	08 95       	ret

00001564 <vTaskSuspendAll>:
    1564:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <uxSchedulerSuspended>
    1568:	8f 5f       	subi	r24, 0xFF	; 255
    156a:	80 93 9f 06 	sts	0x069F, r24	; 0x80069f <uxSchedulerSuspended>
    156e:	08 95       	ret

00001570 <xTaskGetTickCount>:
    1570:	0f b6       	in	r0, 0x3f	; 63
    1572:	f8 94       	cli
    1574:	0f 92       	push	r0
    1576:	80 91 aa 06 	lds	r24, 0x06AA	; 0x8006aa <xTickCount>
    157a:	90 91 ab 06 	lds	r25, 0x06AB	; 0x8006ab <xTickCount+0x1>
    157e:	0f 90       	pop	r0
    1580:	0f be       	out	0x3f, r0	; 63
    1582:	08 95       	ret

00001584 <xTaskIncrementTick>:
    1584:	cf 92       	push	r12
    1586:	df 92       	push	r13
    1588:	ef 92       	push	r14
    158a:	ff 92       	push	r15
    158c:	0f 93       	push	r16
    158e:	1f 93       	push	r17
    1590:	cf 93       	push	r28
    1592:	df 93       	push	r29
    1594:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <uxSchedulerSuspended>
    1598:	81 11       	cpse	r24, r1
    159a:	99 c0       	rjmp	.+306    	; 0x16ce <xTaskIncrementTick+0x14a>
    159c:	e0 90 aa 06 	lds	r14, 0x06AA	; 0x8006aa <xTickCount>
    15a0:	f0 90 ab 06 	lds	r15, 0x06AB	; 0x8006ab <xTickCount+0x1>
    15a4:	8f ef       	ldi	r24, 0xFF	; 255
    15a6:	e8 1a       	sub	r14, r24
    15a8:	f8 0a       	sbc	r15, r24
    15aa:	f0 92 ab 06 	sts	0x06AB, r15	; 0x8006ab <xTickCount+0x1>
    15ae:	e0 92 aa 06 	sts	0x06AA, r14	; 0x8006aa <xTickCount>
    15b2:	e1 14       	cp	r14, r1
    15b4:	f1 04       	cpc	r15, r1
    15b6:	b9 f4       	brne	.+46     	; 0x15e6 <xTaskIncrementTick+0x62>
    15b8:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <pxDelayedTaskList>
    15bc:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <pxDelayedTaskList+0x1>
    15c0:	20 91 c9 06 	lds	r18, 0x06C9	; 0x8006c9 <pxOverflowDelayedTaskList>
    15c4:	30 91 ca 06 	lds	r19, 0x06CA	; 0x8006ca <pxOverflowDelayedTaskList+0x1>
    15c8:	30 93 cc 06 	sts	0x06CC, r19	; 0x8006cc <pxDelayedTaskList+0x1>
    15cc:	20 93 cb 06 	sts	0x06CB, r18	; 0x8006cb <pxDelayedTaskList>
    15d0:	90 93 ca 06 	sts	0x06CA, r25	; 0x8006ca <pxOverflowDelayedTaskList+0x1>
    15d4:	80 93 c9 06 	sts	0x06C9, r24	; 0x8006c9 <pxOverflowDelayedTaskList>
    15d8:	80 91 a5 06 	lds	r24, 0x06A5	; 0x8006a5 <xNumOfOverflows>
    15dc:	8f 5f       	subi	r24, 0xFF	; 255
    15de:	80 93 a5 06 	sts	0x06A5, r24	; 0x8006a5 <xNumOfOverflows>
    15e2:	0e 94 82 08 	call	0x1104	; 0x1104 <prvResetNextTaskUnblockTime>
    15e6:	80 91 a2 06 	lds	r24, 0x06A2	; 0x8006a2 <xNextTaskUnblockTime>
    15ea:	90 91 a3 06 	lds	r25, 0x06A3	; 0x8006a3 <xNextTaskUnblockTime+0x1>
    15ee:	e8 16       	cp	r14, r24
    15f0:	f9 06       	cpc	r15, r25
    15f2:	10 f4       	brcc	.+4      	; 0x15f8 <xTaskIncrementTick+0x74>
    15f4:	d1 2c       	mov	r13, r1
    15f6:	53 c0       	rjmp	.+166    	; 0x169e <xTaskIncrementTick+0x11a>
    15f8:	d1 2c       	mov	r13, r1
    15fa:	cc 24       	eor	r12, r12
    15fc:	c3 94       	inc	r12
    15fe:	e0 91 cb 06 	lds	r30, 0x06CB	; 0x8006cb <pxDelayedTaskList>
    1602:	f0 91 cc 06 	lds	r31, 0x06CC	; 0x8006cc <pxDelayedTaskList+0x1>
    1606:	80 81       	ld	r24, Z
    1608:	81 11       	cpse	r24, r1
    160a:	07 c0       	rjmp	.+14     	; 0x161a <xTaskIncrementTick+0x96>
    160c:	8f ef       	ldi	r24, 0xFF	; 255
    160e:	9f ef       	ldi	r25, 0xFF	; 255
    1610:	90 93 a3 06 	sts	0x06A3, r25	; 0x8006a3 <xNextTaskUnblockTime+0x1>
    1614:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <xNextTaskUnblockTime>
    1618:	42 c0       	rjmp	.+132    	; 0x169e <xTaskIncrementTick+0x11a>
    161a:	e0 91 cb 06 	lds	r30, 0x06CB	; 0x8006cb <pxDelayedTaskList>
    161e:	f0 91 cc 06 	lds	r31, 0x06CC	; 0x8006cc <pxDelayedTaskList+0x1>
    1622:	05 80       	ldd	r0, Z+5	; 0x05
    1624:	f6 81       	ldd	r31, Z+6	; 0x06
    1626:	e0 2d       	mov	r30, r0
    1628:	c6 81       	ldd	r28, Z+6	; 0x06
    162a:	d7 81       	ldd	r29, Z+7	; 0x07
    162c:	8a 81       	ldd	r24, Y+2	; 0x02
    162e:	9b 81       	ldd	r25, Y+3	; 0x03
    1630:	e8 16       	cp	r14, r24
    1632:	f9 06       	cpc	r15, r25
    1634:	28 f4       	brcc	.+10     	; 0x1640 <xTaskIncrementTick+0xbc>
    1636:	90 93 a3 06 	sts	0x06A3, r25	; 0x8006a3 <xNextTaskUnblockTime+0x1>
    163a:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <xNextTaskUnblockTime>
    163e:	2f c0       	rjmp	.+94     	; 0x169e <xTaskIncrementTick+0x11a>
    1640:	8e 01       	movw	r16, r28
    1642:	0e 5f       	subi	r16, 0xFE	; 254
    1644:	1f 4f       	sbci	r17, 0xFF	; 255
    1646:	c8 01       	movw	r24, r16
    1648:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
    164c:	8c 89       	ldd	r24, Y+20	; 0x14
    164e:	9d 89       	ldd	r25, Y+21	; 0x15
    1650:	89 2b       	or	r24, r25
    1652:	21 f0       	breq	.+8      	; 0x165c <xTaskIncrementTick+0xd8>
    1654:	ce 01       	movw	r24, r28
    1656:	0c 96       	adiw	r24, 0x0c	; 12
    1658:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
    165c:	8e 89       	ldd	r24, Y+22	; 0x16
    165e:	90 91 a9 06 	lds	r25, 0x06A9	; 0x8006a9 <uxTopReadyPriority>
    1662:	98 17       	cp	r25, r24
    1664:	10 f4       	brcc	.+4      	; 0x166a <xTaskIncrementTick+0xe6>
    1666:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <uxTopReadyPriority>
    166a:	90 e0       	ldi	r25, 0x00	; 0
    166c:	9c 01       	movw	r18, r24
    166e:	22 0f       	add	r18, r18
    1670:	33 1f       	adc	r19, r19
    1672:	22 0f       	add	r18, r18
    1674:	33 1f       	adc	r19, r19
    1676:	22 0f       	add	r18, r18
    1678:	33 1f       	adc	r19, r19
    167a:	82 0f       	add	r24, r18
    167c:	93 1f       	adc	r25, r19
    167e:	b8 01       	movw	r22, r16
    1680:	81 52       	subi	r24, 0x21	; 33
    1682:	99 4f       	sbci	r25, 0xF9	; 249
    1684:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    1688:	e0 91 0c 07 	lds	r30, 0x070C	; 0x80070c <pxCurrentTCB>
    168c:	f0 91 0d 07 	lds	r31, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    1690:	9e 89       	ldd	r25, Y+22	; 0x16
    1692:	86 89       	ldd	r24, Z+22	; 0x16
    1694:	98 17       	cp	r25, r24
    1696:	08 f4       	brcc	.+2      	; 0x169a <xTaskIncrementTick+0x116>
    1698:	b2 cf       	rjmp	.-156    	; 0x15fe <xTaskIncrementTick+0x7a>
    169a:	dc 2c       	mov	r13, r12
    169c:	b0 cf       	rjmp	.-160    	; 0x15fe <xTaskIncrementTick+0x7a>
    169e:	e0 91 0c 07 	lds	r30, 0x070C	; 0x80070c <pxCurrentTCB>
    16a2:	f0 91 0d 07 	lds	r31, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    16a6:	86 89       	ldd	r24, Z+22	; 0x16
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	fc 01       	movw	r30, r24
    16ac:	ee 0f       	add	r30, r30
    16ae:	ff 1f       	adc	r31, r31
    16b0:	ee 0f       	add	r30, r30
    16b2:	ff 1f       	adc	r31, r31
    16b4:	ee 0f       	add	r30, r30
    16b6:	ff 1f       	adc	r31, r31
    16b8:	8e 0f       	add	r24, r30
    16ba:	9f 1f       	adc	r25, r31
    16bc:	fc 01       	movw	r30, r24
    16be:	e1 52       	subi	r30, 0x21	; 33
    16c0:	f9 4f       	sbci	r31, 0xF9	; 249
    16c2:	80 81       	ld	r24, Z
    16c4:	82 30       	cpi	r24, 0x02	; 2
    16c6:	48 f0       	brcs	.+18     	; 0x16da <xTaskIncrementTick+0x156>
    16c8:	dd 24       	eor	r13, r13
    16ca:	d3 94       	inc	r13
    16cc:	06 c0       	rjmp	.+12     	; 0x16da <xTaskIncrementTick+0x156>
    16ce:	80 91 a7 06 	lds	r24, 0x06A7	; 0x8006a7 <uxPendedTicks>
    16d2:	8f 5f       	subi	r24, 0xFF	; 255
    16d4:	80 93 a7 06 	sts	0x06A7, r24	; 0x8006a7 <uxPendedTicks>
    16d8:	d1 2c       	mov	r13, r1
    16da:	80 91 a6 06 	lds	r24, 0x06A6	; 0x8006a6 <xYieldPending>
    16de:	88 23       	and	r24, r24
    16e0:	11 f0       	breq	.+4      	; 0x16e6 <xTaskIncrementTick+0x162>
    16e2:	dd 24       	eor	r13, r13
    16e4:	d3 94       	inc	r13
    16e6:	8d 2d       	mov	r24, r13
    16e8:	df 91       	pop	r29
    16ea:	cf 91       	pop	r28
    16ec:	1f 91       	pop	r17
    16ee:	0f 91       	pop	r16
    16f0:	ff 90       	pop	r15
    16f2:	ef 90       	pop	r14
    16f4:	df 90       	pop	r13
    16f6:	cf 90       	pop	r12
    16f8:	08 95       	ret

000016fa <xTaskResumeAll>:
    16fa:	df 92       	push	r13
    16fc:	ef 92       	push	r14
    16fe:	ff 92       	push	r15
    1700:	0f 93       	push	r16
    1702:	1f 93       	push	r17
    1704:	cf 93       	push	r28
    1706:	df 93       	push	r29
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	0f 92       	push	r0
    170e:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <uxSchedulerSuspended>
    1712:	81 50       	subi	r24, 0x01	; 1
    1714:	80 93 9f 06 	sts	0x069F, r24	; 0x80069f <uxSchedulerSuspended>
    1718:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <uxSchedulerSuspended>
    171c:	81 11       	cpse	r24, r1
    171e:	5f c0       	rjmp	.+190    	; 0x17de <xTaskResumeAll+0xe4>
    1720:	80 91 ac 06 	lds	r24, 0x06AC	; 0x8006ac <uxCurrentNumberOfTasks>
    1724:	81 11       	cpse	r24, r1
    1726:	33 c0       	rjmp	.+102    	; 0x178e <xTaskResumeAll+0x94>
    1728:	5d c0       	rjmp	.+186    	; 0x17e4 <xTaskResumeAll+0xea>
    172a:	d7 01       	movw	r26, r14
    172c:	15 96       	adiw	r26, 0x05	; 5
    172e:	ed 91       	ld	r30, X+
    1730:	fc 91       	ld	r31, X
    1732:	16 97       	sbiw	r26, 0x06	; 6
    1734:	c6 81       	ldd	r28, Z+6	; 0x06
    1736:	d7 81       	ldd	r29, Z+7	; 0x07
    1738:	ce 01       	movw	r24, r28
    173a:	0c 96       	adiw	r24, 0x0c	; 12
    173c:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
    1740:	8e 01       	movw	r16, r28
    1742:	0e 5f       	subi	r16, 0xFE	; 254
    1744:	1f 4f       	sbci	r17, 0xFF	; 255
    1746:	c8 01       	movw	r24, r16
    1748:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
    174c:	8e 89       	ldd	r24, Y+22	; 0x16
    174e:	90 91 a9 06 	lds	r25, 0x06A9	; 0x8006a9 <uxTopReadyPriority>
    1752:	98 17       	cp	r25, r24
    1754:	10 f4       	brcc	.+4      	; 0x175a <xTaskResumeAll+0x60>
    1756:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <uxTopReadyPriority>
    175a:	90 e0       	ldi	r25, 0x00	; 0
    175c:	9c 01       	movw	r18, r24
    175e:	22 0f       	add	r18, r18
    1760:	33 1f       	adc	r19, r19
    1762:	22 0f       	add	r18, r18
    1764:	33 1f       	adc	r19, r19
    1766:	22 0f       	add	r18, r18
    1768:	33 1f       	adc	r19, r19
    176a:	82 0f       	add	r24, r18
    176c:	93 1f       	adc	r25, r19
    176e:	b8 01       	movw	r22, r16
    1770:	81 52       	subi	r24, 0x21	; 33
    1772:	99 4f       	sbci	r25, 0xF9	; 249
    1774:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    1778:	e0 91 0c 07 	lds	r30, 0x070C	; 0x80070c <pxCurrentTCB>
    177c:	f0 91 0d 07 	lds	r31, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    1780:	9e 89       	ldd	r25, Y+22	; 0x16
    1782:	86 89       	ldd	r24, Z+22	; 0x16
    1784:	98 17       	cp	r25, r24
    1786:	68 f0       	brcs	.+26     	; 0x17a2 <xTaskResumeAll+0xa8>
    1788:	d0 92 a6 06 	sts	0x06A6, r13	; 0x8006a6 <xYieldPending>
    178c:	0a c0       	rjmp	.+20     	; 0x17a2 <xTaskResumeAll+0xa8>
    178e:	c0 e0       	ldi	r28, 0x00	; 0
    1790:	d0 e0       	ldi	r29, 0x00	; 0
    1792:	0f 2e       	mov	r0, r31
    1794:	f0 ec       	ldi	r31, 0xC0	; 192
    1796:	ef 2e       	mov	r14, r31
    1798:	f6 e0       	ldi	r31, 0x06	; 6
    179a:	ff 2e       	mov	r15, r31
    179c:	f0 2d       	mov	r31, r0
    179e:	dd 24       	eor	r13, r13
    17a0:	d3 94       	inc	r13
    17a2:	f7 01       	movw	r30, r14
    17a4:	80 81       	ld	r24, Z
    17a6:	81 11       	cpse	r24, r1
    17a8:	c0 cf       	rjmp	.-128    	; 0x172a <xTaskResumeAll+0x30>
    17aa:	cd 2b       	or	r28, r29
    17ac:	11 f0       	breq	.+4      	; 0x17b2 <xTaskResumeAll+0xb8>
    17ae:	0e 94 82 08 	call	0x1104	; 0x1104 <prvResetNextTaskUnblockTime>
    17b2:	c0 91 a7 06 	lds	r28, 0x06A7	; 0x8006a7 <uxPendedTicks>
    17b6:	cc 23       	and	r28, r28
    17b8:	51 f0       	breq	.+20     	; 0x17ce <xTaskResumeAll+0xd4>
    17ba:	d1 e0       	ldi	r29, 0x01	; 1
    17bc:	0e 94 c2 0a 	call	0x1584	; 0x1584 <xTaskIncrementTick>
    17c0:	81 11       	cpse	r24, r1
    17c2:	d0 93 a6 06 	sts	0x06A6, r29	; 0x8006a6 <xYieldPending>
    17c6:	c1 50       	subi	r28, 0x01	; 1
    17c8:	c9 f7       	brne	.-14     	; 0x17bc <xTaskResumeAll+0xc2>
    17ca:	10 92 a7 06 	sts	0x06A7, r1	; 0x8006a7 <uxPendedTicks>
    17ce:	80 91 a6 06 	lds	r24, 0x06A6	; 0x8006a6 <xYieldPending>
    17d2:	88 23       	and	r24, r24
    17d4:	31 f0       	breq	.+12     	; 0x17e2 <xTaskResumeAll+0xe8>
    17d6:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
    17da:	81 e0       	ldi	r24, 0x01	; 1
    17dc:	03 c0       	rjmp	.+6      	; 0x17e4 <xTaskResumeAll+0xea>
    17de:	80 e0       	ldi	r24, 0x00	; 0
    17e0:	01 c0       	rjmp	.+2      	; 0x17e4 <xTaskResumeAll+0xea>
    17e2:	80 e0       	ldi	r24, 0x00	; 0
    17e4:	0f 90       	pop	r0
    17e6:	0f be       	out	0x3f, r0	; 63
    17e8:	df 91       	pop	r29
    17ea:	cf 91       	pop	r28
    17ec:	1f 91       	pop	r17
    17ee:	0f 91       	pop	r16
    17f0:	ff 90       	pop	r15
    17f2:	ef 90       	pop	r14
    17f4:	df 90       	pop	r13
    17f6:	08 95       	ret

000017f8 <vTaskDelayUntil>:
    17f8:	0f 93       	push	r16
    17fa:	1f 93       	push	r17
    17fc:	cf 93       	push	r28
    17fe:	df 93       	push	r29
    1800:	8c 01       	movw	r16, r24
    1802:	eb 01       	movw	r28, r22
    1804:	0e 94 b2 0a 	call	0x1564	; 0x1564 <vTaskSuspendAll>
    1808:	40 91 aa 06 	lds	r20, 0x06AA	; 0x8006aa <xTickCount>
    180c:	50 91 ab 06 	lds	r21, 0x06AB	; 0x8006ab <xTickCount+0x1>
    1810:	f8 01       	movw	r30, r16
    1812:	20 81       	ld	r18, Z
    1814:	31 81       	ldd	r19, Z+1	; 0x01
    1816:	c9 01       	movw	r24, r18
    1818:	8c 0f       	add	r24, r28
    181a:	9d 1f       	adc	r25, r29
    181c:	42 17       	cp	r20, r18
    181e:	53 07       	cpc	r21, r19
    1820:	48 f4       	brcc	.+18     	; 0x1834 <vTaskDelayUntil+0x3c>
    1822:	82 17       	cp	r24, r18
    1824:	93 07       	cpc	r25, r19
    1826:	e8 f4       	brcc	.+58     	; 0x1862 <vTaskDelayUntil+0x6a>
    1828:	91 83       	std	Z+1, r25	; 0x01
    182a:	80 83       	st	Z, r24
    182c:	48 17       	cp	r20, r24
    182e:	59 07       	cpc	r21, r25
    1830:	68 f4       	brcc	.+26     	; 0x184c <vTaskDelayUntil+0x54>
    1832:	07 c0       	rjmp	.+14     	; 0x1842 <vTaskDelayUntil+0x4a>
    1834:	82 17       	cp	r24, r18
    1836:	93 07       	cpc	r25, r19
    1838:	80 f0       	brcs	.+32     	; 0x185a <vTaskDelayUntil+0x62>
    183a:	48 17       	cp	r20, r24
    183c:	59 07       	cpc	r21, r25
    183e:	68 f0       	brcs	.+26     	; 0x185a <vTaskDelayUntil+0x62>
    1840:	10 c0       	rjmp	.+32     	; 0x1862 <vTaskDelayUntil+0x6a>
    1842:	60 e0       	ldi	r22, 0x00	; 0
    1844:	84 1b       	sub	r24, r20
    1846:	95 0b       	sbc	r25, r21
    1848:	0e 94 cd 08 	call	0x119a	; 0x119a <prvAddCurrentTaskToDelayedList>
    184c:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskResumeAll>
    1850:	81 11       	cpse	r24, r1
    1852:	0b c0       	rjmp	.+22     	; 0x186a <vTaskDelayUntil+0x72>
    1854:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
    1858:	08 c0       	rjmp	.+16     	; 0x186a <vTaskDelayUntil+0x72>
    185a:	f8 01       	movw	r30, r16
    185c:	91 83       	std	Z+1, r25	; 0x01
    185e:	80 83       	st	Z, r24
    1860:	f0 cf       	rjmp	.-32     	; 0x1842 <vTaskDelayUntil+0x4a>
    1862:	f8 01       	movw	r30, r16
    1864:	91 83       	std	Z+1, r25	; 0x01
    1866:	80 83       	st	Z, r24
    1868:	f1 cf       	rjmp	.-30     	; 0x184c <vTaskDelayUntil+0x54>
    186a:	df 91       	pop	r29
    186c:	cf 91       	pop	r28
    186e:	1f 91       	pop	r17
    1870:	0f 91       	pop	r16
    1872:	08 95       	ret

00001874 <vTaskDelay>:
    1874:	cf 93       	push	r28
    1876:	df 93       	push	r29
    1878:	ec 01       	movw	r28, r24
    187a:	89 2b       	or	r24, r25
    187c:	51 f0       	breq	.+20     	; 0x1892 <vTaskDelay+0x1e>
    187e:	0e 94 b2 0a 	call	0x1564	; 0x1564 <vTaskSuspendAll>
    1882:	60 e0       	ldi	r22, 0x00	; 0
    1884:	ce 01       	movw	r24, r28
    1886:	0e 94 cd 08 	call	0x119a	; 0x119a <prvAddCurrentTaskToDelayedList>
    188a:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskResumeAll>
    188e:	81 11       	cpse	r24, r1
    1890:	02 c0       	rjmp	.+4      	; 0x1896 <vTaskDelay+0x22>
    1892:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
    1896:	df 91       	pop	r29
    1898:	cf 91       	pop	r28
    189a:	08 95       	ret

0000189c <vTaskSwitchContext>:
    189c:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <uxSchedulerSuspended>
    18a0:	88 23       	and	r24, r24
    18a2:	21 f0       	breq	.+8      	; 0x18ac <vTaskSwitchContext+0x10>
    18a4:	81 e0       	ldi	r24, 0x01	; 1
    18a6:	80 93 a6 06 	sts	0x06A6, r24	; 0x8006a6 <xYieldPending>
    18aa:	08 95       	ret
    18ac:	10 92 a6 06 	sts	0x06A6, r1	; 0x8006a6 <xYieldPending>
    18b0:	20 91 a9 06 	lds	r18, 0x06A9	; 0x8006a9 <uxTopReadyPriority>
    18b4:	82 2f       	mov	r24, r18
    18b6:	90 e0       	ldi	r25, 0x00	; 0
    18b8:	fc 01       	movw	r30, r24
    18ba:	ee 0f       	add	r30, r30
    18bc:	ff 1f       	adc	r31, r31
    18be:	ee 0f       	add	r30, r30
    18c0:	ff 1f       	adc	r31, r31
    18c2:	ee 0f       	add	r30, r30
    18c4:	ff 1f       	adc	r31, r31
    18c6:	e8 0f       	add	r30, r24
    18c8:	f9 1f       	adc	r31, r25
    18ca:	e1 52       	subi	r30, 0x21	; 33
    18cc:	f9 4f       	sbci	r31, 0xF9	; 249
    18ce:	30 81       	ld	r19, Z
    18d0:	31 11       	cpse	r19, r1
    18d2:	11 c0       	rjmp	.+34     	; 0x18f6 <vTaskSwitchContext+0x5a>
    18d4:	21 50       	subi	r18, 0x01	; 1
    18d6:	82 2f       	mov	r24, r18
    18d8:	90 e0       	ldi	r25, 0x00	; 0
    18da:	fc 01       	movw	r30, r24
    18dc:	ee 0f       	add	r30, r30
    18de:	ff 1f       	adc	r31, r31
    18e0:	ee 0f       	add	r30, r30
    18e2:	ff 1f       	adc	r31, r31
    18e4:	ee 0f       	add	r30, r30
    18e6:	ff 1f       	adc	r31, r31
    18e8:	e8 0f       	add	r30, r24
    18ea:	f9 1f       	adc	r31, r25
    18ec:	e1 52       	subi	r30, 0x21	; 33
    18ee:	f9 4f       	sbci	r31, 0xF9	; 249
    18f0:	30 81       	ld	r19, Z
    18f2:	33 23       	and	r19, r19
    18f4:	79 f3       	breq	.-34     	; 0x18d4 <vTaskSwitchContext+0x38>
    18f6:	ac 01       	movw	r20, r24
    18f8:	44 0f       	add	r20, r20
    18fa:	55 1f       	adc	r21, r21
    18fc:	44 0f       	add	r20, r20
    18fe:	55 1f       	adc	r21, r21
    1900:	44 0f       	add	r20, r20
    1902:	55 1f       	adc	r21, r21
    1904:	48 0f       	add	r20, r24
    1906:	59 1f       	adc	r21, r25
    1908:	da 01       	movw	r26, r20
    190a:	a1 52       	subi	r26, 0x21	; 33
    190c:	b9 4f       	sbci	r27, 0xF9	; 249
    190e:	11 96       	adiw	r26, 0x01	; 1
    1910:	ed 91       	ld	r30, X+
    1912:	fc 91       	ld	r31, X
    1914:	12 97       	sbiw	r26, 0x02	; 2
    1916:	02 80       	ldd	r0, Z+2	; 0x02
    1918:	f3 81       	ldd	r31, Z+3	; 0x03
    191a:	e0 2d       	mov	r30, r0
    191c:	12 96       	adiw	r26, 0x02	; 2
    191e:	fc 93       	st	X, r31
    1920:	ee 93       	st	-X, r30
    1922:	11 97       	sbiw	r26, 0x01	; 1
    1924:	4e 51       	subi	r20, 0x1E	; 30
    1926:	59 4f       	sbci	r21, 0xF9	; 249
    1928:	e4 17       	cp	r30, r20
    192a:	f5 07       	cpc	r31, r21
    192c:	29 f4       	brne	.+10     	; 0x1938 <vTaskSwitchContext+0x9c>
    192e:	42 81       	ldd	r20, Z+2	; 0x02
    1930:	53 81       	ldd	r21, Z+3	; 0x03
    1932:	fd 01       	movw	r30, r26
    1934:	52 83       	std	Z+2, r21	; 0x02
    1936:	41 83       	std	Z+1, r20	; 0x01
    1938:	fc 01       	movw	r30, r24
    193a:	ee 0f       	add	r30, r30
    193c:	ff 1f       	adc	r31, r31
    193e:	ee 0f       	add	r30, r30
    1940:	ff 1f       	adc	r31, r31
    1942:	ee 0f       	add	r30, r30
    1944:	ff 1f       	adc	r31, r31
    1946:	8e 0f       	add	r24, r30
    1948:	9f 1f       	adc	r25, r31
    194a:	fc 01       	movw	r30, r24
    194c:	e1 52       	subi	r30, 0x21	; 33
    194e:	f9 4f       	sbci	r31, 0xF9	; 249
    1950:	01 80       	ldd	r0, Z+1	; 0x01
    1952:	f2 81       	ldd	r31, Z+2	; 0x02
    1954:	e0 2d       	mov	r30, r0
    1956:	86 81       	ldd	r24, Z+6	; 0x06
    1958:	97 81       	ldd	r25, Z+7	; 0x07
    195a:	90 93 0d 07 	sts	0x070D, r25	; 0x80070d <pxCurrentTCB+0x1>
    195e:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <pxCurrentTCB>
    1962:	20 93 a9 06 	sts	0x06A9, r18	; 0x8006a9 <uxTopReadyPriority>
    1966:	08 95       	ret

00001968 <vTaskSuspend>:
    1968:	0f 93       	push	r16
    196a:	1f 93       	push	r17
    196c:	cf 93       	push	r28
    196e:	df 93       	push	r29
    1970:	ec 01       	movw	r28, r24
    1972:	0f b6       	in	r0, 0x3f	; 63
    1974:	f8 94       	cli
    1976:	0f 92       	push	r0
    1978:	89 2b       	or	r24, r25
    197a:	21 f4       	brne	.+8      	; 0x1984 <vTaskSuspend+0x1c>
    197c:	c0 91 0c 07 	lds	r28, 0x070C	; 0x80070c <pxCurrentTCB>
    1980:	d0 91 0d 07 	lds	r29, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    1984:	8e 01       	movw	r16, r28
    1986:	0e 5f       	subi	r16, 0xFE	; 254
    1988:	1f 4f       	sbci	r17, 0xFF	; 255
    198a:	c8 01       	movw	r24, r16
    198c:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
    1990:	8c 89       	ldd	r24, Y+20	; 0x14
    1992:	9d 89       	ldd	r25, Y+21	; 0x15
    1994:	89 2b       	or	r24, r25
    1996:	21 f0       	breq	.+8      	; 0x19a0 <vTaskSuspend+0x38>
    1998:	ce 01       	movw	r24, r28
    199a:	0c 96       	adiw	r24, 0x0c	; 12
    199c:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
    19a0:	b8 01       	movw	r22, r16
    19a2:	8d ea       	ldi	r24, 0xAD	; 173
    19a4:	96 e0       	ldi	r25, 0x06	; 6
    19a6:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    19aa:	8d a1       	ldd	r24, Y+37	; 0x25
    19ac:	81 30       	cpi	r24, 0x01	; 1
    19ae:	09 f4       	brne	.+2      	; 0x19b2 <vTaskSuspend+0x4a>
    19b0:	1d a2       	std	Y+37, r1	; 0x25
    19b2:	0f 90       	pop	r0
    19b4:	0f be       	out	0x3f, r0	; 63
    19b6:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <xSchedulerRunning>
    19ba:	88 23       	and	r24, r24
    19bc:	39 f0       	breq	.+14     	; 0x19cc <vTaskSuspend+0x64>
    19be:	0f b6       	in	r0, 0x3f	; 63
    19c0:	f8 94       	cli
    19c2:	0f 92       	push	r0
    19c4:	0e 94 82 08 	call	0x1104	; 0x1104 <prvResetNextTaskUnblockTime>
    19c8:	0f 90       	pop	r0
    19ca:	0f be       	out	0x3f, r0	; 63
    19cc:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <pxCurrentTCB>
    19d0:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    19d4:	c8 17       	cp	r28, r24
    19d6:	d9 07       	cpc	r29, r25
    19d8:	a1 f4       	brne	.+40     	; 0x1a02 <vTaskSuspend+0x9a>
    19da:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <xSchedulerRunning>
    19de:	88 23       	and	r24, r24
    19e0:	19 f0       	breq	.+6      	; 0x19e8 <vTaskSuspend+0x80>
    19e2:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vPortYield>
    19e6:	0d c0       	rjmp	.+26     	; 0x1a02 <vTaskSuspend+0x9a>
    19e8:	90 91 ad 06 	lds	r25, 0x06AD	; 0x8006ad <xSuspendedTaskList>
    19ec:	80 91 ac 06 	lds	r24, 0x06AC	; 0x8006ac <uxCurrentNumberOfTasks>
    19f0:	98 13       	cpse	r25, r24
    19f2:	05 c0       	rjmp	.+10     	; 0x19fe <vTaskSuspend+0x96>
    19f4:	10 92 0d 07 	sts	0x070D, r1	; 0x80070d <pxCurrentTCB+0x1>
    19f8:	10 92 0c 07 	sts	0x070C, r1	; 0x80070c <pxCurrentTCB>
    19fc:	02 c0       	rjmp	.+4      	; 0x1a02 <vTaskSuspend+0x9a>
    19fe:	0e 94 4e 0c 	call	0x189c	; 0x189c <vTaskSwitchContext>
    1a02:	df 91       	pop	r29
    1a04:	cf 91       	pop	r28
    1a06:	1f 91       	pop	r17
    1a08:	0f 91       	pop	r16
    1a0a:	08 95       	ret

00001a0c <vTaskPlaceOnEventList>:
    1a0c:	cf 93       	push	r28
    1a0e:	df 93       	push	r29
    1a10:	eb 01       	movw	r28, r22
    1a12:	60 91 0c 07 	lds	r22, 0x070C	; 0x80070c <pxCurrentTCB>
    1a16:	70 91 0d 07 	lds	r23, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    1a1a:	64 5f       	subi	r22, 0xF4	; 244
    1a1c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a1e:	0e 94 45 04 	call	0x88a	; 0x88a <vListInsert>
    1a22:	61 e0       	ldi	r22, 0x01	; 1
    1a24:	ce 01       	movw	r24, r28
    1a26:	0e 94 cd 08 	call	0x119a	; 0x119a <prvAddCurrentTaskToDelayedList>
    1a2a:	df 91       	pop	r29
    1a2c:	cf 91       	pop	r28
    1a2e:	08 95       	ret

00001a30 <xTaskRemoveFromEventList>:
    1a30:	0f 93       	push	r16
    1a32:	1f 93       	push	r17
    1a34:	cf 93       	push	r28
    1a36:	df 93       	push	r29
    1a38:	dc 01       	movw	r26, r24
    1a3a:	15 96       	adiw	r26, 0x05	; 5
    1a3c:	ed 91       	ld	r30, X+
    1a3e:	fc 91       	ld	r31, X
    1a40:	16 97       	sbiw	r26, 0x06	; 6
    1a42:	c6 81       	ldd	r28, Z+6	; 0x06
    1a44:	d7 81       	ldd	r29, Z+7	; 0x07
    1a46:	8e 01       	movw	r16, r28
    1a48:	04 5f       	subi	r16, 0xF4	; 244
    1a4a:	1f 4f       	sbci	r17, 0xFF	; 255
    1a4c:	c8 01       	movw	r24, r16
    1a4e:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
    1a52:	80 91 9f 06 	lds	r24, 0x069F	; 0x80069f <uxSchedulerSuspended>
    1a56:	81 11       	cpse	r24, r1
    1a58:	1c c0       	rjmp	.+56     	; 0x1a92 <xTaskRemoveFromEventList+0x62>
    1a5a:	0a 50       	subi	r16, 0x0A	; 10
    1a5c:	11 09       	sbc	r17, r1
    1a5e:	c8 01       	movw	r24, r16
    1a60:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
    1a64:	8e 89       	ldd	r24, Y+22	; 0x16
    1a66:	90 91 a9 06 	lds	r25, 0x06A9	; 0x8006a9 <uxTopReadyPriority>
    1a6a:	98 17       	cp	r25, r24
    1a6c:	10 f4       	brcc	.+4      	; 0x1a72 <xTaskRemoveFromEventList+0x42>
    1a6e:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <uxTopReadyPriority>
    1a72:	90 e0       	ldi	r25, 0x00	; 0
    1a74:	9c 01       	movw	r18, r24
    1a76:	22 0f       	add	r18, r18
    1a78:	33 1f       	adc	r19, r19
    1a7a:	22 0f       	add	r18, r18
    1a7c:	33 1f       	adc	r19, r19
    1a7e:	22 0f       	add	r18, r18
    1a80:	33 1f       	adc	r19, r19
    1a82:	82 0f       	add	r24, r18
    1a84:	93 1f       	adc	r25, r19
    1a86:	b8 01       	movw	r22, r16
    1a88:	81 52       	subi	r24, 0x21	; 33
    1a8a:	99 4f       	sbci	r25, 0xF9	; 249
    1a8c:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    1a90:	05 c0       	rjmp	.+10     	; 0x1a9c <xTaskRemoveFromEventList+0x6c>
    1a92:	b8 01       	movw	r22, r16
    1a94:	80 ec       	ldi	r24, 0xC0	; 192
    1a96:	96 e0       	ldi	r25, 0x06	; 6
    1a98:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    1a9c:	e0 91 0c 07 	lds	r30, 0x070C	; 0x80070c <pxCurrentTCB>
    1aa0:	f0 91 0d 07 	lds	r31, 0x070D	; 0x80070d <pxCurrentTCB+0x1>
    1aa4:	9e 89       	ldd	r25, Y+22	; 0x16
    1aa6:	86 89       	ldd	r24, Z+22	; 0x16
    1aa8:	89 17       	cp	r24, r25
    1aaa:	20 f4       	brcc	.+8      	; 0x1ab4 <xTaskRemoveFromEventList+0x84>
    1aac:	81 e0       	ldi	r24, 0x01	; 1
    1aae:	80 93 a6 06 	sts	0x06A6, r24	; 0x8006a6 <xYieldPending>
    1ab2:	01 c0       	rjmp	.+2      	; 0x1ab6 <xTaskRemoveFromEventList+0x86>
    1ab4:	80 e0       	ldi	r24, 0x00	; 0
    1ab6:	df 91       	pop	r29
    1ab8:	cf 91       	pop	r28
    1aba:	1f 91       	pop	r17
    1abc:	0f 91       	pop	r16
    1abe:	08 95       	ret

00001ac0 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1ac0:	20 91 a5 06 	lds	r18, 0x06A5	; 0x8006a5 <xNumOfOverflows>
    1ac4:	fc 01       	movw	r30, r24
    1ac6:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1ac8:	20 91 aa 06 	lds	r18, 0x06AA	; 0x8006aa <xTickCount>
    1acc:	30 91 ab 06 	lds	r19, 0x06AB	; 0x8006ab <xTickCount+0x1>
    1ad0:	32 83       	std	Z+2, r19	; 0x02
    1ad2:	21 83       	std	Z+1, r18	; 0x01
    1ad4:	08 95       	ret

00001ad6 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1ad6:	cf 93       	push	r28
    1ad8:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1ada:	0f b6       	in	r0, 0x3f	; 63
    1adc:	f8 94       	cli
    1ade:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1ae0:	20 91 aa 06 	lds	r18, 0x06AA	; 0x8006aa <xTickCount>
    1ae4:	30 91 ab 06 	lds	r19, 0x06AB	; 0x8006ab <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    1ae8:	db 01       	movw	r26, r22
    1aea:	4d 91       	ld	r20, X+
    1aec:	5c 91       	ld	r21, X
    1aee:	4f 3f       	cpi	r20, 0xFF	; 255
    1af0:	bf ef       	ldi	r27, 0xFF	; 255
    1af2:	5b 07       	cpc	r21, r27
    1af4:	f1 f0       	breq	.+60     	; 0x1b32 <xTaskCheckForTimeOut+0x5c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1af6:	ec 01       	movw	r28, r24
    1af8:	e9 81       	ldd	r30, Y+1	; 0x01
    1afa:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1afc:	a0 91 a5 06 	lds	r26, 0x06A5	; 0x8006a5 <xNumOfOverflows>
    1b00:	b8 81       	ld	r27, Y
    1b02:	ba 17       	cp	r27, r26
    1b04:	19 f0       	breq	.+6      	; 0x1b0c <xTaskCheckForTimeOut+0x36>
    1b06:	2e 17       	cp	r18, r30
    1b08:	3f 07       	cpc	r19, r31
    1b0a:	a8 f4       	brcc	.+42     	; 0x1b36 <xTaskCheckForTimeOut+0x60>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1b0c:	2e 1b       	sub	r18, r30
    1b0e:	3f 0b       	sbc	r19, r31
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1b10:	24 17       	cp	r18, r20
    1b12:	35 07       	cpc	r19, r21
    1b14:	48 f4       	brcc	.+18     	; 0x1b28 <xTaskCheckForTimeOut+0x52>
    1b16:	fb 01       	movw	r30, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    1b18:	42 1b       	sub	r20, r18
    1b1a:	53 0b       	sbc	r21, r19
    1b1c:	51 83       	std	Z+1, r21	; 0x01
    1b1e:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    1b20:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    1b24:	80 e0       	ldi	r24, 0x00	; 0
    1b26:	08 c0       	rjmp	.+16     	; 0x1b38 <xTaskCheckForTimeOut+0x62>
		}
		else
		{
			*pxTicksToWait = 0;
    1b28:	fb 01       	movw	r30, r22
    1b2a:	11 82       	std	Z+1, r1	; 0x01
    1b2c:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    1b2e:	81 e0       	ldi	r24, 0x01	; 1
    1b30:	03 c0       	rjmp	.+6      	; 0x1b38 <xTaskCheckForTimeOut+0x62>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    1b32:	80 e0       	ldi	r24, 0x00	; 0
    1b34:	01 c0       	rjmp	.+2      	; 0x1b38 <xTaskCheckForTimeOut+0x62>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1b36:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1b38:	0f 90       	pop	r0
    1b3a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1b3c:	df 91       	pop	r29
    1b3e:	cf 91       	pop	r28
    1b40:	08 95       	ret

00001b42 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1b42:	81 e0       	ldi	r24, 0x01	; 1
    1b44:	80 93 a6 06 	sts	0x06A6, r24	; 0x8006a6 <xYieldPending>
    1b48:	08 95       	ret

00001b4a <memcpy>:
    1b4a:	fb 01       	movw	r30, r22
    1b4c:	dc 01       	movw	r26, r24
    1b4e:	02 c0       	rjmp	.+4      	; 0x1b54 <memcpy+0xa>
    1b50:	01 90       	ld	r0, Z+
    1b52:	0d 92       	st	X+, r0
    1b54:	41 50       	subi	r20, 0x01	; 1
    1b56:	50 40       	sbci	r21, 0x00	; 0
    1b58:	d8 f7       	brcc	.-10     	; 0x1b50 <memcpy+0x6>
    1b5a:	08 95       	ret

00001b5c <_exit>:
    1b5c:	f8 94       	cli

00001b5e <__stop_program>:
    1b5e:	ff cf       	rjmp	.-2      	; 0x1b5e <__stop_program>
