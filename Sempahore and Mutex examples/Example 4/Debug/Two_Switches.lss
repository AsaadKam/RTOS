
Two_Switches.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001bee  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000036  00800060  00001bee  00001c82  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000665  00800096  00800096  00001cb8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001cb8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001ce8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003e8  00000000  00000000  00001d24  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000510b  00000000  00000000  0000210c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001298  00000000  00000000  00007217  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000308b  00000000  00000000  000084af  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b94  00000000  00000000  0000b53c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000186a  00000000  00000000  0000c0d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000050f4  00000000  00000000  0000d93a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000430  00000000  00000000  00012a2e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 59 06 	jmp	0xcb2	; 0xcb2 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee ee       	ldi	r30, 0xEE	; 238
      68:	fb e1       	ldi	r31, 0x1B	; 27
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a6 39       	cpi	r26, 0x96	; 150
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	26 e0       	ldi	r18, 0x06	; 6
      78:	a6 e9       	ldi	r26, 0x96	; 150
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ab 3f       	cpi	r26, 0xFB	; 251
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 06 02 	call	0x40c	; 0x40c <main>
      8a:	0c 94 f5 0d 	jmp	0x1bea	; 0x1bea <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <System_Init>:
						 
void System_Init (void *Pv_Parameter)             /**     No  Periodicity         -- Priority is 4**//**Execution time range micro    **/
{
    uinteg8_t gu8_LCD_Status=0;

	vTaskSuspend(Monitoring_Handler);
      92:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <__data_end>
      96:	90 91 97 00 	lds	r25, 0x0097	; 0x800097 <__data_end+0x1>
      9a:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vTaskSuspend>
	vTaskSuspend(Led_On_Off_Handler);
      9e:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <Led_On_Off_Handler>
      a2:	90 91 9f 00 	lds	r25, 0x009F	; 0x80009f <Led_On_Off_Handler+0x1>
      a6:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vTaskSuspend>
	vTaskSuspend(Switch0_Handler);
      aa:	80 91 9a 00 	lds	r24, 0x009A	; 0x80009a <Switch0_Handler>
      ae:	90 91 9b 00 	lds	r25, 0x009B	; 0x80009b <Switch0_Handler+0x1>
      b2:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vTaskSuspend>
	vTaskSuspend(Switch1_Handler);	
      b6:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <Switch1_Handler>
      ba:	90 91 99 00 	lds	r25, 0x0099	; 0x800099 <Switch1_Handler+0x1>
      be:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vTaskSuspend>
		
	while(1)
	{
	    LCD_init();
      c2:	0e 94 8e 02 	call	0x51c	; 0x51c <LCD_init>
		Switch_init(switch0);
      c6:	60 e0       	ldi	r22, 0x00	; 0
      c8:	88 e0       	ldi	r24, 0x08	; 8
      ca:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_Init_Pin>
		Switch_init(switch1);		
      ce:	60 e0       	ldi	r22, 0x00	; 0
      d0:	89 e0       	ldi	r24, 0x09	; 9
      d2:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_Init_Pin>
		Led_init(LED0);
      d6:	61 e0       	ldi	r22, 0x01	; 1
      d8:	8a e0       	ldi	r24, 0x0A	; 10
      da:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_Init_Pin>
		Led_init(LED1);		
      de:	61 e0       	ldi	r22, 0x01	; 1
      e0:	8b e0       	ldi	r24, 0x0B	; 11
      e2:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_Init_Pin>
		vTaskResume(Monitoring_Handler);
      e6:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <__data_end>
      ea:	90 91 97 00 	lds	r25, 0x0097	; 0x800097 <__data_end+0x1>
      ee:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vTaskResume>
		vTaskResume(Led_On_Off_Handler);
      f2:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <Led_On_Off_Handler>
      f6:	90 91 9f 00 	lds	r25, 0x009F	; 0x80009f <Led_On_Off_Handler+0x1>
      fa:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vTaskResume>
		vTaskResume(Switch0_Handler);		
      fe:	80 91 9a 00 	lds	r24, 0x009A	; 0x80009a <Switch0_Handler>
     102:	90 91 9b 00 	lds	r25, 0x009B	; 0x80009b <Switch0_Handler+0x1>
     106:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vTaskResume>
		vTaskResume(Switch1_Handler);			
     10a:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <Switch1_Handler>
     10e:	90 91 99 00 	lds	r25, 0x0099	; 0x800099 <Switch1_Handler+0x1>
     112:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vTaskResume>
		vTaskSuspend(SYS_Handler);
     116:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <SYS_Handler>
     11a:	90 91 9d 00 	lds	r25, 0x009D	; 0x80009d <SYS_Handler+0x1>
     11e:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vTaskSuspend>
     122:	cf cf       	rjmp	.-98     	; 0xc2 <System_Init+0x30>

00000124 <Check_Switch0>:
	}
}

void Check_Switch0(void*Pv_Parameter)             /** Periodicity 50 milisecond   -- Priority is 3**//**Execution time range micro    **/
{
     124:	cf 93       	push	r28
     126:	df 93       	push	r29
     128:	00 d0       	rcall	.+0      	; 0x12a <Check_Switch0+0x6>
     12a:	1f 92       	push	r1
     12c:	cd b7       	in	r28, 0x3d	; 61
     12e:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 50;
    Switch0_Couting_Semaphore=xSemaphoreCreateCounting(2,0);		
     130:	60 e0       	ldi	r22, 0x00	; 0
     132:	82 e0       	ldi	r24, 0x02	; 2
     134:	0e 94 c3 07 	call	0xf86	; 0xf86 <xQueueCreateCountingSemaphore>
     138:	90 93 fa 06 	sts	0x06FA, r25	; 0x8006fa <Switch0_Couting_Semaphore+0x1>
     13c:	80 93 f9 06 	sts	0x06F9, r24	; 0x8006f9 <Switch0_Couting_Semaphore>

	
	while(1)
	{
		
		xLastWakeTime=xTaskGetTickCount();
     140:	0e 94 22 0b 	call	0x1644	; 0x1644 <xTaskGetTickCount>
     144:	9a 83       	std	Y+2, r25	; 0x02
     146:	89 83       	std	Y+1, r24	; 0x01
		Debug_By_Toggle(22);
     148:	86 e1       	ldi	r24, 0x16	; 22
     14a:	90 e0       	ldi	r25, 0x00	; 0
     14c:	0e 94 ca 04 	call	0x994	; 0x994 <Debug_By_Toggle>
		/*Read switch 0 */
		Read_Switch(switch0,&u8_value_of_switch);
     150:	be 01       	movw	r22, r28
     152:	6d 5f       	subi	r22, 0xFD	; 253
     154:	7f 4f       	sbci	r23, 0xFF	; 255
     156:	88 e0       	ldi	r24, 0x08	; 8
     158:	0e 94 90 03 	call	0x720	; 0x720 <DIO_Read_Pin>
		/*if it is high increment the global variable */
		if(u8_value_of_switch==HIGH)
     15c:	8b 81       	ldd	r24, Y+3	; 0x03
     15e:	81 30       	cpi	r24, 0x01	; 1
     160:	99 f4       	brne	.+38     	; 0x188 <Check_Switch0+0x64>
		{
			if(uxSemaphoreGetCount(Switch0_Couting_Semaphore)<2)
     162:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <Switch0_Couting_Semaphore>
     166:	90 91 fa 06 	lds	r25, 0x06FA	; 0x8006fa <Switch0_Couting_Semaphore+0x1>
     16a:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <uxQueueMessagesWaiting>
     16e:	82 30       	cpi	r24, 0x02	; 2
     170:	58 f4       	brcc	.+22     	; 0x188 <Check_Switch0+0x64>
			{

				/*Increment counting semaphore*/
				xSemaphoreGive(Switch0_Couting_Semaphore);
     172:	20 e0       	ldi	r18, 0x00	; 0
     174:	40 e0       	ldi	r20, 0x00	; 0
     176:	50 e0       	ldi	r21, 0x00	; 0
     178:	60 e0       	ldi	r22, 0x00	; 0
     17a:	70 e0       	ldi	r23, 0x00	; 0
     17c:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <Switch0_Couting_Semaphore>
     180:	90 91 fa 06 	lds	r25, 0x06FA	; 0x8006fa <Switch0_Couting_Semaphore+0x1>
     184:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericSend>
		}
		else
		{
			/*Do nothing*/
		}
		Debug_By_Toggle(22);		
     188:	86 e1       	ldi	r24, 0x16	; 22
     18a:	90 e0       	ldi	r25, 0x00	; 0
     18c:	0e 94 ca 04 	call	0x994	; 0x994 <Debug_By_Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );			
     190:	62 e3       	ldi	r22, 0x32	; 50
     192:	70 e0       	ldi	r23, 0x00	; 0
     194:	ce 01       	movw	r24, r28
     196:	01 96       	adiw	r24, 0x01	; 1
     198:	0e 94 43 0c 	call	0x1886	; 0x1886 <vTaskDelayUntil>
	}
     19c:	d1 cf       	rjmp	.-94     	; 0x140 <Check_Switch0+0x1c>

0000019e <Check_Switch1>:
}

void Check_Switch1(void*Pv_Parameter)             /** Periodicity 50 milisecond   -- Priority is 3**//**Execution time range micro    **/
{
     19e:	cf 93       	push	r28
     1a0:	df 93       	push	r29
     1a2:	00 d0       	rcall	.+0      	; 0x1a4 <Check_Switch1+0x6>
     1a4:	1f 92       	push	r1
     1a6:	cd b7       	in	r28, 0x3d	; 61
     1a8:	de b7       	in	r29, 0x3e	; 62

	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 50;
	Switch1_Couting_Semaphore=xSemaphoreCreateCounting(2,0);
     1aa:	60 e0       	ldi	r22, 0x00	; 0
     1ac:	82 e0       	ldi	r24, 0x02	; 2
     1ae:	0e 94 c3 07 	call	0xf86	; 0xf86 <xQueueCreateCountingSemaphore>
     1b2:	90 93 f6 06 	sts	0x06F6, r25	; 0x8006f6 <Switch1_Couting_Semaphore+0x1>
     1b6:	80 93 f5 06 	sts	0x06F5, r24	; 0x8006f5 <Switch1_Couting_Semaphore>

	
	while(1)
	{

		xLastWakeTime=xTaskGetTickCount();
     1ba:	0e 94 22 0b 	call	0x1644	; 0x1644 <xTaskGetTickCount>
     1be:	9a 83       	std	Y+2, r25	; 0x02
     1c0:	89 83       	std	Y+1, r24	; 0x01
	    Debug_By_Toggle(23);
     1c2:	87 e1       	ldi	r24, 0x17	; 23
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	0e 94 ca 04 	call	0x994	; 0x994 <Debug_By_Toggle>
		/*Read switch 0 */
		Read_Switch(switch1,&u8_value_of_switch);
     1ca:	be 01       	movw	r22, r28
     1cc:	6d 5f       	subi	r22, 0xFD	; 253
     1ce:	7f 4f       	sbci	r23, 0xFF	; 255
     1d0:	89 e0       	ldi	r24, 0x09	; 9
     1d2:	0e 94 90 03 	call	0x720	; 0x720 <DIO_Read_Pin>
		/*if it is high increment the global variable */
		if(u8_value_of_switch==HIGH)
     1d6:	8b 81       	ldd	r24, Y+3	; 0x03
     1d8:	81 30       	cpi	r24, 0x01	; 1
     1da:	99 f4       	brne	.+38     	; 0x202 <Check_Switch1+0x64>
		{
			if(uxSemaphoreGetCount(Switch1_Couting_Semaphore)<2)
     1dc:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <Switch1_Couting_Semaphore>
     1e0:	90 91 f6 06 	lds	r25, 0x06F6	; 0x8006f6 <Switch1_Couting_Semaphore+0x1>
     1e4:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <uxQueueMessagesWaiting>
     1e8:	82 30       	cpi	r24, 0x02	; 2
     1ea:	58 f4       	brcc	.+22     	; 0x202 <Check_Switch1+0x64>
			{

				/*Increment counting semaphore*/
				xSemaphoreGive(Switch1_Couting_Semaphore);
     1ec:	20 e0       	ldi	r18, 0x00	; 0
     1ee:	40 e0       	ldi	r20, 0x00	; 0
     1f0:	50 e0       	ldi	r21, 0x00	; 0
     1f2:	60 e0       	ldi	r22, 0x00	; 0
     1f4:	70 e0       	ldi	r23, 0x00	; 0
     1f6:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <Switch1_Couting_Semaphore>
     1fa:	90 91 f6 06 	lds	r25, 0x06F6	; 0x8006f6 <Switch1_Couting_Semaphore+0x1>
     1fe:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericSend>
		}
		else
		{
			/*Do nothing*/
		}
	    Debug_By_Toggle(23);		
     202:	87 e1       	ldi	r24, 0x17	; 23
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	0e 94 ca 04 	call	0x994	; 0x994 <Debug_By_Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );		
     20a:	62 e3       	ldi	r22, 0x32	; 50
     20c:	70 e0       	ldi	r23, 0x00	; 0
     20e:	ce 01       	movw	r24, r28
     210:	01 96       	adiw	r24, 0x01	; 1
     212:	0e 94 43 0c 	call	0x1886	; 0x1886 <vTaskDelayUntil>
	}
     216:	d1 cf       	rjmp	.-94     	; 0x1ba <Check_Switch1+0x1c>

00000218 <Monitoring_Task>:
}

void Monitoring_Task(void *Pv_Paramaeter)         /** Periodicity 200 milisecond  -- Priority is 2**//**Execution time 104 milisecond **/
{
     218:	cf 93       	push	r28
     21a:	df 93       	push	r29
     21c:	00 d0       	rcall	.+0      	; 0x21e <Monitoring_Task+0x6>
     21e:	cd b7       	in	r28, 0x3d	; 61
     220:	de b7       	in	r29, 0x3e	; 62
	static uinteg8_t su8_Switch1_state_Flag=0;
	static uinteg8_t su8_Write_New_String_Flag=1;
	uinteg8_t  u8_Switch0_Sempahore_Count_Buffer=0;
	uinteg8_t  u8_Switch1_Sempahore_Count_Buffer=0;
	
	vSemaphoreCreateBinary(Switch0_is_set_Semaphore);
     222:	43 e0       	ldi	r20, 0x03	; 3
     224:	60 e0       	ldi	r22, 0x00	; 0
     226:	81 e0       	ldi	r24, 0x01	; 1
     228:	0e 94 96 07 	call	0xf2c	; 0xf2c <xQueueGenericCreate>
     22c:	90 93 f0 06 	sts	0x06F0, r25	; 0x8006f0 <Switch0_is_set_Semaphore+0x1>
     230:	80 93 ef 06 	sts	0x06EF, r24	; 0x8006ef <Switch0_is_set_Semaphore>
     234:	00 97       	sbiw	r24, 0x00	; 0
     236:	39 f0       	breq	.+14     	; 0x246 <Monitoring_Task+0x2e>
     238:	20 e0       	ldi	r18, 0x00	; 0
     23a:	40 e0       	ldi	r20, 0x00	; 0
     23c:	50 e0       	ldi	r21, 0x00	; 0
     23e:	60 e0       	ldi	r22, 0x00	; 0
     240:	70 e0       	ldi	r23, 0x00	; 0
     242:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericSend>
	vSemaphoreCreateBinary(Switch1_is_set_Semaphore);
     246:	43 e0       	ldi	r20, 0x03	; 3
     248:	60 e0       	ldi	r22, 0x00	; 0
     24a:	81 e0       	ldi	r24, 0x01	; 1
     24c:	0e 94 96 07 	call	0xf2c	; 0xf2c <xQueueGenericCreate>
     250:	90 93 f8 06 	sts	0x06F8, r25	; 0x8006f8 <Switch1_is_set_Semaphore+0x1>
     254:	80 93 f7 06 	sts	0x06F7, r24	; 0x8006f7 <Switch1_is_set_Semaphore>
     258:	00 97       	sbiw	r24, 0x00	; 0
     25a:	39 f0       	breq	.+14     	; 0x26a <Monitoring_Task+0x52>
     25c:	20 e0       	ldi	r18, 0x00	; 0
     25e:	40 e0       	ldi	r20, 0x00	; 0
     260:	50 e0       	ldi	r21, 0x00	; 0
     262:	60 e0       	ldi	r22, 0x00	; 0
     264:	70 e0       	ldi	r23, 0x00	; 0
     266:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericSend>
	
	while(1)
	{
		xLastWakeTime=xTaskGetTickCount();
     26a:	0e 94 22 0b 	call	0x1644	; 0x1644 <xTaskGetTickCount>
     26e:	9a 83       	std	Y+2, r25	; 0x02
     270:	89 83       	std	Y+1, r24	; 0x01
		Debug_By_Toggle(30);
     272:	8e e1       	ldi	r24, 0x1E	; 30
     274:	90 e0       	ldi	r25, 0x00	; 0
     276:	0e 94 ca 04 	call	0x994	; 0x994 <Debug_By_Toggle>
		u8_Switch0_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch0_Couting_Semaphore);
     27a:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <Switch0_Couting_Semaphore>
     27e:	90 91 fa 06 	lds	r25, 0x06FA	; 0x8006fa <Switch0_Couting_Semaphore+0x1>
     282:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <uxQueueMessagesWaiting>
     286:	08 2f       	mov	r16, r24
		u8_Switch1_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch1_Couting_Semaphore);
     288:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <Switch1_Couting_Semaphore>
     28c:	90 91 f6 06 	lds	r25, 0x06F6	; 0x8006f6 <Switch1_Couting_Semaphore+0x1>
     290:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <uxQueueMessagesWaiting>
     294:	18 2f       	mov	r17, r24
		
		
		while(uxSemaphoreGetCount(Switch0_Couting_Semaphore)!=0)
     296:	08 c0       	rjmp	.+16     	; 0x2a8 <Monitoring_Task+0x90>
		{
			xSemaphoreTake(Switch0_Couting_Semaphore,0);
     298:	60 e0       	ldi	r22, 0x00	; 0
     29a:	70 e0       	ldi	r23, 0x00	; 0
     29c:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <Switch0_Couting_Semaphore>
     2a0:	90 91 fa 06 	lds	r25, 0x06FA	; 0x8006fa <Switch0_Couting_Semaphore+0x1>
     2a4:	0e 94 68 08 	call	0x10d0	; 0x10d0 <xQueueSemaphoreTake>
		Debug_By_Toggle(30);
		u8_Switch0_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch0_Couting_Semaphore);
		u8_Switch1_Sempahore_Count_Buffer=uxSemaphoreGetCount(Switch1_Couting_Semaphore);
		
		
		while(uxSemaphoreGetCount(Switch0_Couting_Semaphore)!=0)
     2a8:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <Switch0_Couting_Semaphore>
     2ac:	90 91 fa 06 	lds	r25, 0x06FA	; 0x8006fa <Switch0_Couting_Semaphore+0x1>
     2b0:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <uxQueueMessagesWaiting>
     2b4:	81 11       	cpse	r24, r1
     2b6:	f0 cf       	rjmp	.-32     	; 0x298 <Monitoring_Task+0x80>
     2b8:	08 c0       	rjmp	.+16     	; 0x2ca <Monitoring_Task+0xb2>
		{
			xSemaphoreTake(Switch0_Couting_Semaphore,0);
		}
		while(uxSemaphoreGetCount(Switch1_Couting_Semaphore)!=0)
		{
			xSemaphoreTake(Switch1_Couting_Semaphore,0);
     2ba:	60 e0       	ldi	r22, 0x00	; 0
     2bc:	70 e0       	ldi	r23, 0x00	; 0
     2be:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <Switch1_Couting_Semaphore>
     2c2:	90 91 f6 06 	lds	r25, 0x06F6	; 0x8006f6 <Switch1_Couting_Semaphore+0x1>
     2c6:	0e 94 68 08 	call	0x10d0	; 0x10d0 <xQueueSemaphoreTake>
		
		while(uxSemaphoreGetCount(Switch0_Couting_Semaphore)!=0)
		{
			xSemaphoreTake(Switch0_Couting_Semaphore,0);
		}
		while(uxSemaphoreGetCount(Switch1_Couting_Semaphore)!=0)
     2ca:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <Switch1_Couting_Semaphore>
     2ce:	90 91 f6 06 	lds	r25, 0x06F6	; 0x8006f6 <Switch1_Couting_Semaphore+0x1>
     2d2:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <uxQueueMessagesWaiting>
     2d6:	81 11       	cpse	r24, r1
     2d8:	f0 cf       	rjmp	.-32     	; 0x2ba <Monitoring_Task+0xa2>
		{
			xSemaphoreTake(Switch1_Couting_Semaphore,0);
		}
		
		if((u8_Switch0_Sempahore_Count_Buffer>=2)&&(u8_Switch1_Sempahore_Count_Buffer<2))
     2da:	02 30       	cpi	r16, 0x02	; 2
     2dc:	98 f0       	brcs	.+38     	; 0x304 <Monitoring_Task+0xec>
     2de:	12 30       	cpi	r17, 0x02	; 2
     2e0:	20 f5       	brcc	.+72     	; 0x32a <Monitoring_Task+0x112>
		{
			xSemaphoreTake(Switch0_is_set_Semaphore,0);
     2e2:	60 e0       	ldi	r22, 0x00	; 0
     2e4:	70 e0       	ldi	r23, 0x00	; 0
     2e6:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <Switch0_is_set_Semaphore>
     2ea:	90 91 f0 06 	lds	r25, 0x06F0	; 0x8006f0 <Switch0_is_set_Semaphore+0x1>
     2ee:	0e 94 68 08 	call	0x10d0	; 0x10d0 <xQueueSemaphoreTake>
			LCD_displayStringRowColumn(1,1,Switch0_ON_Array);
     2f2:	40 e7       	ldi	r20, 0x70	; 112
     2f4:	50 e0       	ldi	r21, 0x00	; 0
     2f6:	61 e0       	ldi	r22, 0x01	; 1
     2f8:	70 e0       	ldi	r23, 0x00	; 0
     2fa:	81 e0       	ldi	r24, 0x01	; 1
     2fc:	90 e0       	ldi	r25, 0x00	; 0
     2fe:	0e 94 ef 02 	call	0x5de	; 0x5de <LCD_displayStringRowColumn>
		{
			xSemaphoreTake(Switch1_Couting_Semaphore,0);
		}
		
		if((u8_Switch0_Sempahore_Count_Buffer>=2)&&(u8_Switch1_Sempahore_Count_Buffer<2))
		{
     302:	1b c0       	rjmp	.+54     	; 0x33a <Monitoring_Task+0x122>
			xSemaphoreTake(Switch0_is_set_Semaphore,0);
			LCD_displayStringRowColumn(1,1,Switch0_ON_Array);
		}
		else if((u8_Switch0_Sempahore_Count_Buffer<2)&&(u8_Switch1_Sempahore_Count_Buffer>=2))
     304:	12 30       	cpi	r17, 0x02	; 2
     306:	88 f0       	brcs	.+34     	; 0x32a <Monitoring_Task+0x112>
		{
			xSemaphoreTake(Switch1_is_set_Semaphore,0);
     308:	60 e0       	ldi	r22, 0x00	; 0
     30a:	70 e0       	ldi	r23, 0x00	; 0
     30c:	80 91 f7 06 	lds	r24, 0x06F7	; 0x8006f7 <Switch1_is_set_Semaphore>
     310:	90 91 f8 06 	lds	r25, 0x06F8	; 0x8006f8 <Switch1_is_set_Semaphore+0x1>
     314:	0e 94 68 08 	call	0x10d0	; 0x10d0 <xQueueSemaphoreTake>
			LCD_displayStringRowColumn(1,1,Switch1_ON_Array);
     318:	40 e8       	ldi	r20, 0x80	; 128
     31a:	50 e0       	ldi	r21, 0x00	; 0
     31c:	61 e0       	ldi	r22, 0x01	; 1
     31e:	70 e0       	ldi	r23, 0x00	; 0
     320:	81 e0       	ldi	r24, 0x01	; 1
     322:	90 e0       	ldi	r25, 0x00	; 0
     324:	0e 94 ef 02 	call	0x5de	; 0x5de <LCD_displayStringRowColumn>
		{
			xSemaphoreTake(Switch0_is_set_Semaphore,0);
			LCD_displayStringRowColumn(1,1,Switch0_ON_Array);
		}
		else if((u8_Switch0_Sempahore_Count_Buffer<2)&&(u8_Switch1_Sempahore_Count_Buffer>=2))
		{
     328:	08 c0       	rjmp	.+16     	; 0x33a <Monitoring_Task+0x122>
			xSemaphoreTake(Switch1_is_set_Semaphore,0);
			LCD_displayStringRowColumn(1,1,Switch1_ON_Array);
		}		
		else
		{
			LCD_displayStringRowColumn(1,1,Switches_OFF_Array);
     32a:	40 e6       	ldi	r20, 0x60	; 96
     32c:	50 e0       	ldi	r21, 0x00	; 0
     32e:	61 e0       	ldi	r22, 0x01	; 1
     330:	70 e0       	ldi	r23, 0x00	; 0
     332:	81 e0       	ldi	r24, 0x01	; 1
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	0e 94 ef 02 	call	0x5de	; 0x5de <LCD_displayStringRowColumn>
		}
		Debug_By_Toggle(30);
     33a:	8e e1       	ldi	r24, 0x1E	; 30
     33c:	90 e0       	ldi	r25, 0x00	; 0
     33e:	0e 94 ca 04 	call	0x994	; 0x994 <Debug_By_Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
     342:	68 ec       	ldi	r22, 0xC8	; 200
     344:	70 e0       	ldi	r23, 0x00	; 0
     346:	ce 01       	movw	r24, r28
     348:	01 96       	adiw	r24, 0x01	; 1
     34a:	0e 94 43 0c 	call	0x1886	; 0x1886 <vTaskDelayUntil>
	}
     34e:	8d cf       	rjmp	.-230    	; 0x26a <Monitoring_Task+0x52>

00000350 <Led_On_Off_Task>:
}
 
void Led_On_Off_Task(void *Pv_Parameter)          /** Periodicity 200 milisecond  -- Priority is 1**//**Execution time range micro    **/
{
     350:	cf 93       	push	r28
     352:	df 93       	push	r29
     354:	00 d0       	rcall	.+0      	; 0x356 <Led_On_Off_Task+0x6>
     356:	cd b7       	in	r28, 0x3d	; 61
     358:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime;
	const TickType_t xFrequency = 200;		
	vSemaphoreCreateBinary(Led_On_Off_Semaphore);
     35a:	43 e0       	ldi	r20, 0x03	; 3
     35c:	60 e0       	ldi	r22, 0x00	; 0
     35e:	81 e0       	ldi	r24, 0x01	; 1
     360:	0e 94 96 07 	call	0xf2c	; 0xf2c <xQueueGenericCreate>
     364:	90 93 f4 06 	sts	0x06F4, r25	; 0x8006f4 <Led_On_Off_Semaphore+0x1>
     368:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <Led_On_Off_Semaphore>
     36c:	00 97       	sbiw	r24, 0x00	; 0
     36e:	39 f0       	breq	.+14     	; 0x37e <Led_On_Off_Task+0x2e>
     370:	20 e0       	ldi	r18, 0x00	; 0
     372:	40 e0       	ldi	r20, 0x00	; 0
     374:	50 e0       	ldi	r21, 0x00	; 0
     376:	60 e0       	ldi	r22, 0x00	; 0
     378:	70 e0       	ldi	r23, 0x00	; 0
     37a:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericSend>
    uinteg8_t u8_LCD_ROW_0_index=0,u8_LCD_ROW_1_index=0;
	while(1)
	{
		xLastWakeTime=xTaskGetTickCount();
     37e:	0e 94 22 0b 	call	0x1644	; 0x1644 <xTaskGetTickCount>
     382:	9a 83       	std	Y+2, r25	; 0x02
     384:	89 83       	std	Y+1, r24	; 0x01
		Debug_By_Toggle(24);
     386:	88 e1       	ldi	r24, 0x18	; 24
     388:	90 e0       	ldi	r25, 0x00	; 0
     38a:	0e 94 ca 04 	call	0x994	; 0x994 <Debug_By_Toggle>
		if(uxSemaphoreGetCount(Switch0_is_set_Semaphore)==0)
     38e:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <Switch0_is_set_Semaphore>
     392:	90 91 f0 06 	lds	r25, 0x06F0	; 0x8006f0 <Switch0_is_set_Semaphore+0x1>
     396:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <uxQueueMessagesWaiting>
     39a:	81 11       	cpse	r24, r1
     39c:	10 c0       	rjmp	.+32     	; 0x3be <Led_On_Off_Task+0x6e>
		{
			Led_Turn_On(LED0);
     39e:	61 e0       	ldi	r22, 0x01	; 1
     3a0:	8a e0       	ldi	r24, 0x0A	; 10
     3a2:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <DIO_Write_Pin>
			xSemaphoreGive(Switch0_is_set_Semaphore);
     3a6:	20 e0       	ldi	r18, 0x00	; 0
     3a8:	40 e0       	ldi	r20, 0x00	; 0
     3aa:	50 e0       	ldi	r21, 0x00	; 0
     3ac:	60 e0       	ldi	r22, 0x00	; 0
     3ae:	70 e0       	ldi	r23, 0x00	; 0
     3b0:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <Switch0_is_set_Semaphore>
     3b4:	90 91 f0 06 	lds	r25, 0x06F0	; 0x8006f0 <Switch0_is_set_Semaphore+0x1>
     3b8:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericSend>
     3bc:	1c c0       	rjmp	.+56     	; 0x3f6 <Led_On_Off_Task+0xa6>
		}
		else if(uxSemaphoreGetCount(Switch1_is_set_Semaphore)==0)
     3be:	80 91 f7 06 	lds	r24, 0x06F7	; 0x8006f7 <Switch1_is_set_Semaphore>
     3c2:	90 91 f8 06 	lds	r25, 0x06F8	; 0x8006f8 <Switch1_is_set_Semaphore+0x1>
     3c6:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <uxQueueMessagesWaiting>
     3ca:	81 11       	cpse	r24, r1
     3cc:	10 c0       	rjmp	.+32     	; 0x3ee <Led_On_Off_Task+0x9e>
		{
			Led_Turn_On(LED0);
     3ce:	61 e0       	ldi	r22, 0x01	; 1
     3d0:	8a e0       	ldi	r24, 0x0A	; 10
     3d2:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <DIO_Write_Pin>
			xSemaphoreGive(Switch1_is_set_Semaphore);
     3d6:	20 e0       	ldi	r18, 0x00	; 0
     3d8:	40 e0       	ldi	r20, 0x00	; 0
     3da:	50 e0       	ldi	r21, 0x00	; 0
     3dc:	60 e0       	ldi	r22, 0x00	; 0
     3de:	70 e0       	ldi	r23, 0x00	; 0
     3e0:	80 91 f7 06 	lds	r24, 0x06F7	; 0x8006f7 <Switch1_is_set_Semaphore>
     3e4:	90 91 f8 06 	lds	r25, 0x06F8	; 0x8006f8 <Switch1_is_set_Semaphore+0x1>
     3e8:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericSend>
     3ec:	04 c0       	rjmp	.+8      	; 0x3f6 <Led_On_Off_Task+0xa6>
		}
		else
		{
			Led_Turn_Off(LED0);			
     3ee:	60 e0       	ldi	r22, 0x00	; 0
     3f0:	8a e0       	ldi	r24, 0x0A	; 10
     3f2:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <DIO_Write_Pin>
		}   
		Debug_By_Toggle(24);		
     3f6:	88 e1       	ldi	r24, 0x18	; 24
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	0e 94 ca 04 	call	0x994	; 0x994 <Debug_By_Toggle>
		vTaskDelayUntil( &xLastWakeTime, xFrequency );				
     3fe:	68 ec       	ldi	r22, 0xC8	; 200
     400:	70 e0       	ldi	r23, 0x00	; 0
     402:	ce 01       	movw	r24, r28
     404:	01 96       	adiw	r24, 0x01	; 1
     406:	0e 94 43 0c 	call	0x1886	; 0x1886 <vTaskDelayUntil>
	}
     40a:	b9 cf       	rjmp	.-142    	; 0x37e <Led_On_Off_Task+0x2e>

0000040c <main>:
}


int main(void)
{
     40c:	ef 92       	push	r14
     40e:	ff 92       	push	r15
     410:	0f 93       	push	r16
	/**Create the task of System_Init where it uses 100 word from stack and has priority 4*/
	xTaskCreate(System_Init,NULL,100,NULL,4,&SYS_Handler);
     412:	0f 2e       	mov	r0, r31
     414:	fc e9       	ldi	r31, 0x9C	; 156
     416:	ef 2e       	mov	r14, r31
     418:	f0 e0       	ldi	r31, 0x00	; 0
     41a:	ff 2e       	mov	r15, r31
     41c:	f0 2d       	mov	r31, r0
     41e:	04 e0       	ldi	r16, 0x04	; 4
     420:	20 e0       	ldi	r18, 0x00	; 0
     422:	30 e0       	ldi	r19, 0x00	; 0
     424:	44 e6       	ldi	r20, 0x64	; 100
     426:	50 e0       	ldi	r21, 0x00	; 0
     428:	60 e0       	ldi	r22, 0x00	; 0
     42a:	70 e0       	ldi	r23, 0x00	; 0
     42c:	89 e4       	ldi	r24, 0x49	; 73
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	0e 94 9f 09 	call	0x133e	; 0x133e <xTaskCreate>
	/**Create the task of Check_Switch0 where it uses 100 word from stack and has priority 3*/
	xTaskCreate(Check_Switch0,NULL,100,NULL,3,&Switch0_Handler);
     434:	0f 2e       	mov	r0, r31
     436:	fa e9       	ldi	r31, 0x9A	; 154
     438:	ef 2e       	mov	r14, r31
     43a:	f0 e0       	ldi	r31, 0x00	; 0
     43c:	ff 2e       	mov	r15, r31
     43e:	f0 2d       	mov	r31, r0
     440:	03 e0       	ldi	r16, 0x03	; 3
     442:	20 e0       	ldi	r18, 0x00	; 0
     444:	30 e0       	ldi	r19, 0x00	; 0
     446:	44 e6       	ldi	r20, 0x64	; 100
     448:	50 e0       	ldi	r21, 0x00	; 0
     44a:	60 e0       	ldi	r22, 0x00	; 0
     44c:	70 e0       	ldi	r23, 0x00	; 0
     44e:	82 e9       	ldi	r24, 0x92	; 146
     450:	90 e0       	ldi	r25, 0x00	; 0
     452:	0e 94 9f 09 	call	0x133e	; 0x133e <xTaskCreate>
	/**Create the task of Check_Switch0 where it uses 100 word from stack and has priority 3*/
	xTaskCreate(Check_Switch1,NULL,100,NULL,3,&Switch1_Handler);	
     456:	0f 2e       	mov	r0, r31
     458:	f8 e9       	ldi	r31, 0x98	; 152
     45a:	ef 2e       	mov	r14, r31
     45c:	f0 e0       	ldi	r31, 0x00	; 0
     45e:	ff 2e       	mov	r15, r31
     460:	f0 2d       	mov	r31, r0
     462:	20 e0       	ldi	r18, 0x00	; 0
     464:	30 e0       	ldi	r19, 0x00	; 0
     466:	44 e6       	ldi	r20, 0x64	; 100
     468:	50 e0       	ldi	r21, 0x00	; 0
     46a:	60 e0       	ldi	r22, 0x00	; 0
     46c:	70 e0       	ldi	r23, 0x00	; 0
     46e:	8f ec       	ldi	r24, 0xCF	; 207
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	0e 94 9f 09 	call	0x133e	; 0x133e <xTaskCreate>
	/*Create the task of Monitoring_Task where it uses 100 word from stack and has priority 1*/
	xTaskCreate(Monitoring_Task,NULL,100,NULL,2,&Monitoring_Handler);	
     476:	0f 2e       	mov	r0, r31
     478:	f6 e9       	ldi	r31, 0x96	; 150
     47a:	ef 2e       	mov	r14, r31
     47c:	f0 e0       	ldi	r31, 0x00	; 0
     47e:	ff 2e       	mov	r15, r31
     480:	f0 2d       	mov	r31, r0
     482:	02 e0       	ldi	r16, 0x02	; 2
     484:	20 e0       	ldi	r18, 0x00	; 0
     486:	30 e0       	ldi	r19, 0x00	; 0
     488:	44 e6       	ldi	r20, 0x64	; 100
     48a:	50 e0       	ldi	r21, 0x00	; 0
     48c:	60 e0       	ldi	r22, 0x00	; 0
     48e:	70 e0       	ldi	r23, 0x00	; 0
     490:	8c e0       	ldi	r24, 0x0C	; 12
     492:	91 e0       	ldi	r25, 0x01	; 1
     494:	0e 94 9f 09 	call	0x133e	; 0x133e <xTaskCreate>
	/**Create the task of Led_On_Off_Task where it uses 100 word from stack and has priority 2*/
	xTaskCreate(Led_On_Off_Task,NULL,100,NULL,1,&Led_On_Off_Handler);   	
     498:	0f 2e       	mov	r0, r31
     49a:	fe e9       	ldi	r31, 0x9E	; 158
     49c:	ef 2e       	mov	r14, r31
     49e:	f0 e0       	ldi	r31, 0x00	; 0
     4a0:	ff 2e       	mov	r15, r31
     4a2:	f0 2d       	mov	r31, r0
     4a4:	01 e0       	ldi	r16, 0x01	; 1
     4a6:	20 e0       	ldi	r18, 0x00	; 0
     4a8:	30 e0       	ldi	r19, 0x00	; 0
     4aa:	44 e6       	ldi	r20, 0x64	; 100
     4ac:	50 e0       	ldi	r21, 0x00	; 0
     4ae:	60 e0       	ldi	r22, 0x00	; 0
     4b0:	70 e0       	ldi	r23, 0x00	; 0
     4b2:	88 ea       	ldi	r24, 0xA8	; 168
     4b4:	91 e0       	ldi	r25, 0x01	; 1
     4b6:	0e 94 9f 09 	call	0x133e	; 0x133e <xTaskCreate>

	/*Os start  */
	vTaskStartScheduler();
     4ba:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <vTaskStartScheduler>
}
     4be:	80 e0       	ldi	r24, 0x00	; 0
     4c0:	90 e0       	ldi	r25, 0x00	; 0
     4c2:	0f 91       	pop	r16
     4c4:	ff 90       	pop	r15
     4c6:	ef 90       	pop	r14
     4c8:	08 95       	ret

000004ca <LCD_sendCommand>:
  }
}

void LCD_clearScreen(void)
{
	LCD_sendCommand(CLEAR_COMMAND); //clear display
     4ca:	cf 93       	push	r28
     4cc:	c8 2f       	mov	r28, r24
     4ce:	d9 98       	cbi	0x1b, 1	; 27
     4d0:	da 98       	cbi	0x1b, 2	; 27
     4d2:	db 9a       	sbi	0x1b, 3	; 27
     4d4:	82 e0       	ldi	r24, 0x02	; 2
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	0e 94 81 0c 	call	0x1902	; 0x1902 <vTaskDelay>
     4dc:	8b b3       	in	r24, 0x1b	; 27
     4de:	8f 70       	andi	r24, 0x0F	; 15
     4e0:	9c 2f       	mov	r25, r28
     4e2:	90 7f       	andi	r25, 0xF0	; 240
     4e4:	89 2b       	or	r24, r25
     4e6:	8b bb       	out	0x1b, r24	; 27
     4e8:	db 98       	cbi	0x1b, 3	; 27
     4ea:	82 e0       	ldi	r24, 0x02	; 2
     4ec:	90 e0       	ldi	r25, 0x00	; 0
     4ee:	0e 94 81 0c 	call	0x1902	; 0x1902 <vTaskDelay>
     4f2:	db 9a       	sbi	0x1b, 3	; 27
     4f4:	82 e0       	ldi	r24, 0x02	; 2
     4f6:	90 e0       	ldi	r25, 0x00	; 0
     4f8:	0e 94 81 0c 	call	0x1902	; 0x1902 <vTaskDelay>
     4fc:	8b b3       	in	r24, 0x1b	; 27
     4fe:	28 2f       	mov	r18, r24
     500:	2f 70       	andi	r18, 0x0F	; 15
     502:	30 e1       	ldi	r19, 0x10	; 16
     504:	c3 9f       	mul	r28, r19
     506:	c0 01       	movw	r24, r0
     508:	11 24       	eor	r1, r1
     50a:	82 2b       	or	r24, r18
     50c:	8b bb       	out	0x1b, r24	; 27
     50e:	db 98       	cbi	0x1b, 3	; 27
     510:	82 e0       	ldi	r24, 0x02	; 2
     512:	90 e0       	ldi	r25, 0x00	; 0
     514:	0e 94 81 0c 	call	0x1902	; 0x1902 <vTaskDelay>
     518:	cf 91       	pop	r28
     51a:	08 95       	ret

0000051c <LCD_init>:
     51c:	8a b3       	in	r24, 0x1a	; 26
     51e:	8e 60       	ori	r24, 0x0E	; 14
     520:	8a bb       	out	0x1a, r24	; 26
     522:	8a b3       	in	r24, 0x1a	; 26
     524:	80 6f       	ori	r24, 0xF0	; 240
     526:	8a bb       	out	0x1a, r24	; 26
     528:	82 e0       	ldi	r24, 0x02	; 2
     52a:	0e 94 65 02 	call	0x4ca	; 0x4ca <LCD_sendCommand>
     52e:	88 e2       	ldi	r24, 0x28	; 40
     530:	0e 94 65 02 	call	0x4ca	; 0x4ca <LCD_sendCommand>
     534:	8c e0       	ldi	r24, 0x0C	; 12
     536:	0e 94 65 02 	call	0x4ca	; 0x4ca <LCD_sendCommand>
     53a:	81 e0       	ldi	r24, 0x01	; 1
     53c:	0e 94 65 02 	call	0x4ca	; 0x4ca <LCD_sendCommand>
     540:	08 95       	ret

00000542 <LCD_displayCharacter>:
     542:	cf 93       	push	r28
     544:	c8 2f       	mov	r28, r24
     546:	d9 9a       	sbi	0x1b, 1	; 27
     548:	da 98       	cbi	0x1b, 2	; 27
     54a:	db 9a       	sbi	0x1b, 3	; 27
     54c:	81 e0       	ldi	r24, 0x01	; 1
     54e:	90 e0       	ldi	r25, 0x00	; 0
     550:	0e 94 81 0c 	call	0x1902	; 0x1902 <vTaskDelay>
     554:	8b b3       	in	r24, 0x1b	; 27
     556:	8f 70       	andi	r24, 0x0F	; 15
     558:	9c 2f       	mov	r25, r28
     55a:	90 7f       	andi	r25, 0xF0	; 240
     55c:	89 2b       	or	r24, r25
     55e:	8b bb       	out	0x1b, r24	; 27
     560:	db 98       	cbi	0x1b, 3	; 27
     562:	81 e0       	ldi	r24, 0x01	; 1
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	0e 94 81 0c 	call	0x1902	; 0x1902 <vTaskDelay>
     56a:	db 9a       	sbi	0x1b, 3	; 27
     56c:	81 e0       	ldi	r24, 0x01	; 1
     56e:	90 e0       	ldi	r25, 0x00	; 0
     570:	0e 94 81 0c 	call	0x1902	; 0x1902 <vTaskDelay>
     574:	8b b3       	in	r24, 0x1b	; 27
     576:	28 2f       	mov	r18, r24
     578:	2f 70       	andi	r18, 0x0F	; 15
     57a:	30 e1       	ldi	r19, 0x10	; 16
     57c:	c3 9f       	mul	r28, r19
     57e:	c0 01       	movw	r24, r0
     580:	11 24       	eor	r1, r1
     582:	82 2b       	or	r24, r18
     584:	8b bb       	out	0x1b, r24	; 27
     586:	db 98       	cbi	0x1b, 3	; 27
     588:	81 e0       	ldi	r24, 0x01	; 1
     58a:	90 e0       	ldi	r25, 0x00	; 0
     58c:	0e 94 81 0c 	call	0x1902	; 0x1902 <vTaskDelay>
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	cf 91       	pop	r28
     594:	08 95       	ret

00000596 <LCD_displayString>:
     596:	0f 93       	push	r16
     598:	1f 93       	push	r17
     59a:	cf 93       	push	r28
     59c:	fc 01       	movw	r30, r24
     59e:	80 81       	ld	r24, Z
     5a0:	88 23       	and	r24, r24
     5a2:	59 f0       	breq	.+22     	; 0x5ba <LCD_displayString+0x24>
     5a4:	8f 01       	movw	r16, r30
     5a6:	c0 e0       	ldi	r28, 0x00	; 0
     5a8:	0e 94 a1 02 	call	0x542	; 0x542 <LCD_displayCharacter>
     5ac:	cf 5f       	subi	r28, 0xFF	; 255
     5ae:	f8 01       	movw	r30, r16
     5b0:	ec 0f       	add	r30, r28
     5b2:	f1 1d       	adc	r31, r1
     5b4:	80 81       	ld	r24, Z
     5b6:	81 11       	cpse	r24, r1
     5b8:	f7 cf       	rjmp	.-18     	; 0x5a8 <LCD_displayString+0x12>
     5ba:	cf 91       	pop	r28
     5bc:	1f 91       	pop	r17
     5be:	0f 91       	pop	r16
     5c0:	08 95       	ret

000005c2 <LCD_goToRowColumn>:
}

void LCD_goToRowColumn(uinteg8_t row, uinteg8_t col)
{
	uinteg8_t address;
	switch(row)
     5c2:	81 30       	cpi	r24, 0x01	; 1
     5c4:	19 f0       	breq	.+6      	; 0x5cc <LCD_goToRowColumn+0xa>
     5c6:	82 30       	cpi	r24, 0x02	; 2
     5c8:	21 f0       	breq	.+8      	; 0x5d2 <LCD_goToRowColumn+0x10>
     5ca:	05 c0       	rjmp	.+10     	; 0x5d6 <LCD_goToRowColumn+0x14>
	{
		case 1:
			address = 0x80 + col-1;
     5cc:	9f e7       	ldi	r25, 0x7F	; 127
     5ce:	96 0f       	add	r25, r22
			//OR LCD_sendCommand(0x80).
			break;
     5d0:	02 c0       	rjmp	.+4      	; 0x5d6 <LCD_goToRowColumn+0x14>
		case 2:
			address = 0xC0 + col-1;
     5d2:	9f eb       	ldi	r25, 0xBF	; 191
     5d4:	96 0f       	add	r25, r22
		default:
			break;
			//Nothing.
	}

    LCD_sendCommand(address | 0b100000000);
     5d6:	89 2f       	mov	r24, r25
     5d8:	0e 94 65 02 	call	0x4ca	; 0x4ca <LCD_sendCommand>
     5dc:	08 95       	ret

000005de <LCD_displayStringRowColumn>:

}

void LCD_displayStringRowColumn(uinteg8_t row,uinteg8_t col,const uinteg8_t *Str)
{
     5de:	cf 93       	push	r28
     5e0:	df 93       	push	r29
     5e2:	ea 01       	movw	r28, r20
	
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
     5e4:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <LCD_goToRowColumn>
	LCD_displayString(Str);
     5e8:	ce 01       	movw	r24, r28
     5ea:	0e 94 cb 02 	call	0x596	; 0x596 <LCD_displayString>

}
     5ee:	df 91       	pop	r29
     5f0:	cf 91       	pop	r28
     5f2:	08 95       	ret

000005f4 <DIO_Init_Pin>:
		default :
		return DIO_ERROR_NOK;
		break;
		}
return DIO_ERROR_OK;
}
     5f4:	80 32       	cpi	r24, 0x20	; 32
     5f6:	08 f0       	brcs	.+2      	; 0x5fa <DIO_Init_Pin+0x6>
     5f8:	8f c0       	rjmp	.+286    	; 0x718 <DIO_Init_Pin+0x124>
     5fa:	98 2f       	mov	r25, r24
     5fc:	97 70       	andi	r25, 0x07	; 7
     5fe:	86 95       	lsr	r24
     600:	86 95       	lsr	r24
     602:	86 95       	lsr	r24
     604:	8f 5b       	subi	r24, 0xBF	; 191
     606:	82 34       	cpi	r24, 0x42	; 66
     608:	51 f1       	breq	.+84     	; 0x65e <DIO_Init_Pin+0x6a>
     60a:	18 f4       	brcc	.+6      	; 0x612 <DIO_Init_Pin+0x1e>
     60c:	81 34       	cpi	r24, 0x41	; 65
     60e:	41 f0       	breq	.+16     	; 0x620 <DIO_Init_Pin+0x2c>
     610:	85 c0       	rjmp	.+266    	; 0x71c <DIO_Init_Pin+0x128>
     612:	83 34       	cpi	r24, 0x43	; 67
     614:	09 f4       	brne	.+2      	; 0x618 <DIO_Init_Pin+0x24>
     616:	42 c0       	rjmp	.+132    	; 0x69c <DIO_Init_Pin+0xa8>
     618:	84 34       	cpi	r24, 0x44	; 68
     61a:	09 f4       	brne	.+2      	; 0x61e <DIO_Init_Pin+0x2a>
     61c:	5e c0       	rjmp	.+188    	; 0x6da <DIO_Init_Pin+0xe6>
     61e:	7e c0       	rjmp	.+252    	; 0x71c <DIO_Init_Pin+0x128>
     620:	61 11       	cpse	r22, r1
     622:	0f c0       	rjmp	.+30     	; 0x642 <DIO_Init_Pin+0x4e>
     624:	4a b3       	in	r20, 0x1a	; 26
     626:	21 e0       	ldi	r18, 0x01	; 1
     628:	30 e0       	ldi	r19, 0x00	; 0
     62a:	b9 01       	movw	r22, r18
     62c:	02 c0       	rjmp	.+4      	; 0x632 <DIO_Init_Pin+0x3e>
     62e:	66 0f       	add	r22, r22
     630:	77 1f       	adc	r23, r23
     632:	9a 95       	dec	r25
     634:	e2 f7       	brpl	.-8      	; 0x62e <DIO_Init_Pin+0x3a>
     636:	cb 01       	movw	r24, r22
     638:	80 95       	com	r24
     63a:	84 23       	and	r24, r20
     63c:	8a bb       	out	0x1a, r24	; 26
     63e:	80 e0       	ldi	r24, 0x00	; 0
     640:	08 95       	ret
     642:	4a b3       	in	r20, 0x1a	; 26
     644:	21 e0       	ldi	r18, 0x01	; 1
     646:	30 e0       	ldi	r19, 0x00	; 0
     648:	b9 01       	movw	r22, r18
     64a:	02 c0       	rjmp	.+4      	; 0x650 <DIO_Init_Pin+0x5c>
     64c:	66 0f       	add	r22, r22
     64e:	77 1f       	adc	r23, r23
     650:	9a 95       	dec	r25
     652:	e2 f7       	brpl	.-8      	; 0x64c <DIO_Init_Pin+0x58>
     654:	cb 01       	movw	r24, r22
     656:	84 2b       	or	r24, r20
     658:	8a bb       	out	0x1a, r24	; 26
     65a:	80 e0       	ldi	r24, 0x00	; 0
     65c:	08 95       	ret
     65e:	61 11       	cpse	r22, r1
     660:	0f c0       	rjmp	.+30     	; 0x680 <DIO_Init_Pin+0x8c>
     662:	47 b3       	in	r20, 0x17	; 23
     664:	21 e0       	ldi	r18, 0x01	; 1
     666:	30 e0       	ldi	r19, 0x00	; 0
     668:	b9 01       	movw	r22, r18
     66a:	02 c0       	rjmp	.+4      	; 0x670 <DIO_Init_Pin+0x7c>
     66c:	66 0f       	add	r22, r22
     66e:	77 1f       	adc	r23, r23
     670:	9a 95       	dec	r25
     672:	e2 f7       	brpl	.-8      	; 0x66c <DIO_Init_Pin+0x78>
     674:	cb 01       	movw	r24, r22
     676:	80 95       	com	r24
     678:	84 23       	and	r24, r20
     67a:	87 bb       	out	0x17, r24	; 23
     67c:	80 e0       	ldi	r24, 0x00	; 0
     67e:	08 95       	ret
     680:	47 b3       	in	r20, 0x17	; 23
     682:	21 e0       	ldi	r18, 0x01	; 1
     684:	30 e0       	ldi	r19, 0x00	; 0
     686:	b9 01       	movw	r22, r18
     688:	02 c0       	rjmp	.+4      	; 0x68e <DIO_Init_Pin+0x9a>
     68a:	66 0f       	add	r22, r22
     68c:	77 1f       	adc	r23, r23
     68e:	9a 95       	dec	r25
     690:	e2 f7       	brpl	.-8      	; 0x68a <DIO_Init_Pin+0x96>
     692:	cb 01       	movw	r24, r22
     694:	84 2b       	or	r24, r20
     696:	87 bb       	out	0x17, r24	; 23
     698:	80 e0       	ldi	r24, 0x00	; 0
     69a:	08 95       	ret
     69c:	61 11       	cpse	r22, r1
     69e:	0f c0       	rjmp	.+30     	; 0x6be <DIO_Init_Pin+0xca>
     6a0:	44 b3       	in	r20, 0x14	; 20
     6a2:	21 e0       	ldi	r18, 0x01	; 1
     6a4:	30 e0       	ldi	r19, 0x00	; 0
     6a6:	b9 01       	movw	r22, r18
     6a8:	02 c0       	rjmp	.+4      	; 0x6ae <DIO_Init_Pin+0xba>
     6aa:	66 0f       	add	r22, r22
     6ac:	77 1f       	adc	r23, r23
     6ae:	9a 95       	dec	r25
     6b0:	e2 f7       	brpl	.-8      	; 0x6aa <DIO_Init_Pin+0xb6>
     6b2:	cb 01       	movw	r24, r22
     6b4:	80 95       	com	r24
     6b6:	84 23       	and	r24, r20
     6b8:	84 bb       	out	0x14, r24	; 20
     6ba:	80 e0       	ldi	r24, 0x00	; 0
     6bc:	08 95       	ret
     6be:	44 b3       	in	r20, 0x14	; 20
     6c0:	21 e0       	ldi	r18, 0x01	; 1
     6c2:	30 e0       	ldi	r19, 0x00	; 0
     6c4:	b9 01       	movw	r22, r18
     6c6:	02 c0       	rjmp	.+4      	; 0x6cc <DIO_Init_Pin+0xd8>
     6c8:	66 0f       	add	r22, r22
     6ca:	77 1f       	adc	r23, r23
     6cc:	9a 95       	dec	r25
     6ce:	e2 f7       	brpl	.-8      	; 0x6c8 <DIO_Init_Pin+0xd4>
     6d0:	cb 01       	movw	r24, r22
     6d2:	84 2b       	or	r24, r20
     6d4:	84 bb       	out	0x14, r24	; 20
     6d6:	80 e0       	ldi	r24, 0x00	; 0
     6d8:	08 95       	ret
     6da:	61 11       	cpse	r22, r1
     6dc:	0f c0       	rjmp	.+30     	; 0x6fc <DIO_Init_Pin+0x108>
     6de:	41 b3       	in	r20, 0x11	; 17
     6e0:	21 e0       	ldi	r18, 0x01	; 1
     6e2:	30 e0       	ldi	r19, 0x00	; 0
     6e4:	b9 01       	movw	r22, r18
     6e6:	02 c0       	rjmp	.+4      	; 0x6ec <DIO_Init_Pin+0xf8>
     6e8:	66 0f       	add	r22, r22
     6ea:	77 1f       	adc	r23, r23
     6ec:	9a 95       	dec	r25
     6ee:	e2 f7       	brpl	.-8      	; 0x6e8 <DIO_Init_Pin+0xf4>
     6f0:	cb 01       	movw	r24, r22
     6f2:	80 95       	com	r24
     6f4:	84 23       	and	r24, r20
     6f6:	81 bb       	out	0x11, r24	; 17
     6f8:	80 e0       	ldi	r24, 0x00	; 0
     6fa:	08 95       	ret
     6fc:	41 b3       	in	r20, 0x11	; 17
     6fe:	21 e0       	ldi	r18, 0x01	; 1
     700:	30 e0       	ldi	r19, 0x00	; 0
     702:	b9 01       	movw	r22, r18
     704:	02 c0       	rjmp	.+4      	; 0x70a <DIO_Init_Pin+0x116>
     706:	66 0f       	add	r22, r22
     708:	77 1f       	adc	r23, r23
     70a:	9a 95       	dec	r25
     70c:	e2 f7       	brpl	.-8      	; 0x706 <DIO_Init_Pin+0x112>
     70e:	cb 01       	movw	r24, r22
     710:	84 2b       	or	r24, r20
     712:	81 bb       	out	0x11, r24	; 17
     714:	80 e0       	ldi	r24, 0x00	; 0
     716:	08 95       	ret
     718:	81 e0       	ldi	r24, 0x01	; 1
     71a:	08 95       	ret
     71c:	81 e0       	ldi	r24, 0x01	; 1
     71e:	08 95       	ret

00000720 <DIO_Read_Pin>:
     720:	80 32       	cpi	r24, 0x20	; 32
     722:	08 f0       	brcs	.+2      	; 0x726 <DIO_Read_Pin+0x6>
     724:	4d c0       	rjmp	.+154    	; 0x7c0 <DIO_Read_Pin+0xa0>
     726:	98 2f       	mov	r25, r24
     728:	97 70       	andi	r25, 0x07	; 7
     72a:	86 95       	lsr	r24
     72c:	86 95       	lsr	r24
     72e:	86 95       	lsr	r24
     730:	8f 5b       	subi	r24, 0xBF	; 191
     732:	82 34       	cpi	r24, 0x42	; 66
     734:	c1 f0       	breq	.+48     	; 0x766 <DIO_Read_Pin+0x46>
     736:	18 f4       	brcc	.+6      	; 0x73e <DIO_Read_Pin+0x1e>
     738:	81 34       	cpi	r24, 0x41	; 65
     73a:	31 f0       	breq	.+12     	; 0x748 <DIO_Read_Pin+0x28>
     73c:	43 c0       	rjmp	.+134    	; 0x7c4 <DIO_Read_Pin+0xa4>
     73e:	83 34       	cpi	r24, 0x43	; 67
     740:	09 f1       	breq	.+66     	; 0x784 <DIO_Read_Pin+0x64>
     742:	84 34       	cpi	r24, 0x44	; 68
     744:	71 f1       	breq	.+92     	; 0x7a2 <DIO_Read_Pin+0x82>
     746:	3e c0       	rjmp	.+124    	; 0x7c4 <DIO_Read_Pin+0xa4>
     748:	89 b3       	in	r24, 0x19	; 25
     74a:	28 2f       	mov	r18, r24
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	a9 01       	movw	r20, r18
     750:	02 c0       	rjmp	.+4      	; 0x756 <DIO_Read_Pin+0x36>
     752:	55 95       	asr	r21
     754:	47 95       	ror	r20
     756:	9a 95       	dec	r25
     758:	e2 f7       	brpl	.-8      	; 0x752 <DIO_Read_Pin+0x32>
     75a:	ca 01       	movw	r24, r20
     75c:	81 70       	andi	r24, 0x01	; 1
     75e:	fb 01       	movw	r30, r22
     760:	80 83       	st	Z, r24
     762:	80 e0       	ldi	r24, 0x00	; 0
     764:	08 95       	ret
     766:	86 b3       	in	r24, 0x16	; 22
     768:	28 2f       	mov	r18, r24
     76a:	30 e0       	ldi	r19, 0x00	; 0
     76c:	a9 01       	movw	r20, r18
     76e:	02 c0       	rjmp	.+4      	; 0x774 <DIO_Read_Pin+0x54>
     770:	55 95       	asr	r21
     772:	47 95       	ror	r20
     774:	9a 95       	dec	r25
     776:	e2 f7       	brpl	.-8      	; 0x770 <DIO_Read_Pin+0x50>
     778:	ca 01       	movw	r24, r20
     77a:	81 70       	andi	r24, 0x01	; 1
     77c:	fb 01       	movw	r30, r22
     77e:	80 83       	st	Z, r24
     780:	80 e0       	ldi	r24, 0x00	; 0
     782:	08 95       	ret
     784:	83 b3       	in	r24, 0x13	; 19
     786:	28 2f       	mov	r18, r24
     788:	30 e0       	ldi	r19, 0x00	; 0
     78a:	a9 01       	movw	r20, r18
     78c:	02 c0       	rjmp	.+4      	; 0x792 <DIO_Read_Pin+0x72>
     78e:	55 95       	asr	r21
     790:	47 95       	ror	r20
     792:	9a 95       	dec	r25
     794:	e2 f7       	brpl	.-8      	; 0x78e <DIO_Read_Pin+0x6e>
     796:	ca 01       	movw	r24, r20
     798:	81 70       	andi	r24, 0x01	; 1
     79a:	fb 01       	movw	r30, r22
     79c:	80 83       	st	Z, r24
     79e:	80 e0       	ldi	r24, 0x00	; 0
     7a0:	08 95       	ret
     7a2:	80 b3       	in	r24, 0x10	; 16
     7a4:	28 2f       	mov	r18, r24
     7a6:	30 e0       	ldi	r19, 0x00	; 0
     7a8:	a9 01       	movw	r20, r18
     7aa:	02 c0       	rjmp	.+4      	; 0x7b0 <DIO_Read_Pin+0x90>
     7ac:	55 95       	asr	r21
     7ae:	47 95       	ror	r20
     7b0:	9a 95       	dec	r25
     7b2:	e2 f7       	brpl	.-8      	; 0x7ac <DIO_Read_Pin+0x8c>
     7b4:	ca 01       	movw	r24, r20
     7b6:	81 70       	andi	r24, 0x01	; 1
     7b8:	fb 01       	movw	r30, r22
     7ba:	80 83       	st	Z, r24
     7bc:	80 e0       	ldi	r24, 0x00	; 0
     7be:	08 95       	ret
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	08 95       	ret
     7c4:	81 e0       	ldi	r24, 0x01	; 1
     7c6:	08 95       	ret

000007c8 <DIO_Write_Pin>:
     7c8:	80 32       	cpi	r24, 0x20	; 32
     7ca:	08 f0       	brcs	.+2      	; 0x7ce <DIO_Write_Pin+0x6>
     7cc:	8f c0       	rjmp	.+286    	; 0x8ec <__stack+0x8d>
     7ce:	98 2f       	mov	r25, r24
     7d0:	97 70       	andi	r25, 0x07	; 7
     7d2:	86 95       	lsr	r24
     7d4:	86 95       	lsr	r24
     7d6:	86 95       	lsr	r24
     7d8:	8f 5b       	subi	r24, 0xBF	; 191
     7da:	82 34       	cpi	r24, 0x42	; 66
     7dc:	51 f1       	breq	.+84     	; 0x832 <DIO_Write_Pin+0x6a>
     7de:	18 f4       	brcc	.+6      	; 0x7e6 <DIO_Write_Pin+0x1e>
     7e0:	81 34       	cpi	r24, 0x41	; 65
     7e2:	41 f0       	breq	.+16     	; 0x7f4 <DIO_Write_Pin+0x2c>
     7e4:	85 c0       	rjmp	.+266    	; 0x8f0 <__stack+0x91>
     7e6:	83 34       	cpi	r24, 0x43	; 67
     7e8:	09 f4       	brne	.+2      	; 0x7ec <DIO_Write_Pin+0x24>
     7ea:	42 c0       	rjmp	.+132    	; 0x870 <__stack+0x11>
     7ec:	84 34       	cpi	r24, 0x44	; 68
     7ee:	09 f4       	brne	.+2      	; 0x7f2 <DIO_Write_Pin+0x2a>
     7f0:	5e c0       	rjmp	.+188    	; 0x8ae <__stack+0x4f>
     7f2:	7e c0       	rjmp	.+252    	; 0x8f0 <__stack+0x91>
     7f4:	61 11       	cpse	r22, r1
     7f6:	0f c0       	rjmp	.+30     	; 0x816 <DIO_Write_Pin+0x4e>
     7f8:	4b b3       	in	r20, 0x1b	; 27
     7fa:	21 e0       	ldi	r18, 0x01	; 1
     7fc:	30 e0       	ldi	r19, 0x00	; 0
     7fe:	b9 01       	movw	r22, r18
     800:	02 c0       	rjmp	.+4      	; 0x806 <DIO_Write_Pin+0x3e>
     802:	66 0f       	add	r22, r22
     804:	77 1f       	adc	r23, r23
     806:	9a 95       	dec	r25
     808:	e2 f7       	brpl	.-8      	; 0x802 <DIO_Write_Pin+0x3a>
     80a:	cb 01       	movw	r24, r22
     80c:	80 95       	com	r24
     80e:	84 23       	and	r24, r20
     810:	8b bb       	out	0x1b, r24	; 27
     812:	80 e0       	ldi	r24, 0x00	; 0
     814:	08 95       	ret
     816:	4b b3       	in	r20, 0x1b	; 27
     818:	21 e0       	ldi	r18, 0x01	; 1
     81a:	30 e0       	ldi	r19, 0x00	; 0
     81c:	b9 01       	movw	r22, r18
     81e:	02 c0       	rjmp	.+4      	; 0x824 <DIO_Write_Pin+0x5c>
     820:	66 0f       	add	r22, r22
     822:	77 1f       	adc	r23, r23
     824:	9a 95       	dec	r25
     826:	e2 f7       	brpl	.-8      	; 0x820 <DIO_Write_Pin+0x58>
     828:	cb 01       	movw	r24, r22
     82a:	84 2b       	or	r24, r20
     82c:	8b bb       	out	0x1b, r24	; 27
     82e:	80 e0       	ldi	r24, 0x00	; 0
     830:	08 95       	ret
     832:	61 11       	cpse	r22, r1
     834:	0f c0       	rjmp	.+30     	; 0x854 <DIO_Write_Pin+0x8c>
     836:	48 b3       	in	r20, 0x18	; 24
     838:	21 e0       	ldi	r18, 0x01	; 1
     83a:	30 e0       	ldi	r19, 0x00	; 0
     83c:	b9 01       	movw	r22, r18
     83e:	02 c0       	rjmp	.+4      	; 0x844 <DIO_Write_Pin+0x7c>
     840:	66 0f       	add	r22, r22
     842:	77 1f       	adc	r23, r23
     844:	9a 95       	dec	r25
     846:	e2 f7       	brpl	.-8      	; 0x840 <DIO_Write_Pin+0x78>
     848:	cb 01       	movw	r24, r22
     84a:	80 95       	com	r24
     84c:	84 23       	and	r24, r20
     84e:	88 bb       	out	0x18, r24	; 24
     850:	80 e0       	ldi	r24, 0x00	; 0
     852:	08 95       	ret
     854:	48 b3       	in	r20, 0x18	; 24
     856:	21 e0       	ldi	r18, 0x01	; 1
     858:	30 e0       	ldi	r19, 0x00	; 0
     85a:	b9 01       	movw	r22, r18
     85c:	02 c0       	rjmp	.+4      	; 0x862 <__stack+0x3>
     85e:	66 0f       	add	r22, r22
     860:	77 1f       	adc	r23, r23
     862:	9a 95       	dec	r25
     864:	e2 f7       	brpl	.-8      	; 0x85e <DIO_Write_Pin+0x96>
     866:	cb 01       	movw	r24, r22
     868:	84 2b       	or	r24, r20
     86a:	88 bb       	out	0x18, r24	; 24
     86c:	80 e0       	ldi	r24, 0x00	; 0
     86e:	08 95       	ret
     870:	61 11       	cpse	r22, r1
     872:	0f c0       	rjmp	.+30     	; 0x892 <__stack+0x33>
     874:	45 b3       	in	r20, 0x15	; 21
     876:	21 e0       	ldi	r18, 0x01	; 1
     878:	30 e0       	ldi	r19, 0x00	; 0
     87a:	b9 01       	movw	r22, r18
     87c:	02 c0       	rjmp	.+4      	; 0x882 <__stack+0x23>
     87e:	66 0f       	add	r22, r22
     880:	77 1f       	adc	r23, r23
     882:	9a 95       	dec	r25
     884:	e2 f7       	brpl	.-8      	; 0x87e <__stack+0x1f>
     886:	cb 01       	movw	r24, r22
     888:	80 95       	com	r24
     88a:	84 23       	and	r24, r20
     88c:	85 bb       	out	0x15, r24	; 21
     88e:	80 e0       	ldi	r24, 0x00	; 0
     890:	08 95       	ret
     892:	45 b3       	in	r20, 0x15	; 21
     894:	21 e0       	ldi	r18, 0x01	; 1
     896:	30 e0       	ldi	r19, 0x00	; 0
     898:	b9 01       	movw	r22, r18
     89a:	02 c0       	rjmp	.+4      	; 0x8a0 <__stack+0x41>
     89c:	66 0f       	add	r22, r22
     89e:	77 1f       	adc	r23, r23
     8a0:	9a 95       	dec	r25
     8a2:	e2 f7       	brpl	.-8      	; 0x89c <__stack+0x3d>
     8a4:	cb 01       	movw	r24, r22
     8a6:	84 2b       	or	r24, r20
     8a8:	85 bb       	out	0x15, r24	; 21
     8aa:	80 e0       	ldi	r24, 0x00	; 0
     8ac:	08 95       	ret
     8ae:	61 11       	cpse	r22, r1
     8b0:	0f c0       	rjmp	.+30     	; 0x8d0 <__stack+0x71>
     8b2:	42 b3       	in	r20, 0x12	; 18
     8b4:	21 e0       	ldi	r18, 0x01	; 1
     8b6:	30 e0       	ldi	r19, 0x00	; 0
     8b8:	b9 01       	movw	r22, r18
     8ba:	02 c0       	rjmp	.+4      	; 0x8c0 <__stack+0x61>
     8bc:	66 0f       	add	r22, r22
     8be:	77 1f       	adc	r23, r23
     8c0:	9a 95       	dec	r25
     8c2:	e2 f7       	brpl	.-8      	; 0x8bc <__stack+0x5d>
     8c4:	cb 01       	movw	r24, r22
     8c6:	80 95       	com	r24
     8c8:	84 23       	and	r24, r20
     8ca:	82 bb       	out	0x12, r24	; 18
     8cc:	80 e0       	ldi	r24, 0x00	; 0
     8ce:	08 95       	ret
     8d0:	42 b3       	in	r20, 0x12	; 18
     8d2:	21 e0       	ldi	r18, 0x01	; 1
     8d4:	30 e0       	ldi	r19, 0x00	; 0
     8d6:	b9 01       	movw	r22, r18
     8d8:	02 c0       	rjmp	.+4      	; 0x8de <__stack+0x7f>
     8da:	66 0f       	add	r22, r22
     8dc:	77 1f       	adc	r23, r23
     8de:	9a 95       	dec	r25
     8e0:	e2 f7       	brpl	.-8      	; 0x8da <__stack+0x7b>
     8e2:	cb 01       	movw	r24, r22
     8e4:	84 2b       	or	r24, r20
     8e6:	82 bb       	out	0x12, r24	; 18
     8e8:	80 e0       	ldi	r24, 0x00	; 0
     8ea:	08 95       	ret
     8ec:	81 e0       	ldi	r24, 0x01	; 1
     8ee:	08 95       	ret
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	08 95       	ret

000008f4 <DIO_toggle_Pin>:
uinteg8_t DIO_toggle_Pin(uinteg8_t pin)
{
	uinteg8_t por;
	if(pin>=PinsNeeded || pin>=No_of_pins ) return DIO_ERROR_NOK;
     8f4:	80 32       	cpi	r24, 0x20	; 32
     8f6:	08 f0       	brcs	.+2      	; 0x8fa <DIO_toggle_Pin+0x6>
     8f8:	49 c0       	rjmp	.+146    	; 0x98c <DIO_toggle_Pin+0x98>
	else
	{
		por='A'+pin/PortSize;
		pin=pin%PortSize;
     8fa:	98 2f       	mov	r25, r24
     8fc:	97 70       	andi	r25, 0x07	; 7
	}
	
	switch(por)
     8fe:	86 95       	lsr	r24
     900:	86 95       	lsr	r24
     902:	86 95       	lsr	r24
     904:	8f 5b       	subi	r24, 0xBF	; 191
     906:	82 34       	cpi	r24, 0x42	; 66
     908:	b9 f0       	breq	.+46     	; 0x938 <DIO_toggle_Pin+0x44>
     90a:	18 f4       	brcc	.+6      	; 0x912 <DIO_toggle_Pin+0x1e>
     90c:	81 34       	cpi	r24, 0x41	; 65
     90e:	31 f0       	breq	.+12     	; 0x91c <DIO_toggle_Pin+0x28>
     910:	3f c0       	rjmp	.+126    	; 0x990 <DIO_toggle_Pin+0x9c>
     912:	83 34       	cpi	r24, 0x43	; 67
     914:	f9 f0       	breq	.+62     	; 0x954 <DIO_toggle_Pin+0x60>
     916:	84 34       	cpi	r24, 0x44	; 68
     918:	59 f1       	breq	.+86     	; 0x970 <DIO_toggle_Pin+0x7c>
     91a:	3a c0       	rjmp	.+116    	; 0x990 <DIO_toggle_Pin+0x9c>
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
     91c:	4b b3       	in	r20, 0x1b	; 27
     91e:	21 e0       	ldi	r18, 0x01	; 1
     920:	30 e0       	ldi	r19, 0x00	; 0
     922:	b9 01       	movw	r22, r18
     924:	02 c0       	rjmp	.+4      	; 0x92a <DIO_toggle_Pin+0x36>
     926:	66 0f       	add	r22, r22
     928:	77 1f       	adc	r23, r23
     92a:	9a 95       	dec	r25
     92c:	e2 f7       	brpl	.-8      	; 0x926 <DIO_toggle_Pin+0x32>
     92e:	cb 01       	movw	r24, r22
     930:	84 27       	eor	r24, r20
     932:	8b bb       	out	0x1b, r24	; 27
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     934:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	switch(por)
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
     936:	08 95       	ret
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
     938:	48 b3       	in	r20, 0x18	; 24
     93a:	21 e0       	ldi	r18, 0x01	; 1
     93c:	30 e0       	ldi	r19, 0x00	; 0
     93e:	b9 01       	movw	r22, r18
     940:	02 c0       	rjmp	.+4      	; 0x946 <DIO_toggle_Pin+0x52>
     942:	66 0f       	add	r22, r22
     944:	77 1f       	adc	r23, r23
     946:	9a 95       	dec	r25
     948:	e2 f7       	brpl	.-8      	; 0x942 <DIO_toggle_Pin+0x4e>
     94a:	cb 01       	movw	r24, r22
     94c:	84 27       	eor	r24, r20
     94e:	88 bb       	out	0x18, r24	; 24
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     950:	80 e0       	ldi	r24, 0x00	; 0
	switch(por)
	{
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
     952:	08 95       	ret
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
     954:	45 b3       	in	r20, 0x15	; 21
     956:	21 e0       	ldi	r18, 0x01	; 1
     958:	30 e0       	ldi	r19, 0x00	; 0
     95a:	b9 01       	movw	r22, r18
     95c:	02 c0       	rjmp	.+4      	; 0x962 <DIO_toggle_Pin+0x6e>
     95e:	66 0f       	add	r22, r22
     960:	77 1f       	adc	r23, r23
     962:	9a 95       	dec	r25
     964:	e2 f7       	brpl	.-8      	; 0x95e <DIO_toggle_Pin+0x6a>
     966:	cb 01       	movw	r24, r22
     968:	84 27       	eor	r24, r20
     96a:	85 bb       	out	0x15, r24	; 21
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     96c:	80 e0       	ldi	r24, 0x00	; 0
		case 'A':TOGGLE_BIT(WriteRegisterA,pin);
			 break;
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
			 break;
     96e:	08 95       	ret
		case 'D':TOGGLE_BIT(WriteRegisterD,pin);
     970:	42 b3       	in	r20, 0x12	; 18
     972:	21 e0       	ldi	r18, 0x01	; 1
     974:	30 e0       	ldi	r19, 0x00	; 0
     976:	b9 01       	movw	r22, r18
     978:	02 c0       	rjmp	.+4      	; 0x97e <DIO_toggle_Pin+0x8a>
     97a:	66 0f       	add	r22, r22
     97c:	77 1f       	adc	r23, r23
     97e:	9a 95       	dec	r25
     980:	e2 f7       	brpl	.-8      	; 0x97a <DIO_toggle_Pin+0x86>
     982:	cb 01       	movw	r24, r22
     984:	84 27       	eor	r24, r20
     986:	82 bb       	out	0x12, r24	; 18
		default :
		return DIO_ERROR_NOK;
		break;
		
	}
	return DIO_ERROR_OK;
     988:	80 e0       	ldi	r24, 0x00	; 0
		case 'B':TOGGLE_BIT(WriteRegisterB,pin);
			 break;
		case 'C':TOGGLE_BIT(WriteRegisterC,pin);
			 break;
		case 'D':TOGGLE_BIT(WriteRegisterD,pin);
			 break;
     98a:	08 95       	ret
return DIO_ERROR_OK;
}
uinteg8_t DIO_toggle_Pin(uinteg8_t pin)
{
	uinteg8_t por;
	if(pin>=PinsNeeded || pin>=No_of_pins ) return DIO_ERROR_NOK;
     98c:	81 e0       	ldi	r24, 0x01	; 1
     98e:	08 95       	ret
			 break;
		case 'G':TOGGLE_BIT(PORTG,pin);
			 break;
#endif
		default :
		return DIO_ERROR_NOK;
     990:	81 e0       	ldi	r24, 0x01	; 1
		break;
		
	}
	return DIO_ERROR_OK;
}
     992:	08 95       	ret

00000994 <Debug_By_Toggle>:
#define Debug_By_Toggle_State_Other_times 1
#define Debug_By_Toggle_State_Nothing     2


void Debug_By_Toggle(uinteg8_t u8_Pin)
{
     994:	cf 93       	push	r28
     996:	c8 2f       	mov	r28, r24
	DIO_Init_Pin(u8_Pin,1);
     998:	61 e0       	ldi	r22, 0x01	; 1
     99a:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <DIO_Init_Pin>
	DIO_toggle_Pin(u8_Pin);
     99e:	8c 2f       	mov	r24, r28
     9a0:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <DIO_toggle_Pin>
     9a4:	cf 91       	pop	r28
     9a6:	08 95       	ret

000009a8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     9a8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9aa:	03 96       	adiw	r24, 0x03	; 3
     9ac:	92 83       	std	Z+2, r25	; 0x02
     9ae:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     9b0:	2f ef       	ldi	r18, 0xFF	; 255
     9b2:	3f ef       	ldi	r19, 0xFF	; 255
     9b4:	34 83       	std	Z+4, r19	; 0x04
     9b6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9b8:	96 83       	std	Z+6, r25	; 0x06
     9ba:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9bc:	90 87       	std	Z+8, r25	; 0x08
     9be:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     9c0:	10 82       	st	Z, r1
     9c2:	08 95       	ret

000009c4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     9c4:	fc 01       	movw	r30, r24
     9c6:	11 86       	std	Z+9, r1	; 0x09
     9c8:	10 86       	std	Z+8, r1	; 0x08
     9ca:	08 95       	ret

000009cc <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9cc:	cf 93       	push	r28
     9ce:	df 93       	push	r29
     9d0:	9c 01       	movw	r18, r24
     9d2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     9d4:	dc 01       	movw	r26, r24
     9d6:	11 96       	adiw	r26, 0x01	; 1
     9d8:	cd 91       	ld	r28, X+
     9da:	dc 91       	ld	r29, X
     9dc:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     9de:	d3 83       	std	Z+3, r29	; 0x03
     9e0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9e2:	8c 81       	ldd	r24, Y+4	; 0x04
     9e4:	9d 81       	ldd	r25, Y+5	; 0x05
     9e6:	95 83       	std	Z+5, r25	; 0x05
     9e8:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     9ea:	8c 81       	ldd	r24, Y+4	; 0x04
     9ec:	9d 81       	ldd	r25, Y+5	; 0x05
     9ee:	dc 01       	movw	r26, r24
     9f0:	13 96       	adiw	r26, 0x03	; 3
     9f2:	7c 93       	st	X, r23
     9f4:	6e 93       	st	-X, r22
     9f6:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     9f8:	7d 83       	std	Y+5, r23	; 0x05
     9fa:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     9fc:	31 87       	std	Z+9, r19	; 0x09
     9fe:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     a00:	f9 01       	movw	r30, r18
     a02:	80 81       	ld	r24, Z
     a04:	8f 5f       	subi	r24, 0xFF	; 255
     a06:	80 83       	st	Z, r24
}
     a08:	df 91       	pop	r29
     a0a:	cf 91       	pop	r28
     a0c:	08 95       	ret

00000a0e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a0e:	cf 93       	push	r28
     a10:	df 93       	push	r29
     a12:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     a14:	48 81       	ld	r20, Y
     a16:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a18:	4f 3f       	cpi	r20, 0xFF	; 255
     a1a:	2f ef       	ldi	r18, 0xFF	; 255
     a1c:	52 07       	cpc	r21, r18
     a1e:	21 f4       	brne	.+8      	; 0xa28 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a20:	fc 01       	movw	r30, r24
     a22:	a7 81       	ldd	r26, Z+7	; 0x07
     a24:	b0 85       	ldd	r27, Z+8	; 0x08
     a26:	0d c0       	rjmp	.+26     	; 0xa42 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     a28:	dc 01       	movw	r26, r24
     a2a:	13 96       	adiw	r26, 0x03	; 3
     a2c:	01 c0       	rjmp	.+2      	; 0xa30 <vListInsert+0x22>
     a2e:	df 01       	movw	r26, r30
     a30:	12 96       	adiw	r26, 0x02	; 2
     a32:	ed 91       	ld	r30, X+
     a34:	fc 91       	ld	r31, X
     a36:	13 97       	sbiw	r26, 0x03	; 3
     a38:	20 81       	ld	r18, Z
     a3a:	31 81       	ldd	r19, Z+1	; 0x01
     a3c:	42 17       	cp	r20, r18
     a3e:	53 07       	cpc	r21, r19
     a40:	b0 f7       	brcc	.-20     	; 0xa2e <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a42:	12 96       	adiw	r26, 0x02	; 2
     a44:	ed 91       	ld	r30, X+
     a46:	fc 91       	ld	r31, X
     a48:	13 97       	sbiw	r26, 0x03	; 3
     a4a:	fb 83       	std	Y+3, r31	; 0x03
     a4c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a4e:	d5 83       	std	Z+5, r29	; 0x05
     a50:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a52:	bd 83       	std	Y+5, r27	; 0x05
     a54:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a56:	13 96       	adiw	r26, 0x03	; 3
     a58:	dc 93       	st	X, r29
     a5a:	ce 93       	st	-X, r28
     a5c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     a5e:	99 87       	std	Y+9, r25	; 0x09
     a60:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a62:	fc 01       	movw	r30, r24
     a64:	20 81       	ld	r18, Z
     a66:	2f 5f       	subi	r18, 0xFF	; 255
     a68:	20 83       	st	Z, r18
}
     a6a:	df 91       	pop	r29
     a6c:	cf 91       	pop	r28
     a6e:	08 95       	ret

00000a70 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a70:	cf 93       	push	r28
     a72:	df 93       	push	r29
     a74:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     a76:	a0 85       	ldd	r26, Z+8	; 0x08
     a78:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a7a:	c2 81       	ldd	r28, Z+2	; 0x02
     a7c:	d3 81       	ldd	r29, Z+3	; 0x03
     a7e:	84 81       	ldd	r24, Z+4	; 0x04
     a80:	95 81       	ldd	r25, Z+5	; 0x05
     a82:	9d 83       	std	Y+5, r25	; 0x05
     a84:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a86:	c4 81       	ldd	r28, Z+4	; 0x04
     a88:	d5 81       	ldd	r29, Z+5	; 0x05
     a8a:	82 81       	ldd	r24, Z+2	; 0x02
     a8c:	93 81       	ldd	r25, Z+3	; 0x03
     a8e:	9b 83       	std	Y+3, r25	; 0x03
     a90:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a92:	11 96       	adiw	r26, 0x01	; 1
     a94:	8d 91       	ld	r24, X+
     a96:	9c 91       	ld	r25, X
     a98:	12 97       	sbiw	r26, 0x02	; 2
     a9a:	e8 17       	cp	r30, r24
     a9c:	f9 07       	cpc	r31, r25
     a9e:	31 f4       	brne	.+12     	; 0xaac <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     aa0:	84 81       	ldd	r24, Z+4	; 0x04
     aa2:	95 81       	ldd	r25, Z+5	; 0x05
     aa4:	12 96       	adiw	r26, 0x02	; 2
     aa6:	9c 93       	st	X, r25
     aa8:	8e 93       	st	-X, r24
     aaa:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     aac:	11 86       	std	Z+9, r1	; 0x09
     aae:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     ab0:	8c 91       	ld	r24, X
     ab2:	81 50       	subi	r24, 0x01	; 1
     ab4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     ab6:	8c 91       	ld	r24, X
}
     ab8:	df 91       	pop	r29
     aba:	cf 91       	pop	r28
     abc:	08 95       	ret

00000abe <pxPortInitialiseStack>:
	{
		vTaskSwitchContext();
	}
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
     abe:	31 e1       	ldi	r19, 0x11	; 17
     ac0:	fc 01       	movw	r30, r24
     ac2:	30 83       	st	Z, r19
     ac4:	31 97       	sbiw	r30, 0x01	; 1
     ac6:	22 e2       	ldi	r18, 0x22	; 34
     ac8:	20 83       	st	Z, r18
     aca:	31 97       	sbiw	r30, 0x01	; 1
     acc:	a3 e3       	ldi	r26, 0x33	; 51
     ace:	a0 83       	st	Z, r26
     ad0:	31 97       	sbiw	r30, 0x01	; 1
     ad2:	60 83       	st	Z, r22
     ad4:	31 97       	sbiw	r30, 0x01	; 1
     ad6:	70 83       	st	Z, r23
     ad8:	31 97       	sbiw	r30, 0x01	; 1
     ada:	10 82       	st	Z, r1
     adc:	31 97       	sbiw	r30, 0x01	; 1
     ade:	60 e8       	ldi	r22, 0x80	; 128
     ae0:	60 83       	st	Z, r22
     ae2:	31 97       	sbiw	r30, 0x01	; 1
     ae4:	10 82       	st	Z, r1
     ae6:	31 97       	sbiw	r30, 0x01	; 1
     ae8:	62 e0       	ldi	r22, 0x02	; 2
     aea:	60 83       	st	Z, r22
     aec:	31 97       	sbiw	r30, 0x01	; 1
     aee:	63 e0       	ldi	r22, 0x03	; 3
     af0:	60 83       	st	Z, r22
     af2:	31 97       	sbiw	r30, 0x01	; 1
     af4:	64 e0       	ldi	r22, 0x04	; 4
     af6:	60 83       	st	Z, r22
     af8:	31 97       	sbiw	r30, 0x01	; 1
     afa:	65 e0       	ldi	r22, 0x05	; 5
     afc:	60 83       	st	Z, r22
     afe:	31 97       	sbiw	r30, 0x01	; 1
     b00:	66 e0       	ldi	r22, 0x06	; 6
     b02:	60 83       	st	Z, r22
     b04:	31 97       	sbiw	r30, 0x01	; 1
     b06:	67 e0       	ldi	r22, 0x07	; 7
     b08:	60 83       	st	Z, r22
     b0a:	31 97       	sbiw	r30, 0x01	; 1
     b0c:	68 e0       	ldi	r22, 0x08	; 8
     b0e:	60 83       	st	Z, r22
     b10:	31 97       	sbiw	r30, 0x01	; 1
     b12:	69 e0       	ldi	r22, 0x09	; 9
     b14:	60 83       	st	Z, r22
     b16:	31 97       	sbiw	r30, 0x01	; 1
     b18:	60 e1       	ldi	r22, 0x10	; 16
     b1a:	60 83       	st	Z, r22
     b1c:	31 97       	sbiw	r30, 0x01	; 1
     b1e:	30 83       	st	Z, r19
     b20:	31 97       	sbiw	r30, 0x01	; 1
     b22:	32 e1       	ldi	r19, 0x12	; 18
     b24:	30 83       	st	Z, r19
     b26:	31 97       	sbiw	r30, 0x01	; 1
     b28:	33 e1       	ldi	r19, 0x13	; 19
     b2a:	30 83       	st	Z, r19
     b2c:	31 97       	sbiw	r30, 0x01	; 1
     b2e:	34 e1       	ldi	r19, 0x14	; 20
     b30:	30 83       	st	Z, r19
     b32:	31 97       	sbiw	r30, 0x01	; 1
     b34:	35 e1       	ldi	r19, 0x15	; 21
     b36:	30 83       	st	Z, r19
     b38:	31 97       	sbiw	r30, 0x01	; 1
     b3a:	36 e1       	ldi	r19, 0x16	; 22
     b3c:	30 83       	st	Z, r19
     b3e:	31 97       	sbiw	r30, 0x01	; 1
     b40:	37 e1       	ldi	r19, 0x17	; 23
     b42:	30 83       	st	Z, r19
     b44:	31 97       	sbiw	r30, 0x01	; 1
     b46:	38 e1       	ldi	r19, 0x18	; 24
     b48:	30 83       	st	Z, r19
     b4a:	31 97       	sbiw	r30, 0x01	; 1
     b4c:	39 e1       	ldi	r19, 0x19	; 25
     b4e:	30 83       	st	Z, r19
     b50:	31 97       	sbiw	r30, 0x01	; 1
     b52:	30 e2       	ldi	r19, 0x20	; 32
     b54:	30 83       	st	Z, r19
     b56:	31 97       	sbiw	r30, 0x01	; 1
     b58:	31 e2       	ldi	r19, 0x21	; 33
     b5a:	30 83       	st	Z, r19
     b5c:	31 97       	sbiw	r30, 0x01	; 1
     b5e:	20 83       	st	Z, r18
     b60:	31 97       	sbiw	r30, 0x01	; 1
     b62:	23 e2       	ldi	r18, 0x23	; 35
     b64:	20 83       	st	Z, r18
     b66:	31 97       	sbiw	r30, 0x01	; 1
     b68:	40 83       	st	Z, r20
     b6a:	31 97       	sbiw	r30, 0x01	; 1
     b6c:	50 83       	st	Z, r21
     b6e:	31 97       	sbiw	r30, 0x01	; 1
     b70:	26 e2       	ldi	r18, 0x26	; 38
     b72:	20 83       	st	Z, r18
     b74:	31 97       	sbiw	r30, 0x01	; 1
     b76:	27 e2       	ldi	r18, 0x27	; 39
     b78:	20 83       	st	Z, r18
     b7a:	31 97       	sbiw	r30, 0x01	; 1
     b7c:	28 e2       	ldi	r18, 0x28	; 40
     b7e:	20 83       	st	Z, r18
     b80:	31 97       	sbiw	r30, 0x01	; 1
     b82:	29 e2       	ldi	r18, 0x29	; 41
     b84:	20 83       	st	Z, r18
     b86:	31 97       	sbiw	r30, 0x01	; 1
     b88:	20 e3       	ldi	r18, 0x30	; 48
     b8a:	20 83       	st	Z, r18
     b8c:	31 97       	sbiw	r30, 0x01	; 1
     b8e:	21 e3       	ldi	r18, 0x31	; 49
     b90:	20 83       	st	Z, r18
     b92:	86 97       	sbiw	r24, 0x26	; 38
     b94:	08 95       	ret

00000b96 <xPortStartScheduler>:
     b96:	1b bc       	out	0x2b, r1	; 43
     b98:	8c e7       	ldi	r24, 0x7C	; 124
     b9a:	8a bd       	out	0x2a, r24	; 42
     b9c:	8b e0       	ldi	r24, 0x0B	; 11
     b9e:	8e bd       	out	0x2e, r24	; 46
     ba0:	89 b7       	in	r24, 0x39	; 57
     ba2:	80 61       	ori	r24, 0x10	; 16
     ba4:	89 bf       	out	0x39, r24	; 57
     ba6:	a0 91 ed 06 	lds	r26, 0x06ED	; 0x8006ed <pxCurrentTCB>
     baa:	b0 91 ee 06 	lds	r27, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
     bae:	cd 91       	ld	r28, X+
     bb0:	cd bf       	out	0x3d, r28	; 61
     bb2:	dd 91       	ld	r29, X+
     bb4:	de bf       	out	0x3e, r29	; 62
     bb6:	ff 91       	pop	r31
     bb8:	ef 91       	pop	r30
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	bf 91       	pop	r27
     bc0:	af 91       	pop	r26
     bc2:	9f 91       	pop	r25
     bc4:	8f 91       	pop	r24
     bc6:	7f 91       	pop	r23
     bc8:	6f 91       	pop	r22
     bca:	5f 91       	pop	r21
     bcc:	4f 91       	pop	r20
     bce:	3f 91       	pop	r19
     bd0:	2f 91       	pop	r18
     bd2:	1f 91       	pop	r17
     bd4:	0f 91       	pop	r16
     bd6:	ff 90       	pop	r15
     bd8:	ef 90       	pop	r14
     bda:	df 90       	pop	r13
     bdc:	cf 90       	pop	r12
     bde:	bf 90       	pop	r11
     be0:	af 90       	pop	r10
     be2:	9f 90       	pop	r9
     be4:	8f 90       	pop	r8
     be6:	7f 90       	pop	r7
     be8:	6f 90       	pop	r6
     bea:	5f 90       	pop	r5
     bec:	4f 90       	pop	r4
     bee:	3f 90       	pop	r3
     bf0:	2f 90       	pop	r2
     bf2:	1f 90       	pop	r1
     bf4:	0f 90       	pop	r0
     bf6:	0f be       	out	0x3f, r0	; 63
     bf8:	0f 90       	pop	r0
     bfa:	08 95       	ret
     bfc:	81 e0       	ldi	r24, 0x01	; 1
     bfe:	08 95       	ret

00000c00 <vPortYield>:
     c00:	0f 92       	push	r0
     c02:	0f b6       	in	r0, 0x3f	; 63
     c04:	f8 94       	cli
     c06:	0f 92       	push	r0
     c08:	1f 92       	push	r1
     c0a:	11 24       	eor	r1, r1
     c0c:	2f 92       	push	r2
     c0e:	3f 92       	push	r3
     c10:	4f 92       	push	r4
     c12:	5f 92       	push	r5
     c14:	6f 92       	push	r6
     c16:	7f 92       	push	r7
     c18:	8f 92       	push	r8
     c1a:	9f 92       	push	r9
     c1c:	af 92       	push	r10
     c1e:	bf 92       	push	r11
     c20:	cf 92       	push	r12
     c22:	df 92       	push	r13
     c24:	ef 92       	push	r14
     c26:	ff 92       	push	r15
     c28:	0f 93       	push	r16
     c2a:	1f 93       	push	r17
     c2c:	2f 93       	push	r18
     c2e:	3f 93       	push	r19
     c30:	4f 93       	push	r20
     c32:	5f 93       	push	r21
     c34:	6f 93       	push	r22
     c36:	7f 93       	push	r23
     c38:	8f 93       	push	r24
     c3a:	9f 93       	push	r25
     c3c:	af 93       	push	r26
     c3e:	bf 93       	push	r27
     c40:	cf 93       	push	r28
     c42:	df 93       	push	r29
     c44:	ef 93       	push	r30
     c46:	ff 93       	push	r31
     c48:	a0 91 ed 06 	lds	r26, 0x06ED	; 0x8006ed <pxCurrentTCB>
     c4c:	b0 91 ee 06 	lds	r27, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
     c50:	0d b6       	in	r0, 0x3d	; 61
     c52:	0d 92       	st	X+, r0
     c54:	0e b6       	in	r0, 0x3e	; 62
     c56:	0d 92       	st	X+, r0
     c58:	0e 94 95 0c 	call	0x192a	; 0x192a <vTaskSwitchContext>
     c5c:	a0 91 ed 06 	lds	r26, 0x06ED	; 0x8006ed <pxCurrentTCB>
     c60:	b0 91 ee 06 	lds	r27, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
     c64:	cd 91       	ld	r28, X+
     c66:	cd bf       	out	0x3d, r28	; 61
     c68:	dd 91       	ld	r29, X+
     c6a:	de bf       	out	0x3e, r29	; 62
     c6c:	ff 91       	pop	r31
     c6e:	ef 91       	pop	r30
     c70:	df 91       	pop	r29
     c72:	cf 91       	pop	r28
     c74:	bf 91       	pop	r27
     c76:	af 91       	pop	r26
     c78:	9f 91       	pop	r25
     c7a:	8f 91       	pop	r24
     c7c:	7f 91       	pop	r23
     c7e:	6f 91       	pop	r22
     c80:	5f 91       	pop	r21
     c82:	4f 91       	pop	r20
     c84:	3f 91       	pop	r19
     c86:	2f 91       	pop	r18
     c88:	1f 91       	pop	r17
     c8a:	0f 91       	pop	r16
     c8c:	ff 90       	pop	r15
     c8e:	ef 90       	pop	r14
     c90:	df 90       	pop	r13
     c92:	cf 90       	pop	r12
     c94:	bf 90       	pop	r11
     c96:	af 90       	pop	r10
     c98:	9f 90       	pop	r9
     c9a:	8f 90       	pop	r8
     c9c:	7f 90       	pop	r7
     c9e:	6f 90       	pop	r6
     ca0:	5f 90       	pop	r5
     ca2:	4f 90       	pop	r4
     ca4:	3f 90       	pop	r3
     ca6:	2f 90       	pop	r2
     ca8:	1f 90       	pop	r1
     caa:	0f 90       	pop	r0
     cac:	0f be       	out	0x3f, r0	; 63
     cae:	0f 90       	pop	r0
     cb0:	08 95       	ret

00000cb2 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
     cb2:	1f 92       	push	r1
     cb4:	0f 92       	push	r0
     cb6:	0f b6       	in	r0, 0x3f	; 63
     cb8:	0f 92       	push	r0
     cba:	11 24       	eor	r1, r1
     cbc:	2f 93       	push	r18
     cbe:	3f 93       	push	r19
     cc0:	4f 93       	push	r20
     cc2:	5f 93       	push	r21
     cc4:	6f 93       	push	r22
     cc6:	7f 93       	push	r23
     cc8:	8f 93       	push	r24
     cca:	9f 93       	push	r25
     ccc:	af 93       	push	r26
     cce:	bf 93       	push	r27
     cd0:	ef 93       	push	r30
     cd2:	ff 93       	push	r31
		xTaskIncrementTick();
     cd4:	0e 94 2c 0b 	call	0x1658	; 0x1658 <xTaskIncrementTick>
	}
     cd8:	ff 91       	pop	r31
     cda:	ef 91       	pop	r30
     cdc:	bf 91       	pop	r27
     cde:	af 91       	pop	r26
     ce0:	9f 91       	pop	r25
     ce2:	8f 91       	pop	r24
     ce4:	7f 91       	pop	r23
     ce6:	6f 91       	pop	r22
     ce8:	5f 91       	pop	r21
     cea:	4f 91       	pop	r20
     cec:	3f 91       	pop	r19
     cee:	2f 91       	pop	r18
     cf0:	0f 90       	pop	r0
     cf2:	0f be       	out	0x3f, r0	; 63
     cf4:	0f 90       	pop	r0
     cf6:	1f 90       	pop	r1
     cf8:	18 95       	reti

00000cfa <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     cfa:	cf 93       	push	r28
     cfc:	df 93       	push	r29
     cfe:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     d00:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     d04:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <pucAlignedHeap.2084>
     d08:	90 91 a1 00 	lds	r25, 0x00A1	; 0x8000a1 <pucAlignedHeap.2084+0x1>
     d0c:	89 2b       	or	r24, r25
     d0e:	31 f4       	brne	.+12     	; 0xd1c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     d10:	85 ea       	ldi	r24, 0xA5	; 165
     d12:	90 e0       	ldi	r25, 0x00	; 0
     d14:	90 93 a1 00 	sts	0x00A1, r25	; 0x8000a1 <pucAlignedHeap.2084+0x1>
     d18:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     d1c:	20 91 a2 00 	lds	r18, 0x00A2	; 0x8000a2 <xNextFreeByte>
     d20:	30 91 a3 00 	lds	r19, 0x00A3	; 0x8000a3 <xNextFreeByte+0x1>
     d24:	c9 01       	movw	r24, r18
     d26:	8c 0f       	add	r24, r28
     d28:	9d 1f       	adc	r25, r29
     d2a:	8b 3d       	cpi	r24, 0xDB	; 219
     d2c:	45 e0       	ldi	r20, 0x05	; 5
     d2e:	94 07       	cpc	r25, r20
     d30:	70 f4       	brcc	.+28     	; 0xd4e <pvPortMalloc+0x54>
     d32:	28 17       	cp	r18, r24
     d34:	39 07       	cpc	r19, r25
     d36:	70 f4       	brcc	.+28     	; 0xd54 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     d38:	c0 91 a0 00 	lds	r28, 0x00A0	; 0x8000a0 <pucAlignedHeap.2084>
     d3c:	d0 91 a1 00 	lds	r29, 0x00A1	; 0x8000a1 <pucAlignedHeap.2084+0x1>
     d40:	c2 0f       	add	r28, r18
     d42:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     d44:	90 93 a3 00 	sts	0x00A3, r25	; 0x8000a3 <xNextFreeByte+0x1>
     d48:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <xNextFreeByte>
     d4c:	05 c0       	rjmp	.+10     	; 0xd58 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     d4e:	c0 e0       	ldi	r28, 0x00	; 0
     d50:	d0 e0       	ldi	r29, 0x00	; 0
     d52:	02 c0       	rjmp	.+4      	; 0xd58 <pvPortMalloc+0x5e>
     d54:	c0 e0       	ldi	r28, 0x00	; 0
     d56:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     d58:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     d5c:	ce 01       	movw	r24, r28
     d5e:	df 91       	pop	r29
     d60:	cf 91       	pop	r28
     d62:	08 95       	ret

00000d64 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     d64:	08 95       	ret

00000d66 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     d66:	0f b6       	in	r0, 0x3f	; 63
     d68:	f8 94       	cli
     d6a:	0f 92       	push	r0
     d6c:	fc 01       	movw	r30, r24
     d6e:	92 8d       	ldd	r25, Z+26	; 0x1a
     d70:	0f 90       	pop	r0
     d72:	0f be       	out	0x3f, r0	; 63
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	91 11       	cpse	r25, r1
     d78:	80 e0       	ldi	r24, 0x00	; 0
     d7a:	08 95       	ret

00000d7c <prvCopyDataToQueue>:
     d7c:	0f 93       	push	r16
     d7e:	1f 93       	push	r17
     d80:	cf 93       	push	r28
     d82:	df 93       	push	r29
     d84:	ec 01       	movw	r28, r24
     d86:	04 2f       	mov	r16, r20
     d88:	1a 8d       	ldd	r17, Y+26	; 0x1a
     d8a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     d8c:	44 23       	and	r20, r20
     d8e:	b9 f1       	breq	.+110    	; 0xdfe <prvCopyDataToQueue+0x82>
     d90:	01 11       	cpse	r16, r1
     d92:	16 c0       	rjmp	.+44     	; 0xdc0 <prvCopyDataToQueue+0x44>
     d94:	50 e0       	ldi	r21, 0x00	; 0
     d96:	8a 81       	ldd	r24, Y+2	; 0x02
     d98:	9b 81       	ldd	r25, Y+3	; 0x03
     d9a:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <memcpy>
     d9e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     da0:	8a 81       	ldd	r24, Y+2	; 0x02
     da2:	9b 81       	ldd	r25, Y+3	; 0x03
     da4:	82 0f       	add	r24, r18
     da6:	91 1d       	adc	r25, r1
     da8:	9b 83       	std	Y+3, r25	; 0x03
     daa:	8a 83       	std	Y+2, r24	; 0x02
     dac:	2c 81       	ldd	r18, Y+4	; 0x04
     dae:	3d 81       	ldd	r19, Y+5	; 0x05
     db0:	82 17       	cp	r24, r18
     db2:	93 07       	cpc	r25, r19
     db4:	20 f1       	brcs	.+72     	; 0xdfe <prvCopyDataToQueue+0x82>
     db6:	88 81       	ld	r24, Y
     db8:	99 81       	ldd	r25, Y+1	; 0x01
     dba:	9b 83       	std	Y+3, r25	; 0x03
     dbc:	8a 83       	std	Y+2, r24	; 0x02
     dbe:	1f c0       	rjmp	.+62     	; 0xdfe <prvCopyDataToQueue+0x82>
     dc0:	50 e0       	ldi	r21, 0x00	; 0
     dc2:	8e 81       	ldd	r24, Y+6	; 0x06
     dc4:	9f 81       	ldd	r25, Y+7	; 0x07
     dc6:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <memcpy>
     dca:	8c 8d       	ldd	r24, Y+28	; 0x1c
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	91 95       	neg	r25
     dd0:	81 95       	neg	r24
     dd2:	91 09       	sbc	r25, r1
     dd4:	2e 81       	ldd	r18, Y+6	; 0x06
     dd6:	3f 81       	ldd	r19, Y+7	; 0x07
     dd8:	28 0f       	add	r18, r24
     dda:	39 1f       	adc	r19, r25
     ddc:	3f 83       	std	Y+7, r19	; 0x07
     dde:	2e 83       	std	Y+6, r18	; 0x06
     de0:	48 81       	ld	r20, Y
     de2:	59 81       	ldd	r21, Y+1	; 0x01
     de4:	24 17       	cp	r18, r20
     de6:	35 07       	cpc	r19, r21
     de8:	30 f4       	brcc	.+12     	; 0xdf6 <prvCopyDataToQueue+0x7a>
     dea:	2c 81       	ldd	r18, Y+4	; 0x04
     dec:	3d 81       	ldd	r19, Y+5	; 0x05
     dee:	82 0f       	add	r24, r18
     df0:	93 1f       	adc	r25, r19
     df2:	9f 83       	std	Y+7, r25	; 0x07
     df4:	8e 83       	std	Y+6, r24	; 0x06
     df6:	02 30       	cpi	r16, 0x02	; 2
     df8:	11 f4       	brne	.+4      	; 0xdfe <prvCopyDataToQueue+0x82>
     dfa:	11 11       	cpse	r17, r1
     dfc:	11 50       	subi	r17, 0x01	; 1
     dfe:	1f 5f       	subi	r17, 0xFF	; 255
     e00:	1a 8f       	std	Y+26, r17	; 0x1a
     e02:	80 e0       	ldi	r24, 0x00	; 0
     e04:	df 91       	pop	r29
     e06:	cf 91       	pop	r28
     e08:	1f 91       	pop	r17
     e0a:	0f 91       	pop	r16
     e0c:	08 95       	ret

00000e0e <prvUnlockQueue>:
     e0e:	ef 92       	push	r14
     e10:	ff 92       	push	r15
     e12:	0f 93       	push	r16
     e14:	1f 93       	push	r17
     e16:	cf 93       	push	r28
     e18:	8c 01       	movw	r16, r24
     e1a:	0f b6       	in	r0, 0x3f	; 63
     e1c:	f8 94       	cli
     e1e:	0f 92       	push	r0
     e20:	fc 01       	movw	r30, r24
     e22:	c6 8d       	ldd	r28, Z+30	; 0x1e
     e24:	1c 16       	cp	r1, r28
     e26:	ac f4       	brge	.+42     	; 0xe52 <prvUnlockQueue+0x44>
     e28:	81 89       	ldd	r24, Z+17	; 0x11
     e2a:	81 11       	cpse	r24, r1
     e2c:	06 c0       	rjmp	.+12     	; 0xe3a <prvUnlockQueue+0x2c>
     e2e:	11 c0       	rjmp	.+34     	; 0xe52 <prvUnlockQueue+0x44>
     e30:	f8 01       	movw	r30, r16
     e32:	81 89       	ldd	r24, Z+17	; 0x11
     e34:	81 11       	cpse	r24, r1
     e36:	05 c0       	rjmp	.+10     	; 0xe42 <prvUnlockQueue+0x34>
     e38:	0c c0       	rjmp	.+24     	; 0xe52 <prvUnlockQueue+0x44>
     e3a:	78 01       	movw	r14, r16
     e3c:	f1 e1       	ldi	r31, 0x11	; 17
     e3e:	ef 0e       	add	r14, r31
     e40:	f1 1c       	adc	r15, r1
     e42:	c7 01       	movw	r24, r14
     e44:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <xTaskRemoveFromEventList>
     e48:	81 11       	cpse	r24, r1
     e4a:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <vTaskMissedYield>
     e4e:	c1 50       	subi	r28, 0x01	; 1
     e50:	79 f7       	brne	.-34     	; 0xe30 <prvUnlockQueue+0x22>
     e52:	8f ef       	ldi	r24, 0xFF	; 255
     e54:	f8 01       	movw	r30, r16
     e56:	86 8f       	std	Z+30, r24	; 0x1e
     e58:	0f 90       	pop	r0
     e5a:	0f be       	out	0x3f, r0	; 63
     e5c:	0f b6       	in	r0, 0x3f	; 63
     e5e:	f8 94       	cli
     e60:	0f 92       	push	r0
     e62:	c5 8d       	ldd	r28, Z+29	; 0x1d
     e64:	1c 16       	cp	r1, r28
     e66:	ac f4       	brge	.+42     	; 0xe92 <prvUnlockQueue+0x84>
     e68:	80 85       	ldd	r24, Z+8	; 0x08
     e6a:	81 11       	cpse	r24, r1
     e6c:	06 c0       	rjmp	.+12     	; 0xe7a <prvUnlockQueue+0x6c>
     e6e:	11 c0       	rjmp	.+34     	; 0xe92 <prvUnlockQueue+0x84>
     e70:	f8 01       	movw	r30, r16
     e72:	80 85       	ldd	r24, Z+8	; 0x08
     e74:	81 11       	cpse	r24, r1
     e76:	05 c0       	rjmp	.+10     	; 0xe82 <prvUnlockQueue+0x74>
     e78:	0c c0       	rjmp	.+24     	; 0xe92 <prvUnlockQueue+0x84>
     e7a:	78 01       	movw	r14, r16
     e7c:	f8 e0       	ldi	r31, 0x08	; 8
     e7e:	ef 0e       	add	r14, r31
     e80:	f1 1c       	adc	r15, r1
     e82:	c7 01       	movw	r24, r14
     e84:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <xTaskRemoveFromEventList>
     e88:	81 11       	cpse	r24, r1
     e8a:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <vTaskMissedYield>
     e8e:	c1 50       	subi	r28, 0x01	; 1
     e90:	79 f7       	brne	.-34     	; 0xe70 <prvUnlockQueue+0x62>
     e92:	8f ef       	ldi	r24, 0xFF	; 255
     e94:	f8 01       	movw	r30, r16
     e96:	85 8f       	std	Z+29, r24	; 0x1d
     e98:	0f 90       	pop	r0
     e9a:	0f be       	out	0x3f, r0	; 63
     e9c:	cf 91       	pop	r28
     e9e:	1f 91       	pop	r17
     ea0:	0f 91       	pop	r16
     ea2:	ff 90       	pop	r15
     ea4:	ef 90       	pop	r14
     ea6:	08 95       	ret

00000ea8 <xQueueGenericReset>:
     ea8:	cf 93       	push	r28
     eaa:	df 93       	push	r29
     eac:	ec 01       	movw	r28, r24
     eae:	0f b6       	in	r0, 0x3f	; 63
     eb0:	f8 94       	cli
     eb2:	0f 92       	push	r0
     eb4:	e8 81       	ld	r30, Y
     eb6:	f9 81       	ldd	r31, Y+1	; 0x01
     eb8:	8b 8d       	ldd	r24, Y+27	; 0x1b
     eba:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	30 e0       	ldi	r19, 0x00	; 0
     ec0:	82 9f       	mul	r24, r18
     ec2:	a0 01       	movw	r20, r0
     ec4:	83 9f       	mul	r24, r19
     ec6:	50 0d       	add	r21, r0
     ec8:	92 9f       	mul	r25, r18
     eca:	50 0d       	add	r21, r0
     ecc:	11 24       	eor	r1, r1
     ece:	4e 0f       	add	r20, r30
     ed0:	5f 1f       	adc	r21, r31
     ed2:	5d 83       	std	Y+5, r21	; 0x05
     ed4:	4c 83       	std	Y+4, r20	; 0x04
     ed6:	1a 8e       	std	Y+26, r1	; 0x1a
     ed8:	fb 83       	std	Y+3, r31	; 0x03
     eda:	ea 83       	std	Y+2, r30	; 0x02
     edc:	01 97       	sbiw	r24, 0x01	; 1
     ede:	82 9f       	mul	r24, r18
     ee0:	a0 01       	movw	r20, r0
     ee2:	83 9f       	mul	r24, r19
     ee4:	50 0d       	add	r21, r0
     ee6:	92 9f       	mul	r25, r18
     ee8:	50 0d       	add	r21, r0
     eea:	11 24       	eor	r1, r1
     eec:	cf 01       	movw	r24, r30
     eee:	84 0f       	add	r24, r20
     ef0:	95 1f       	adc	r25, r21
     ef2:	9f 83       	std	Y+7, r25	; 0x07
     ef4:	8e 83       	std	Y+6, r24	; 0x06
     ef6:	8f ef       	ldi	r24, 0xFF	; 255
     ef8:	8d 8f       	std	Y+29, r24	; 0x1d
     efa:	8e 8f       	std	Y+30, r24	; 0x1e
     efc:	61 11       	cpse	r22, r1
     efe:	08 c0       	rjmp	.+16     	; 0xf10 <xQueueGenericReset+0x68>
     f00:	88 85       	ldd	r24, Y+8	; 0x08
     f02:	88 23       	and	r24, r24
     f04:	69 f0       	breq	.+26     	; 0xf20 <xQueueGenericReset+0x78>
     f06:	ce 01       	movw	r24, r28
     f08:	08 96       	adiw	r24, 0x08	; 8
     f0a:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <xTaskRemoveFromEventList>
     f0e:	08 c0       	rjmp	.+16     	; 0xf20 <xQueueGenericReset+0x78>
     f10:	ce 01       	movw	r24, r28
     f12:	08 96       	adiw	r24, 0x08	; 8
     f14:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vListInitialise>
     f18:	ce 01       	movw	r24, r28
     f1a:	41 96       	adiw	r24, 0x11	; 17
     f1c:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vListInitialise>
     f20:	0f 90       	pop	r0
     f22:	0f be       	out	0x3f, r0	; 63
     f24:	81 e0       	ldi	r24, 0x01	; 1
     f26:	df 91       	pop	r29
     f28:	cf 91       	pop	r28
     f2a:	08 95       	ret

00000f2c <xQueueGenericCreate>:
     f2c:	0f 93       	push	r16
     f2e:	1f 93       	push	r17
     f30:	cf 93       	push	r28
     f32:	df 93       	push	r29
     f34:	08 2f       	mov	r16, r24
     f36:	16 2f       	mov	r17, r22
     f38:	66 23       	and	r22, r22
     f3a:	c1 f0       	breq	.+48     	; 0xf6c <xQueueGenericCreate+0x40>
     f3c:	86 9f       	mul	r24, r22
     f3e:	c0 01       	movw	r24, r0
     f40:	11 24       	eor	r1, r1
     f42:	4f 96       	adiw	r24, 0x1f	; 31
     f44:	0e 94 7d 06 	call	0xcfa	; 0xcfa <pvPortMalloc>
     f48:	ec 01       	movw	r28, r24
     f4a:	00 97       	sbiw	r24, 0x00	; 0
     f4c:	41 f4       	brne	.+16     	; 0xf5e <xQueueGenericCreate+0x32>
     f4e:	15 c0       	rjmp	.+42     	; 0xf7a <xQueueGenericCreate+0x4e>
     f50:	0b 8f       	std	Y+27, r16	; 0x1b
     f52:	1c 8f       	std	Y+28, r17	; 0x1c
     f54:	61 e0       	ldi	r22, 0x01	; 1
     f56:	ce 01       	movw	r24, r28
     f58:	0e 94 54 07 	call	0xea8	; 0xea8 <xQueueGenericReset>
     f5c:	0e c0       	rjmp	.+28     	; 0xf7a <xQueueGenericCreate+0x4e>
     f5e:	4f 96       	adiw	r24, 0x1f	; 31
     f60:	99 83       	std	Y+1, r25	; 0x01
     f62:	88 83       	st	Y, r24
     f64:	f5 cf       	rjmp	.-22     	; 0xf50 <xQueueGenericCreate+0x24>
     f66:	d9 83       	std	Y+1, r29	; 0x01
     f68:	c8 83       	st	Y, r28
     f6a:	f2 cf       	rjmp	.-28     	; 0xf50 <xQueueGenericCreate+0x24>
     f6c:	8f e1       	ldi	r24, 0x1F	; 31
     f6e:	90 e0       	ldi	r25, 0x00	; 0
     f70:	0e 94 7d 06 	call	0xcfa	; 0xcfa <pvPortMalloc>
     f74:	ec 01       	movw	r28, r24
     f76:	89 2b       	or	r24, r25
     f78:	b1 f7       	brne	.-20     	; 0xf66 <xQueueGenericCreate+0x3a>
     f7a:	ce 01       	movw	r24, r28
     f7c:	df 91       	pop	r29
     f7e:	cf 91       	pop	r28
     f80:	1f 91       	pop	r17
     f82:	0f 91       	pop	r16
     f84:	08 95       	ret

00000f86 <xQueueCreateCountingSemaphore>:
     f86:	cf 93       	push	r28
     f88:	c6 2f       	mov	r28, r22
     f8a:	42 e0       	ldi	r20, 0x02	; 2
     f8c:	60 e0       	ldi	r22, 0x00	; 0
     f8e:	0e 94 96 07 	call	0xf2c	; 0xf2c <xQueueGenericCreate>
     f92:	00 97       	sbiw	r24, 0x00	; 0
     f94:	11 f0       	breq	.+4      	; 0xf9a <xQueueCreateCountingSemaphore+0x14>
     f96:	fc 01       	movw	r30, r24
     f98:	c2 8f       	std	Z+26, r28	; 0x1a
     f9a:	cf 91       	pop	r28
     f9c:	08 95       	ret

00000f9e <xQueueGenericSend>:
     f9e:	9f 92       	push	r9
     fa0:	af 92       	push	r10
     fa2:	bf 92       	push	r11
     fa4:	cf 92       	push	r12
     fa6:	df 92       	push	r13
     fa8:	ef 92       	push	r14
     faa:	ff 92       	push	r15
     fac:	0f 93       	push	r16
     fae:	1f 93       	push	r17
     fb0:	cf 93       	push	r28
     fb2:	df 93       	push	r29
     fb4:	00 d0       	rcall	.+0      	; 0xfb6 <xQueueGenericSend+0x18>
     fb6:	00 d0       	rcall	.+0      	; 0xfb8 <xQueueGenericSend+0x1a>
     fb8:	1f 92       	push	r1
     fba:	cd b7       	in	r28, 0x3d	; 61
     fbc:	de b7       	in	r29, 0x3e	; 62
     fbe:	8c 01       	movw	r16, r24
     fc0:	6b 01       	movw	r12, r22
     fc2:	5d 83       	std	Y+5, r21	; 0x05
     fc4:	4c 83       	std	Y+4, r20	; 0x04
     fc6:	a2 2e       	mov	r10, r18
     fc8:	b1 2c       	mov	r11, r1
     fca:	99 24       	eor	r9, r9
     fcc:	93 94       	inc	r9
     fce:	7c 01       	movw	r14, r24
     fd0:	88 e0       	ldi	r24, 0x08	; 8
     fd2:	e8 0e       	add	r14, r24
     fd4:	f1 1c       	adc	r15, r1
     fd6:	0f b6       	in	r0, 0x3f	; 63
     fd8:	f8 94       	cli
     fda:	0f 92       	push	r0
     fdc:	f8 01       	movw	r30, r16
     fde:	92 8d       	ldd	r25, Z+26	; 0x1a
     fe0:	83 8d       	ldd	r24, Z+27	; 0x1b
     fe2:	98 17       	cp	r25, r24
     fe4:	18 f0       	brcs	.+6      	; 0xfec <xQueueGenericSend+0x4e>
     fe6:	f2 e0       	ldi	r31, 0x02	; 2
     fe8:	af 12       	cpse	r10, r31
     fea:	11 c0       	rjmp	.+34     	; 0x100e <xQueueGenericSend+0x70>
     fec:	4a 2d       	mov	r20, r10
     fee:	b6 01       	movw	r22, r12
     ff0:	c8 01       	movw	r24, r16
     ff2:	0e 94 be 06 	call	0xd7c	; 0xd7c <prvCopyDataToQueue>
     ff6:	f8 01       	movw	r30, r16
     ff8:	81 89       	ldd	r24, Z+17	; 0x11
     ffa:	88 23       	and	r24, r24
     ffc:	21 f0       	breq	.+8      	; 0x1006 <xQueueGenericSend+0x68>
     ffe:	c8 01       	movw	r24, r16
    1000:	41 96       	adiw	r24, 0x11	; 17
    1002:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <xTaskRemoveFromEventList>
    1006:	0f 90       	pop	r0
    1008:	0f be       	out	0x3f, r0	; 63
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	50 c0       	rjmp	.+160    	; 0x10ae <xQueueGenericSend+0x110>
    100e:	8c 81       	ldd	r24, Y+4	; 0x04
    1010:	9d 81       	ldd	r25, Y+5	; 0x05
    1012:	89 2b       	or	r24, r25
    1014:	21 f4       	brne	.+8      	; 0x101e <xQueueGenericSend+0x80>
    1016:	0f 90       	pop	r0
    1018:	0f be       	out	0x3f, r0	; 63
    101a:	80 e0       	ldi	r24, 0x00	; 0
    101c:	48 c0       	rjmp	.+144    	; 0x10ae <xQueueGenericSend+0x110>
    101e:	b1 10       	cpse	r11, r1
    1020:	05 c0       	rjmp	.+10     	; 0x102c <xQueueGenericSend+0x8e>
    1022:	ce 01       	movw	r24, r28
    1024:	01 96       	adiw	r24, 0x01	; 1
    1026:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vTaskInternalSetTimeOutState>
    102a:	b9 2c       	mov	r11, r9
    102c:	0f 90       	pop	r0
    102e:	0f be       	out	0x3f, r0	; 63
    1030:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vTaskSuspendAll>
    1034:	0f b6       	in	r0, 0x3f	; 63
    1036:	f8 94       	cli
    1038:	0f 92       	push	r0
    103a:	f8 01       	movw	r30, r16
    103c:	85 8d       	ldd	r24, Z+29	; 0x1d
    103e:	8f 3f       	cpi	r24, 0xFF	; 255
    1040:	09 f4       	brne	.+2      	; 0x1044 <xQueueGenericSend+0xa6>
    1042:	15 8e       	std	Z+29, r1	; 0x1d
    1044:	f8 01       	movw	r30, r16
    1046:	86 8d       	ldd	r24, Z+30	; 0x1e
    1048:	8f 3f       	cpi	r24, 0xFF	; 255
    104a:	09 f4       	brne	.+2      	; 0x104e <xQueueGenericSend+0xb0>
    104c:	16 8e       	std	Z+30, r1	; 0x1e
    104e:	0f 90       	pop	r0
    1050:	0f be       	out	0x3f, r0	; 63
    1052:	be 01       	movw	r22, r28
    1054:	6c 5f       	subi	r22, 0xFC	; 252
    1056:	7f 4f       	sbci	r23, 0xFF	; 255
    1058:	ce 01       	movw	r24, r28
    105a:	01 96       	adiw	r24, 0x01	; 1
    105c:	0e 94 b2 0d 	call	0x1b64	; 0x1b64 <xTaskCheckForTimeOut>
    1060:	81 11       	cpse	r24, r1
    1062:	1f c0       	rjmp	.+62     	; 0x10a2 <xQueueGenericSend+0x104>
    1064:	0f b6       	in	r0, 0x3f	; 63
    1066:	f8 94       	cli
    1068:	0f 92       	push	r0
    106a:	f8 01       	movw	r30, r16
    106c:	92 8d       	ldd	r25, Z+26	; 0x1a
    106e:	0f 90       	pop	r0
    1070:	0f be       	out	0x3f, r0	; 63
    1072:	83 8d       	ldd	r24, Z+27	; 0x1b
    1074:	98 13       	cpse	r25, r24
    1076:	0f c0       	rjmp	.+30     	; 0x1096 <xQueueGenericSend+0xf8>
    1078:	6c 81       	ldd	r22, Y+4	; 0x04
    107a:	7d 81       	ldd	r23, Y+5	; 0x05
    107c:	c7 01       	movw	r24, r14
    107e:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <vTaskPlaceOnEventList>
    1082:	c8 01       	movw	r24, r16
    1084:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
    1088:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskResumeAll>
    108c:	81 11       	cpse	r24, r1
    108e:	a3 cf       	rjmp	.-186    	; 0xfd6 <xQueueGenericSend+0x38>
    1090:	0e 94 00 06 	call	0xc00	; 0xc00 <vPortYield>
    1094:	a0 cf       	rjmp	.-192    	; 0xfd6 <xQueueGenericSend+0x38>
    1096:	c8 01       	movw	r24, r16
    1098:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
    109c:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskResumeAll>
    10a0:	9a cf       	rjmp	.-204    	; 0xfd6 <xQueueGenericSend+0x38>
    10a2:	c8 01       	movw	r24, r16
    10a4:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
    10a8:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskResumeAll>
    10ac:	80 e0       	ldi	r24, 0x00	; 0
    10ae:	0f 90       	pop	r0
    10b0:	0f 90       	pop	r0
    10b2:	0f 90       	pop	r0
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	1f 91       	pop	r17
    10be:	0f 91       	pop	r16
    10c0:	ff 90       	pop	r15
    10c2:	ef 90       	pop	r14
    10c4:	df 90       	pop	r13
    10c6:	cf 90       	pop	r12
    10c8:	bf 90       	pop	r11
    10ca:	af 90       	pop	r10
    10cc:	9f 90       	pop	r9
    10ce:	08 95       	ret

000010d0 <xQueueSemaphoreTake>:
    10d0:	cf 92       	push	r12
    10d2:	df 92       	push	r13
    10d4:	ef 92       	push	r14
    10d6:	ff 92       	push	r15
    10d8:	0f 93       	push	r16
    10da:	1f 93       	push	r17
    10dc:	cf 93       	push	r28
    10de:	df 93       	push	r29
    10e0:	00 d0       	rcall	.+0      	; 0x10e2 <xQueueSemaphoreTake+0x12>
    10e2:	00 d0       	rcall	.+0      	; 0x10e4 <xQueueSemaphoreTake+0x14>
    10e4:	1f 92       	push	r1
    10e6:	cd b7       	in	r28, 0x3d	; 61
    10e8:	de b7       	in	r29, 0x3e	; 62
    10ea:	8c 01       	movw	r16, r24
    10ec:	7d 83       	std	Y+5, r23	; 0x05
    10ee:	6c 83       	std	Y+4, r22	; 0x04
    10f0:	d1 2c       	mov	r13, r1
    10f2:	cc 24       	eor	r12, r12
    10f4:	c3 94       	inc	r12
    10f6:	7c 01       	movw	r14, r24
    10f8:	81 e1       	ldi	r24, 0x11	; 17
    10fa:	e8 0e       	add	r14, r24
    10fc:	f1 1c       	adc	r15, r1
    10fe:	0f b6       	in	r0, 0x3f	; 63
    1100:	f8 94       	cli
    1102:	0f 92       	push	r0
    1104:	f8 01       	movw	r30, r16
    1106:	82 8d       	ldd	r24, Z+26	; 0x1a
    1108:	88 23       	and	r24, r24
    110a:	69 f0       	breq	.+26     	; 0x1126 <xQueueSemaphoreTake+0x56>
    110c:	81 50       	subi	r24, 0x01	; 1
    110e:	82 8f       	std	Z+26, r24	; 0x1a
    1110:	80 85       	ldd	r24, Z+8	; 0x08
    1112:	88 23       	and	r24, r24
    1114:	21 f0       	breq	.+8      	; 0x111e <xQueueSemaphoreTake+0x4e>
    1116:	c8 01       	movw	r24, r16
    1118:	08 96       	adiw	r24, 0x08	; 8
    111a:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <xTaskRemoveFromEventList>
    111e:	0f 90       	pop	r0
    1120:	0f be       	out	0x3f, r0	; 63
    1122:	81 e0       	ldi	r24, 0x01	; 1
    1124:	51 c0       	rjmp	.+162    	; 0x11c8 <xQueueSemaphoreTake+0xf8>
    1126:	8c 81       	ldd	r24, Y+4	; 0x04
    1128:	9d 81       	ldd	r25, Y+5	; 0x05
    112a:	89 2b       	or	r24, r25
    112c:	21 f4       	brne	.+8      	; 0x1136 <xQueueSemaphoreTake+0x66>
    112e:	0f 90       	pop	r0
    1130:	0f be       	out	0x3f, r0	; 63
    1132:	80 e0       	ldi	r24, 0x00	; 0
    1134:	49 c0       	rjmp	.+146    	; 0x11c8 <xQueueSemaphoreTake+0xf8>
    1136:	d1 10       	cpse	r13, r1
    1138:	05 c0       	rjmp	.+10     	; 0x1144 <xQueueSemaphoreTake+0x74>
    113a:	ce 01       	movw	r24, r28
    113c:	01 96       	adiw	r24, 0x01	; 1
    113e:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vTaskInternalSetTimeOutState>
    1142:	dc 2c       	mov	r13, r12
    1144:	0f 90       	pop	r0
    1146:	0f be       	out	0x3f, r0	; 63
    1148:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vTaskSuspendAll>
    114c:	0f b6       	in	r0, 0x3f	; 63
    114e:	f8 94       	cli
    1150:	0f 92       	push	r0
    1152:	f8 01       	movw	r30, r16
    1154:	85 8d       	ldd	r24, Z+29	; 0x1d
    1156:	8f 3f       	cpi	r24, 0xFF	; 255
    1158:	09 f4       	brne	.+2      	; 0x115c <xQueueSemaphoreTake+0x8c>
    115a:	15 8e       	std	Z+29, r1	; 0x1d
    115c:	f8 01       	movw	r30, r16
    115e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1160:	8f 3f       	cpi	r24, 0xFF	; 255
    1162:	09 f4       	brne	.+2      	; 0x1166 <xQueueSemaphoreTake+0x96>
    1164:	16 8e       	std	Z+30, r1	; 0x1e
    1166:	0f 90       	pop	r0
    1168:	0f be       	out	0x3f, r0	; 63
    116a:	be 01       	movw	r22, r28
    116c:	6c 5f       	subi	r22, 0xFC	; 252
    116e:	7f 4f       	sbci	r23, 0xFF	; 255
    1170:	ce 01       	movw	r24, r28
    1172:	01 96       	adiw	r24, 0x01	; 1
    1174:	0e 94 b2 0d 	call	0x1b64	; 0x1b64 <xTaskCheckForTimeOut>
    1178:	81 11       	cpse	r24, r1
    117a:	1a c0       	rjmp	.+52     	; 0x11b0 <xQueueSemaphoreTake+0xe0>
    117c:	c8 01       	movw	r24, r16
    117e:	0e 94 b3 06 	call	0xd66	; 0xd66 <prvIsQueueEmpty>
    1182:	88 23       	and	r24, r24
    1184:	79 f0       	breq	.+30     	; 0x11a4 <xQueueSemaphoreTake+0xd4>
    1186:	6c 81       	ldd	r22, Y+4	; 0x04
    1188:	7d 81       	ldd	r23, Y+5	; 0x05
    118a:	c7 01       	movw	r24, r14
    118c:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <vTaskPlaceOnEventList>
    1190:	c8 01       	movw	r24, r16
    1192:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
    1196:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskResumeAll>
    119a:	81 11       	cpse	r24, r1
    119c:	b0 cf       	rjmp	.-160    	; 0x10fe <xQueueSemaphoreTake+0x2e>
    119e:	0e 94 00 06 	call	0xc00	; 0xc00 <vPortYield>
    11a2:	ad cf       	rjmp	.-166    	; 0x10fe <xQueueSemaphoreTake+0x2e>
    11a4:	c8 01       	movw	r24, r16
    11a6:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
    11aa:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskResumeAll>
    11ae:	a7 cf       	rjmp	.-178    	; 0x10fe <xQueueSemaphoreTake+0x2e>
    11b0:	c8 01       	movw	r24, r16
    11b2:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvUnlockQueue>
    11b6:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskResumeAll>
    11ba:	c8 01       	movw	r24, r16
    11bc:	0e 94 b3 06 	call	0xd66	; 0xd66 <prvIsQueueEmpty>
    11c0:	88 23       	and	r24, r24
    11c2:	09 f4       	brne	.+2      	; 0x11c6 <xQueueSemaphoreTake+0xf6>
    11c4:	9c cf       	rjmp	.-200    	; 0x10fe <xQueueSemaphoreTake+0x2e>
    11c6:	80 e0       	ldi	r24, 0x00	; 0
    11c8:	0f 90       	pop	r0
    11ca:	0f 90       	pop	r0
    11cc:	0f 90       	pop	r0
    11ce:	0f 90       	pop	r0
    11d0:	0f 90       	pop	r0
    11d2:	df 91       	pop	r29
    11d4:	cf 91       	pop	r28
    11d6:	1f 91       	pop	r17
    11d8:	0f 91       	pop	r16
    11da:	ff 90       	pop	r15
    11dc:	ef 90       	pop	r14
    11de:	df 90       	pop	r13
    11e0:	cf 90       	pop	r12
    11e2:	08 95       	ret

000011e4 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    11e4:	0f b6       	in	r0, 0x3f	; 63
    11e6:	f8 94       	cli
    11e8:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    11ea:	fc 01       	movw	r30, r24
    11ec:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    11ee:	0f 90       	pop	r0
    11f0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    11f2:	08 95       	ret

000011f4 <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    11f4:	e0 91 ac 06 	lds	r30, 0x06AC	; 0x8006ac <pxDelayedTaskList>
    11f8:	f0 91 ad 06 	lds	r31, 0x06AD	; 0x8006ad <pxDelayedTaskList+0x1>
    11fc:	80 81       	ld	r24, Z
    11fe:	81 11       	cpse	r24, r1
    1200:	07 c0       	rjmp	.+14     	; 0x1210 <prvResetNextTaskUnblockTime+0x1c>
    1202:	8f ef       	ldi	r24, 0xFF	; 255
    1204:	9f ef       	ldi	r25, 0xFF	; 255
    1206:	90 93 84 06 	sts	0x0684, r25	; 0x800684 <xNextTaskUnblockTime+0x1>
    120a:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <xNextTaskUnblockTime>
    120e:	08 95       	ret
    1210:	e0 91 ac 06 	lds	r30, 0x06AC	; 0x8006ac <pxDelayedTaskList>
    1214:	f0 91 ad 06 	lds	r31, 0x06AD	; 0x8006ad <pxDelayedTaskList+0x1>
    1218:	05 80       	ldd	r0, Z+5	; 0x05
    121a:	f6 81       	ldd	r31, Z+6	; 0x06
    121c:	e0 2d       	mov	r30, r0
    121e:	06 80       	ldd	r0, Z+6	; 0x06
    1220:	f7 81       	ldd	r31, Z+7	; 0x07
    1222:	e0 2d       	mov	r30, r0
    1224:	82 81       	ldd	r24, Z+2	; 0x02
    1226:	93 81       	ldd	r25, Z+3	; 0x03
    1228:	90 93 84 06 	sts	0x0684, r25	; 0x800684 <xNextTaskUnblockTime+0x1>
    122c:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <xNextTaskUnblockTime>
    1230:	08 95       	ret

00001232 <prvIdleTask>:
    1232:	08 e9       	ldi	r16, 0x98	; 152
    1234:	16 e0       	ldi	r17, 0x06	; 6
    1236:	80 91 97 06 	lds	r24, 0x0697	; 0x800697 <uxDeletedTasksWaitingCleanUp>
    123a:	88 23       	and	r24, r24
    123c:	29 f1       	breq	.+74     	; 0x1288 <prvIdleTask+0x56>
    123e:	0f b6       	in	r0, 0x3f	; 63
    1240:	f8 94       	cli
    1242:	0f 92       	push	r0
    1244:	d8 01       	movw	r26, r16
    1246:	15 96       	adiw	r26, 0x05	; 5
    1248:	ed 91       	ld	r30, X+
    124a:	fc 91       	ld	r31, X
    124c:	16 97       	sbiw	r26, 0x06	; 6
    124e:	c6 81       	ldd	r28, Z+6	; 0x06
    1250:	d7 81       	ldd	r29, Z+7	; 0x07
    1252:	ce 01       	movw	r24, r28
    1254:	02 96       	adiw	r24, 0x02	; 2
    1256:	0e 94 38 05 	call	0xa70	; 0xa70 <uxListRemove>
    125a:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <uxCurrentNumberOfTasks>
    125e:	81 50       	subi	r24, 0x01	; 1
    1260:	80 93 8d 06 	sts	0x068D, r24	; 0x80068d <uxCurrentNumberOfTasks>
    1264:	80 91 97 06 	lds	r24, 0x0697	; 0x800697 <uxDeletedTasksWaitingCleanUp>
    1268:	81 50       	subi	r24, 0x01	; 1
    126a:	80 93 97 06 	sts	0x0697, r24	; 0x800697 <uxDeletedTasksWaitingCleanUp>
    126e:	0f 90       	pop	r0
    1270:	0f be       	out	0x3f, r0	; 63
    1272:	8f 89       	ldd	r24, Y+23	; 0x17
    1274:	98 8d       	ldd	r25, Y+24	; 0x18
    1276:	0e 94 b2 06 	call	0xd64	; 0xd64 <vPortFree>
    127a:	ce 01       	movw	r24, r28
    127c:	0e 94 b2 06 	call	0xd64	; 0xd64 <vPortFree>
    1280:	80 91 97 06 	lds	r24, 0x0697	; 0x800697 <uxDeletedTasksWaitingCleanUp>
    1284:	81 11       	cpse	r24, r1
    1286:	db cf       	rjmp	.-74     	; 0x123e <prvIdleTask+0xc>
    1288:	0e 94 00 06 	call	0xc00	; 0xc00 <vPortYield>
    128c:	d4 cf       	rjmp	.-88     	; 0x1236 <prvIdleTask+0x4>

0000128e <prvAddCurrentTaskToDelayedList>:
    128e:	ff 92       	push	r15
    1290:	0f 93       	push	r16
    1292:	1f 93       	push	r17
    1294:	cf 93       	push	r28
    1296:	df 93       	push	r29
    1298:	ec 01       	movw	r28, r24
    129a:	f6 2e       	mov	r15, r22
    129c:	00 91 8b 06 	lds	r16, 0x068B	; 0x80068b <xTickCount>
    12a0:	10 91 8c 06 	lds	r17, 0x068C	; 0x80068c <xTickCount+0x1>
    12a4:	80 91 ed 06 	lds	r24, 0x06ED	; 0x8006ed <pxCurrentTCB>
    12a8:	90 91 ee 06 	lds	r25, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    12ac:	02 96       	adiw	r24, 0x02	; 2
    12ae:	0e 94 38 05 	call	0xa70	; 0xa70 <uxListRemove>
    12b2:	cf 3f       	cpi	r28, 0xFF	; 255
    12b4:	8f ef       	ldi	r24, 0xFF	; 255
    12b6:	d8 07       	cpc	r29, r24
    12b8:	69 f4       	brne	.+26     	; 0x12d4 <prvAddCurrentTaskToDelayedList+0x46>
    12ba:	ff 20       	and	r15, r15
    12bc:	59 f0       	breq	.+22     	; 0x12d4 <prvAddCurrentTaskToDelayedList+0x46>
    12be:	60 91 ed 06 	lds	r22, 0x06ED	; 0x8006ed <pxCurrentTCB>
    12c2:	70 91 ee 06 	lds	r23, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    12c6:	6e 5f       	subi	r22, 0xFE	; 254
    12c8:	7f 4f       	sbci	r23, 0xFF	; 255
    12ca:	8e e8       	ldi	r24, 0x8E	; 142
    12cc:	96 e0       	ldi	r25, 0x06	; 6
    12ce:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
    12d2:	2f c0       	rjmp	.+94     	; 0x1332 <prvAddCurrentTaskToDelayedList+0xa4>
    12d4:	c0 0f       	add	r28, r16
    12d6:	d1 1f       	adc	r29, r17
    12d8:	e0 91 ed 06 	lds	r30, 0x06ED	; 0x8006ed <pxCurrentTCB>
    12dc:	f0 91 ee 06 	lds	r31, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    12e0:	d3 83       	std	Z+3, r29	; 0x03
    12e2:	c2 83       	std	Z+2, r28	; 0x02
    12e4:	c0 17       	cp	r28, r16
    12e6:	d1 07       	cpc	r29, r17
    12e8:	68 f4       	brcc	.+26     	; 0x1304 <prvAddCurrentTaskToDelayedList+0x76>
    12ea:	60 91 ed 06 	lds	r22, 0x06ED	; 0x8006ed <pxCurrentTCB>
    12ee:	70 91 ee 06 	lds	r23, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    12f2:	80 91 aa 06 	lds	r24, 0x06AA	; 0x8006aa <pxOverflowDelayedTaskList>
    12f6:	90 91 ab 06 	lds	r25, 0x06AB	; 0x8006ab <pxOverflowDelayedTaskList+0x1>
    12fa:	6e 5f       	subi	r22, 0xFE	; 254
    12fc:	7f 4f       	sbci	r23, 0xFF	; 255
    12fe:	0e 94 07 05 	call	0xa0e	; 0xa0e <vListInsert>
    1302:	17 c0       	rjmp	.+46     	; 0x1332 <prvAddCurrentTaskToDelayedList+0xa4>
    1304:	60 91 ed 06 	lds	r22, 0x06ED	; 0x8006ed <pxCurrentTCB>
    1308:	70 91 ee 06 	lds	r23, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    130c:	80 91 ac 06 	lds	r24, 0x06AC	; 0x8006ac <pxDelayedTaskList>
    1310:	90 91 ad 06 	lds	r25, 0x06AD	; 0x8006ad <pxDelayedTaskList+0x1>
    1314:	6e 5f       	subi	r22, 0xFE	; 254
    1316:	7f 4f       	sbci	r23, 0xFF	; 255
    1318:	0e 94 07 05 	call	0xa0e	; 0xa0e <vListInsert>
    131c:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <xNextTaskUnblockTime>
    1320:	90 91 84 06 	lds	r25, 0x0684	; 0x800684 <xNextTaskUnblockTime+0x1>
    1324:	c8 17       	cp	r28, r24
    1326:	d9 07       	cpc	r29, r25
    1328:	20 f4       	brcc	.+8      	; 0x1332 <prvAddCurrentTaskToDelayedList+0xa4>
    132a:	d0 93 84 06 	sts	0x0684, r29	; 0x800684 <xNextTaskUnblockTime+0x1>
    132e:	c0 93 83 06 	sts	0x0683, r28	; 0x800683 <xNextTaskUnblockTime>
    1332:	df 91       	pop	r29
    1334:	cf 91       	pop	r28
    1336:	1f 91       	pop	r17
    1338:	0f 91       	pop	r16
    133a:	ff 90       	pop	r15
    133c:	08 95       	ret

0000133e <xTaskCreate>:
    133e:	4f 92       	push	r4
    1340:	5f 92       	push	r5
    1342:	6f 92       	push	r6
    1344:	7f 92       	push	r7
    1346:	8f 92       	push	r8
    1348:	9f 92       	push	r9
    134a:	af 92       	push	r10
    134c:	bf 92       	push	r11
    134e:	cf 92       	push	r12
    1350:	df 92       	push	r13
    1352:	ef 92       	push	r14
    1354:	ff 92       	push	r15
    1356:	0f 93       	push	r16
    1358:	1f 93       	push	r17
    135a:	cf 93       	push	r28
    135c:	df 93       	push	r29
    135e:	4c 01       	movw	r8, r24
    1360:	6b 01       	movw	r12, r22
    1362:	5a 01       	movw	r10, r20
    1364:	29 01       	movw	r4, r18
    1366:	ca 01       	movw	r24, r20
    1368:	0e 94 7d 06 	call	0xcfa	; 0xcfa <pvPortMalloc>
    136c:	3c 01       	movw	r6, r24
    136e:	89 2b       	or	r24, r25
    1370:	09 f4       	brne	.+2      	; 0x1374 <xTaskCreate+0x36>
    1372:	df c0       	rjmp	.+446    	; 0x1532 <xTaskCreate+0x1f4>
    1374:	86 e2       	ldi	r24, 0x26	; 38
    1376:	90 e0       	ldi	r25, 0x00	; 0
    1378:	0e 94 7d 06 	call	0xcfa	; 0xcfa <pvPortMalloc>
    137c:	ec 01       	movw	r28, r24
    137e:	89 2b       	or	r24, r25
    1380:	59 f0       	breq	.+22     	; 0x1398 <xTaskCreate+0x5a>
    1382:	78 8e       	std	Y+24, r7	; 0x18
    1384:	6f 8a       	std	Y+23, r6	; 0x17
    1386:	81 e0       	ldi	r24, 0x01	; 1
    1388:	a8 1a       	sub	r10, r24
    138a:	b1 08       	sbc	r11, r1
    138c:	a6 0c       	add	r10, r6
    138e:	b7 1c       	adc	r11, r7
    1390:	c1 14       	cp	r12, r1
    1392:	d1 04       	cpc	r13, r1
    1394:	29 f4       	brne	.+10     	; 0x13a0 <xTaskCreate+0x62>
    1396:	20 c0       	rjmp	.+64     	; 0x13d8 <xTaskCreate+0x9a>
    1398:	c3 01       	movw	r24, r6
    139a:	0e 94 b2 06 	call	0xd64	; 0xd64 <vPortFree>
    139e:	c9 c0       	rjmp	.+402    	; 0x1532 <xTaskCreate+0x1f4>
    13a0:	d6 01       	movw	r26, r12
    13a2:	8c 91       	ld	r24, X
    13a4:	89 8f       	std	Y+25, r24	; 0x19
    13a6:	8c 91       	ld	r24, X
    13a8:	88 23       	and	r24, r24
    13aa:	a1 f0       	breq	.+40     	; 0x13d4 <xTaskCreate+0x96>
    13ac:	ae 01       	movw	r20, r28
    13ae:	46 5e       	subi	r20, 0xE6	; 230
    13b0:	5f 4f       	sbci	r21, 0xFF	; 255
    13b2:	f6 01       	movw	r30, r12
    13b4:	31 96       	adiw	r30, 0x01	; 1
    13b6:	b8 e0       	ldi	r27, 0x08	; 8
    13b8:	cb 0e       	add	r12, r27
    13ba:	d1 1c       	adc	r13, r1
    13bc:	cf 01       	movw	r24, r30
    13be:	21 91       	ld	r18, Z+
    13c0:	da 01       	movw	r26, r20
    13c2:	2d 93       	st	X+, r18
    13c4:	ad 01       	movw	r20, r26
    13c6:	dc 01       	movw	r26, r24
    13c8:	8c 91       	ld	r24, X
    13ca:	88 23       	and	r24, r24
    13cc:	19 f0       	breq	.+6      	; 0x13d4 <xTaskCreate+0x96>
    13ce:	ce 16       	cp	r12, r30
    13d0:	df 06       	cpc	r13, r31
    13d2:	a1 f7       	brne	.-24     	; 0x13bc <xTaskCreate+0x7e>
    13d4:	18 a2       	std	Y+32, r1	; 0x20
    13d6:	01 c0       	rjmp	.+2      	; 0x13da <xTaskCreate+0x9c>
    13d8:	19 8e       	std	Y+25, r1	; 0x19
    13da:	05 30       	cpi	r16, 0x05	; 5
    13dc:	08 f0       	brcs	.+2      	; 0x13e0 <xTaskCreate+0xa2>
    13de:	04 e0       	ldi	r16, 0x04	; 4
    13e0:	0e 8b       	std	Y+22, r16	; 0x16
    13e2:	6e 01       	movw	r12, r28
    13e4:	b2 e0       	ldi	r27, 0x02	; 2
    13e6:	cb 0e       	add	r12, r27
    13e8:	d1 1c       	adc	r13, r1
    13ea:	c6 01       	movw	r24, r12
    13ec:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vListInitialiseItem>
    13f0:	ce 01       	movw	r24, r28
    13f2:	0c 96       	adiw	r24, 0x0c	; 12
    13f4:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vListInitialiseItem>
    13f8:	d9 87       	std	Y+9, r29	; 0x09
    13fa:	c8 87       	std	Y+8, r28	; 0x08
    13fc:	85 e0       	ldi	r24, 0x05	; 5
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	80 1b       	sub	r24, r16
    1402:	91 09       	sbc	r25, r1
    1404:	9d 87       	std	Y+13, r25	; 0x0d
    1406:	8c 87       	std	Y+12, r24	; 0x0c
    1408:	db 8b       	std	Y+19, r29	; 0x13
    140a:	ca 8b       	std	Y+18, r28	; 0x12
    140c:	19 a2       	std	Y+33, r1	; 0x21
    140e:	1a a2       	std	Y+34, r1	; 0x22
    1410:	1b a2       	std	Y+35, r1	; 0x23
    1412:	1c a2       	std	Y+36, r1	; 0x24
    1414:	1d a2       	std	Y+37, r1	; 0x25
    1416:	a2 01       	movw	r20, r4
    1418:	b4 01       	movw	r22, r8
    141a:	c5 01       	movw	r24, r10
    141c:	0e 94 5f 05 	call	0xabe	; 0xabe <pxPortInitialiseStack>
    1420:	99 83       	std	Y+1, r25	; 0x01
    1422:	88 83       	st	Y, r24
    1424:	e1 14       	cp	r14, r1
    1426:	f1 04       	cpc	r15, r1
    1428:	19 f0       	breq	.+6      	; 0x1430 <xTaskCreate+0xf2>
    142a:	f7 01       	movw	r30, r14
    142c:	d1 83       	std	Z+1, r29	; 0x01
    142e:	c0 83       	st	Z, r28
    1430:	0f b6       	in	r0, 0x3f	; 63
    1432:	f8 94       	cli
    1434:	0f 92       	push	r0
    1436:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <uxCurrentNumberOfTasks>
    143a:	8f 5f       	subi	r24, 0xFF	; 255
    143c:	80 93 8d 06 	sts	0x068D, r24	; 0x80068d <uxCurrentNumberOfTasks>
    1440:	80 91 ed 06 	lds	r24, 0x06ED	; 0x8006ed <pxCurrentTCB>
    1444:	90 91 ee 06 	lds	r25, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    1448:	89 2b       	or	r24, r25
    144a:	d1 f5       	brne	.+116    	; 0x14c0 <xTaskCreate+0x182>
    144c:	d0 93 ee 06 	sts	0x06EE, r29	; 0x8006ee <pxCurrentTCB+0x1>
    1450:	c0 93 ed 06 	sts	0x06ED, r28	; 0x8006ed <pxCurrentTCB>
    1454:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <uxCurrentNumberOfTasks>
    1458:	81 30       	cpi	r24, 0x01	; 1
    145a:	09 f0       	breq	.+2      	; 0x145e <xTaskCreate+0x120>
    145c:	41 c0       	rjmp	.+130    	; 0x14e0 <xTaskCreate+0x1a2>
    145e:	00 ec       	ldi	r16, 0xC0	; 192
    1460:	16 e0       	ldi	r17, 0x06	; 6
    1462:	0f 2e       	mov	r0, r31
    1464:	fd ee       	ldi	r31, 0xED	; 237
    1466:	ef 2e       	mov	r14, r31
    1468:	f6 e0       	ldi	r31, 0x06	; 6
    146a:	ff 2e       	mov	r15, r31
    146c:	f0 2d       	mov	r31, r0
    146e:	c8 01       	movw	r24, r16
    1470:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vListInitialise>
    1474:	07 5f       	subi	r16, 0xF7	; 247
    1476:	1f 4f       	sbci	r17, 0xFF	; 255
    1478:	0e 15       	cp	r16, r14
    147a:	1f 05       	cpc	r17, r15
    147c:	c1 f7       	brne	.-16     	; 0x146e <xTaskCreate+0x130>
    147e:	87 eb       	ldi	r24, 0xB7	; 183
    1480:	96 e0       	ldi	r25, 0x06	; 6
    1482:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vListInitialise>
    1486:	8e ea       	ldi	r24, 0xAE	; 174
    1488:	96 e0       	ldi	r25, 0x06	; 6
    148a:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vListInitialise>
    148e:	81 ea       	ldi	r24, 0xA1	; 161
    1490:	96 e0       	ldi	r25, 0x06	; 6
    1492:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vListInitialise>
    1496:	88 e9       	ldi	r24, 0x98	; 152
    1498:	96 e0       	ldi	r25, 0x06	; 6
    149a:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vListInitialise>
    149e:	8e e8       	ldi	r24, 0x8E	; 142
    14a0:	96 e0       	ldi	r25, 0x06	; 6
    14a2:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vListInitialise>
    14a6:	87 eb       	ldi	r24, 0xB7	; 183
    14a8:	96 e0       	ldi	r25, 0x06	; 6
    14aa:	90 93 ad 06 	sts	0x06AD, r25	; 0x8006ad <pxDelayedTaskList+0x1>
    14ae:	80 93 ac 06 	sts	0x06AC, r24	; 0x8006ac <pxDelayedTaskList>
    14b2:	8e ea       	ldi	r24, 0xAE	; 174
    14b4:	96 e0       	ldi	r25, 0x06	; 6
    14b6:	90 93 ab 06 	sts	0x06AB, r25	; 0x8006ab <pxOverflowDelayedTaskList+0x1>
    14ba:	80 93 aa 06 	sts	0x06AA, r24	; 0x8006aa <pxOverflowDelayedTaskList>
    14be:	10 c0       	rjmp	.+32     	; 0x14e0 <xTaskCreate+0x1a2>
    14c0:	80 91 89 06 	lds	r24, 0x0689	; 0x800689 <xSchedulerRunning>
    14c4:	81 11       	cpse	r24, r1
    14c6:	0c c0       	rjmp	.+24     	; 0x14e0 <xTaskCreate+0x1a2>
    14c8:	e0 91 ed 06 	lds	r30, 0x06ED	; 0x8006ed <pxCurrentTCB>
    14cc:	f0 91 ee 06 	lds	r31, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    14d0:	96 89       	ldd	r25, Z+22	; 0x16
    14d2:	8e 89       	ldd	r24, Y+22	; 0x16
    14d4:	89 17       	cp	r24, r25
    14d6:	20 f0       	brcs	.+8      	; 0x14e0 <xTaskCreate+0x1a2>
    14d8:	d0 93 ee 06 	sts	0x06EE, r29	; 0x8006ee <pxCurrentTCB+0x1>
    14dc:	c0 93 ed 06 	sts	0x06ED, r28	; 0x8006ed <pxCurrentTCB>
    14e0:	80 91 85 06 	lds	r24, 0x0685	; 0x800685 <uxTaskNumber>
    14e4:	8f 5f       	subi	r24, 0xFF	; 255
    14e6:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <uxTaskNumber>
    14ea:	8e 89       	ldd	r24, Y+22	; 0x16
    14ec:	90 91 8a 06 	lds	r25, 0x068A	; 0x80068a <uxTopReadyPriority>
    14f0:	98 17       	cp	r25, r24
    14f2:	10 f4       	brcc	.+4      	; 0x14f8 <xTaskCreate+0x1ba>
    14f4:	80 93 8a 06 	sts	0x068A, r24	; 0x80068a <uxTopReadyPriority>
    14f8:	90 e0       	ldi	r25, 0x00	; 0
    14fa:	9c 01       	movw	r18, r24
    14fc:	22 0f       	add	r18, r18
    14fe:	33 1f       	adc	r19, r19
    1500:	22 0f       	add	r18, r18
    1502:	33 1f       	adc	r19, r19
    1504:	22 0f       	add	r18, r18
    1506:	33 1f       	adc	r19, r19
    1508:	82 0f       	add	r24, r18
    150a:	93 1f       	adc	r25, r19
    150c:	b6 01       	movw	r22, r12
    150e:	80 54       	subi	r24, 0x40	; 64
    1510:	99 4f       	sbci	r25, 0xF9	; 249
    1512:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
    1516:	0f 90       	pop	r0
    1518:	0f be       	out	0x3f, r0	; 63
    151a:	80 91 89 06 	lds	r24, 0x0689	; 0x800689 <xSchedulerRunning>
    151e:	88 23       	and	r24, r24
    1520:	31 f0       	breq	.+12     	; 0x152e <xTaskCreate+0x1f0>
    1522:	80 91 ed 06 	lds	r24, 0x06ED	; 0x8006ed <pxCurrentTCB>
    1526:	90 91 ee 06 	lds	r25, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    152a:	81 e0       	ldi	r24, 0x01	; 1
    152c:	03 c0       	rjmp	.+6      	; 0x1534 <xTaskCreate+0x1f6>
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	01 c0       	rjmp	.+2      	; 0x1534 <xTaskCreate+0x1f6>
    1532:	8f ef       	ldi	r24, 0xFF	; 255
    1534:	df 91       	pop	r29
    1536:	cf 91       	pop	r28
    1538:	1f 91       	pop	r17
    153a:	0f 91       	pop	r16
    153c:	ff 90       	pop	r15
    153e:	ef 90       	pop	r14
    1540:	df 90       	pop	r13
    1542:	cf 90       	pop	r12
    1544:	bf 90       	pop	r11
    1546:	af 90       	pop	r10
    1548:	9f 90       	pop	r9
    154a:	8f 90       	pop	r8
    154c:	7f 90       	pop	r7
    154e:	6f 90       	pop	r6
    1550:	5f 90       	pop	r5
    1552:	4f 90       	pop	r4
    1554:	08 95       	ret

00001556 <vTaskResume>:
    1556:	0f 93       	push	r16
    1558:	1f 93       	push	r17
    155a:	cf 93       	push	r28
    155c:	df 93       	push	r29
    155e:	20 91 ed 06 	lds	r18, 0x06ED	; 0x8006ed <pxCurrentTCB>
    1562:	30 91 ee 06 	lds	r19, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    1566:	82 17       	cp	r24, r18
    1568:	93 07       	cpc	r25, r19
    156a:	b9 f1       	breq	.+110    	; 0x15da <vTaskResume+0x84>
    156c:	00 97       	sbiw	r24, 0x00	; 0
    156e:	a9 f1       	breq	.+106    	; 0x15da <vTaskResume+0x84>
    1570:	0f b6       	in	r0, 0x3f	; 63
    1572:	f8 94       	cli
    1574:	0f 92       	push	r0
    1576:	fc 01       	movw	r30, r24
    1578:	22 85       	ldd	r18, Z+10	; 0x0a
    157a:	33 85       	ldd	r19, Z+11	; 0x0b
    157c:	2e 58       	subi	r18, 0x8E	; 142
    157e:	36 40       	sbci	r19, 0x06	; 6
    1580:	51 f5       	brne	.+84     	; 0x15d6 <vTaskResume+0x80>
    1582:	fc 01       	movw	r30, r24
    1584:	24 89       	ldd	r18, Z+20	; 0x14
    1586:	35 89       	ldd	r19, Z+21	; 0x15
    1588:	f6 e0       	ldi	r31, 0x06	; 6
    158a:	21 3a       	cpi	r18, 0xA1	; 161
    158c:	3f 07       	cpc	r19, r31
    158e:	19 f1       	breq	.+70     	; 0x15d6 <vTaskResume+0x80>
    1590:	23 2b       	or	r18, r19
    1592:	09 f5       	brne	.+66     	; 0x15d6 <vTaskResume+0x80>
    1594:	ec 01       	movw	r28, r24
    1596:	8c 01       	movw	r16, r24
    1598:	0e 5f       	subi	r16, 0xFE	; 254
    159a:	1f 4f       	sbci	r17, 0xFF	; 255
    159c:	c8 01       	movw	r24, r16
    159e:	0e 94 38 05 	call	0xa70	; 0xa70 <uxListRemove>
    15a2:	8e 89       	ldd	r24, Y+22	; 0x16
    15a4:	90 91 8a 06 	lds	r25, 0x068A	; 0x80068a <uxTopReadyPriority>
    15a8:	98 17       	cp	r25, r24
    15aa:	10 f4       	brcc	.+4      	; 0x15b0 <vTaskResume+0x5a>
    15ac:	80 93 8a 06 	sts	0x068A, r24	; 0x80068a <uxTopReadyPriority>
    15b0:	90 e0       	ldi	r25, 0x00	; 0
    15b2:	9c 01       	movw	r18, r24
    15b4:	22 0f       	add	r18, r18
    15b6:	33 1f       	adc	r19, r19
    15b8:	22 0f       	add	r18, r18
    15ba:	33 1f       	adc	r19, r19
    15bc:	22 0f       	add	r18, r18
    15be:	33 1f       	adc	r19, r19
    15c0:	82 0f       	add	r24, r18
    15c2:	93 1f       	adc	r25, r19
    15c4:	b8 01       	movw	r22, r16
    15c6:	80 54       	subi	r24, 0x40	; 64
    15c8:	99 4f       	sbci	r25, 0xF9	; 249
    15ca:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
    15ce:	80 91 ed 06 	lds	r24, 0x06ED	; 0x8006ed <pxCurrentTCB>
    15d2:	90 91 ee 06 	lds	r25, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    15d6:	0f 90       	pop	r0
    15d8:	0f be       	out	0x3f, r0	; 63
    15da:	df 91       	pop	r29
    15dc:	cf 91       	pop	r28
    15de:	1f 91       	pop	r17
    15e0:	0f 91       	pop	r16
    15e2:	08 95       	ret

000015e4 <vTaskStartScheduler>:
    15e4:	ef 92       	push	r14
    15e6:	ff 92       	push	r15
    15e8:	0f 93       	push	r16
    15ea:	0f 2e       	mov	r0, r31
    15ec:	f1 e8       	ldi	r31, 0x81	; 129
    15ee:	ef 2e       	mov	r14, r31
    15f0:	f6 e0       	ldi	r31, 0x06	; 6
    15f2:	ff 2e       	mov	r15, r31
    15f4:	f0 2d       	mov	r31, r0
    15f6:	00 e0       	ldi	r16, 0x00	; 0
    15f8:	20 e0       	ldi	r18, 0x00	; 0
    15fa:	30 e0       	ldi	r19, 0x00	; 0
    15fc:	45 e5       	ldi	r20, 0x55	; 85
    15fe:	50 e0       	ldi	r21, 0x00	; 0
    1600:	60 e9       	ldi	r22, 0x90	; 144
    1602:	70 e0       	ldi	r23, 0x00	; 0
    1604:	89 e1       	ldi	r24, 0x19	; 25
    1606:	99 e0       	ldi	r25, 0x09	; 9
    1608:	0e 94 9f 09 	call	0x133e	; 0x133e <xTaskCreate>
    160c:	81 30       	cpi	r24, 0x01	; 1
    160e:	81 f4       	brne	.+32     	; 0x1630 <vTaskStartScheduler+0x4c>
    1610:	f8 94       	cli
    1612:	8f ef       	ldi	r24, 0xFF	; 255
    1614:	9f ef       	ldi	r25, 0xFF	; 255
    1616:	90 93 84 06 	sts	0x0684, r25	; 0x800684 <xNextTaskUnblockTime+0x1>
    161a:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <xNextTaskUnblockTime>
    161e:	81 e0       	ldi	r24, 0x01	; 1
    1620:	80 93 89 06 	sts	0x0689, r24	; 0x800689 <xSchedulerRunning>
    1624:	10 92 8c 06 	sts	0x068C, r1	; 0x80068c <xTickCount+0x1>
    1628:	10 92 8b 06 	sts	0x068B, r1	; 0x80068b <xTickCount>
    162c:	0e 94 cb 05 	call	0xb96	; 0xb96 <xPortStartScheduler>
    1630:	0f 91       	pop	r16
    1632:	ff 90       	pop	r15
    1634:	ef 90       	pop	r14
    1636:	08 95       	ret

00001638 <vTaskSuspendAll>:
    1638:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <uxSchedulerSuspended>
    163c:	8f 5f       	subi	r24, 0xFF	; 255
    163e:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <uxSchedulerSuspended>
    1642:	08 95       	ret

00001644 <xTaskGetTickCount>:
    1644:	0f b6       	in	r0, 0x3f	; 63
    1646:	f8 94       	cli
    1648:	0f 92       	push	r0
    164a:	80 91 8b 06 	lds	r24, 0x068B	; 0x80068b <xTickCount>
    164e:	90 91 8c 06 	lds	r25, 0x068C	; 0x80068c <xTickCount+0x1>
    1652:	0f 90       	pop	r0
    1654:	0f be       	out	0x3f, r0	; 63
    1656:	08 95       	ret

00001658 <xTaskIncrementTick>:
    1658:	ef 92       	push	r14
    165a:	ff 92       	push	r15
    165c:	0f 93       	push	r16
    165e:	1f 93       	push	r17
    1660:	cf 93       	push	r28
    1662:	df 93       	push	r29
    1664:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <uxSchedulerSuspended>
    1668:	81 11       	cpse	r24, r1
    166a:	89 c0       	rjmp	.+274    	; 0x177e <xTaskIncrementTick+0x126>
    166c:	e0 90 8b 06 	lds	r14, 0x068B	; 0x80068b <xTickCount>
    1670:	f0 90 8c 06 	lds	r15, 0x068C	; 0x80068c <xTickCount+0x1>
    1674:	8f ef       	ldi	r24, 0xFF	; 255
    1676:	e8 1a       	sub	r14, r24
    1678:	f8 0a       	sbc	r15, r24
    167a:	f0 92 8c 06 	sts	0x068C, r15	; 0x80068c <xTickCount+0x1>
    167e:	e0 92 8b 06 	sts	0x068B, r14	; 0x80068b <xTickCount>
    1682:	e1 14       	cp	r14, r1
    1684:	f1 04       	cpc	r15, r1
    1686:	b9 f4       	brne	.+46     	; 0x16b6 <xTaskIncrementTick+0x5e>
    1688:	80 91 ac 06 	lds	r24, 0x06AC	; 0x8006ac <pxDelayedTaskList>
    168c:	90 91 ad 06 	lds	r25, 0x06AD	; 0x8006ad <pxDelayedTaskList+0x1>
    1690:	20 91 aa 06 	lds	r18, 0x06AA	; 0x8006aa <pxOverflowDelayedTaskList>
    1694:	30 91 ab 06 	lds	r19, 0x06AB	; 0x8006ab <pxOverflowDelayedTaskList+0x1>
    1698:	30 93 ad 06 	sts	0x06AD, r19	; 0x8006ad <pxDelayedTaskList+0x1>
    169c:	20 93 ac 06 	sts	0x06AC, r18	; 0x8006ac <pxDelayedTaskList>
    16a0:	90 93 ab 06 	sts	0x06AB, r25	; 0x8006ab <pxOverflowDelayedTaskList+0x1>
    16a4:	80 93 aa 06 	sts	0x06AA, r24	; 0x8006aa <pxOverflowDelayedTaskList>
    16a8:	80 91 86 06 	lds	r24, 0x0686	; 0x800686 <xNumOfOverflows>
    16ac:	8f 5f       	subi	r24, 0xFF	; 255
    16ae:	80 93 86 06 	sts	0x0686, r24	; 0x800686 <xNumOfOverflows>
    16b2:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <prvResetNextTaskUnblockTime>
    16b6:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <xNextTaskUnblockTime>
    16ba:	90 91 84 06 	lds	r25, 0x0684	; 0x800684 <xNextTaskUnblockTime+0x1>
    16be:	e8 16       	cp	r14, r24
    16c0:	f9 06       	cpc	r15, r25
    16c2:	08 f4       	brcc	.+2      	; 0x16c6 <xTaskIncrementTick+0x6e>
    16c4:	61 c0       	rjmp	.+194    	; 0x1788 <xTaskIncrementTick+0x130>
    16c6:	e0 91 ac 06 	lds	r30, 0x06AC	; 0x8006ac <pxDelayedTaskList>
    16ca:	f0 91 ad 06 	lds	r31, 0x06AD	; 0x8006ad <pxDelayedTaskList+0x1>
    16ce:	80 81       	ld	r24, Z
    16d0:	88 23       	and	r24, r24
    16d2:	79 f0       	breq	.+30     	; 0x16f2 <xTaskIncrementTick+0x9a>
    16d4:	e0 91 ac 06 	lds	r30, 0x06AC	; 0x8006ac <pxDelayedTaskList>
    16d8:	f0 91 ad 06 	lds	r31, 0x06AD	; 0x8006ad <pxDelayedTaskList+0x1>
    16dc:	05 80       	ldd	r0, Z+5	; 0x05
    16de:	f6 81       	ldd	r31, Z+6	; 0x06
    16e0:	e0 2d       	mov	r30, r0
    16e2:	c6 81       	ldd	r28, Z+6	; 0x06
    16e4:	d7 81       	ldd	r29, Z+7	; 0x07
    16e6:	8a 81       	ldd	r24, Y+2	; 0x02
    16e8:	9b 81       	ldd	r25, Y+3	; 0x03
    16ea:	e8 16       	cp	r14, r24
    16ec:	f9 06       	cpc	r15, r25
    16ee:	d8 f4       	brcc	.+54     	; 0x1726 <xTaskIncrementTick+0xce>
    16f0:	15 c0       	rjmp	.+42     	; 0x171c <xTaskIncrementTick+0xc4>
    16f2:	8f ef       	ldi	r24, 0xFF	; 255
    16f4:	9f ef       	ldi	r25, 0xFF	; 255
    16f6:	90 93 84 06 	sts	0x0684, r25	; 0x800684 <xNextTaskUnblockTime+0x1>
    16fa:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <xNextTaskUnblockTime>
    16fe:	44 c0       	rjmp	.+136    	; 0x1788 <xTaskIncrementTick+0x130>
    1700:	e0 91 ac 06 	lds	r30, 0x06AC	; 0x8006ac <pxDelayedTaskList>
    1704:	f0 91 ad 06 	lds	r31, 0x06AD	; 0x8006ad <pxDelayedTaskList+0x1>
    1708:	05 80       	ldd	r0, Z+5	; 0x05
    170a:	f6 81       	ldd	r31, Z+6	; 0x06
    170c:	e0 2d       	mov	r30, r0
    170e:	c6 81       	ldd	r28, Z+6	; 0x06
    1710:	d7 81       	ldd	r29, Z+7	; 0x07
    1712:	8a 81       	ldd	r24, Y+2	; 0x02
    1714:	9b 81       	ldd	r25, Y+3	; 0x03
    1716:	e8 16       	cp	r14, r24
    1718:	f9 06       	cpc	r15, r25
    171a:	28 f4       	brcc	.+10     	; 0x1726 <xTaskIncrementTick+0xce>
    171c:	90 93 84 06 	sts	0x0684, r25	; 0x800684 <xNextTaskUnblockTime+0x1>
    1720:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <xNextTaskUnblockTime>
    1724:	31 c0       	rjmp	.+98     	; 0x1788 <xTaskIncrementTick+0x130>
    1726:	8e 01       	movw	r16, r28
    1728:	0e 5f       	subi	r16, 0xFE	; 254
    172a:	1f 4f       	sbci	r17, 0xFF	; 255
    172c:	c8 01       	movw	r24, r16
    172e:	0e 94 38 05 	call	0xa70	; 0xa70 <uxListRemove>
    1732:	8c 89       	ldd	r24, Y+20	; 0x14
    1734:	9d 89       	ldd	r25, Y+21	; 0x15
    1736:	89 2b       	or	r24, r25
    1738:	21 f0       	breq	.+8      	; 0x1742 <xTaskIncrementTick+0xea>
    173a:	ce 01       	movw	r24, r28
    173c:	0c 96       	adiw	r24, 0x0c	; 12
    173e:	0e 94 38 05 	call	0xa70	; 0xa70 <uxListRemove>
    1742:	8e 89       	ldd	r24, Y+22	; 0x16
    1744:	90 91 8a 06 	lds	r25, 0x068A	; 0x80068a <uxTopReadyPriority>
    1748:	98 17       	cp	r25, r24
    174a:	10 f4       	brcc	.+4      	; 0x1750 <xTaskIncrementTick+0xf8>
    174c:	80 93 8a 06 	sts	0x068A, r24	; 0x80068a <uxTopReadyPriority>
    1750:	90 e0       	ldi	r25, 0x00	; 0
    1752:	9c 01       	movw	r18, r24
    1754:	22 0f       	add	r18, r18
    1756:	33 1f       	adc	r19, r19
    1758:	22 0f       	add	r18, r18
    175a:	33 1f       	adc	r19, r19
    175c:	22 0f       	add	r18, r18
    175e:	33 1f       	adc	r19, r19
    1760:	82 0f       	add	r24, r18
    1762:	93 1f       	adc	r25, r19
    1764:	b8 01       	movw	r22, r16
    1766:	80 54       	subi	r24, 0x40	; 64
    1768:	99 4f       	sbci	r25, 0xF9	; 249
    176a:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
    176e:	e0 91 ac 06 	lds	r30, 0x06AC	; 0x8006ac <pxDelayedTaskList>
    1772:	f0 91 ad 06 	lds	r31, 0x06AD	; 0x8006ad <pxDelayedTaskList+0x1>
    1776:	80 81       	ld	r24, Z
    1778:	81 11       	cpse	r24, r1
    177a:	c2 cf       	rjmp	.-124    	; 0x1700 <xTaskIncrementTick+0xa8>
    177c:	ba cf       	rjmp	.-140    	; 0x16f2 <xTaskIncrementTick+0x9a>
    177e:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <uxPendedTicks>
    1782:	8f 5f       	subi	r24, 0xFF	; 255
    1784:	80 93 88 06 	sts	0x0688, r24	; 0x800688 <uxPendedTicks>
    1788:	80 e0       	ldi	r24, 0x00	; 0
    178a:	df 91       	pop	r29
    178c:	cf 91       	pop	r28
    178e:	1f 91       	pop	r17
    1790:	0f 91       	pop	r16
    1792:	ff 90       	pop	r15
    1794:	ef 90       	pop	r14
    1796:	08 95       	ret

00001798 <xTaskResumeAll>:
    1798:	df 92       	push	r13
    179a:	ef 92       	push	r14
    179c:	ff 92       	push	r15
    179e:	0f 93       	push	r16
    17a0:	1f 93       	push	r17
    17a2:	cf 93       	push	r28
    17a4:	df 93       	push	r29
    17a6:	0f b6       	in	r0, 0x3f	; 63
    17a8:	f8 94       	cli
    17aa:	0f 92       	push	r0
    17ac:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <uxSchedulerSuspended>
    17b0:	81 50       	subi	r24, 0x01	; 1
    17b2:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <uxSchedulerSuspended>
    17b6:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <uxSchedulerSuspended>
    17ba:	81 11       	cpse	r24, r1
    17bc:	59 c0       	rjmp	.+178    	; 0x1870 <xTaskResumeAll+0xd8>
    17be:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <uxCurrentNumberOfTasks>
    17c2:	81 11       	cpse	r24, r1
    17c4:	33 c0       	rjmp	.+102    	; 0x182c <xTaskResumeAll+0x94>
    17c6:	54 c0       	rjmp	.+168    	; 0x1870 <xTaskResumeAll+0xd8>
    17c8:	d7 01       	movw	r26, r14
    17ca:	15 96       	adiw	r26, 0x05	; 5
    17cc:	ed 91       	ld	r30, X+
    17ce:	fc 91       	ld	r31, X
    17d0:	16 97       	sbiw	r26, 0x06	; 6
    17d2:	c6 81       	ldd	r28, Z+6	; 0x06
    17d4:	d7 81       	ldd	r29, Z+7	; 0x07
    17d6:	ce 01       	movw	r24, r28
    17d8:	0c 96       	adiw	r24, 0x0c	; 12
    17da:	0e 94 38 05 	call	0xa70	; 0xa70 <uxListRemove>
    17de:	8e 01       	movw	r16, r28
    17e0:	0e 5f       	subi	r16, 0xFE	; 254
    17e2:	1f 4f       	sbci	r17, 0xFF	; 255
    17e4:	c8 01       	movw	r24, r16
    17e6:	0e 94 38 05 	call	0xa70	; 0xa70 <uxListRemove>
    17ea:	8e 89       	ldd	r24, Y+22	; 0x16
    17ec:	90 91 8a 06 	lds	r25, 0x068A	; 0x80068a <uxTopReadyPriority>
    17f0:	98 17       	cp	r25, r24
    17f2:	10 f4       	brcc	.+4      	; 0x17f8 <xTaskResumeAll+0x60>
    17f4:	80 93 8a 06 	sts	0x068A, r24	; 0x80068a <uxTopReadyPriority>
    17f8:	90 e0       	ldi	r25, 0x00	; 0
    17fa:	9c 01       	movw	r18, r24
    17fc:	22 0f       	add	r18, r18
    17fe:	33 1f       	adc	r19, r19
    1800:	22 0f       	add	r18, r18
    1802:	33 1f       	adc	r19, r19
    1804:	22 0f       	add	r18, r18
    1806:	33 1f       	adc	r19, r19
    1808:	82 0f       	add	r24, r18
    180a:	93 1f       	adc	r25, r19
    180c:	b8 01       	movw	r22, r16
    180e:	80 54       	subi	r24, 0x40	; 64
    1810:	99 4f       	sbci	r25, 0xF9	; 249
    1812:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
    1816:	e0 91 ed 06 	lds	r30, 0x06ED	; 0x8006ed <pxCurrentTCB>
    181a:	f0 91 ee 06 	lds	r31, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    181e:	9e 89       	ldd	r25, Y+22	; 0x16
    1820:	86 89       	ldd	r24, Z+22	; 0x16
    1822:	98 17       	cp	r25, r24
    1824:	68 f0       	brcs	.+26     	; 0x1840 <xTaskResumeAll+0xa8>
    1826:	d0 92 87 06 	sts	0x0687, r13	; 0x800687 <xYieldPending>
    182a:	0a c0       	rjmp	.+20     	; 0x1840 <xTaskResumeAll+0xa8>
    182c:	c0 e0       	ldi	r28, 0x00	; 0
    182e:	d0 e0       	ldi	r29, 0x00	; 0
    1830:	0f 2e       	mov	r0, r31
    1832:	f1 ea       	ldi	r31, 0xA1	; 161
    1834:	ef 2e       	mov	r14, r31
    1836:	f6 e0       	ldi	r31, 0x06	; 6
    1838:	ff 2e       	mov	r15, r31
    183a:	f0 2d       	mov	r31, r0
    183c:	dd 24       	eor	r13, r13
    183e:	d3 94       	inc	r13
    1840:	f7 01       	movw	r30, r14
    1842:	80 81       	ld	r24, Z
    1844:	81 11       	cpse	r24, r1
    1846:	c0 cf       	rjmp	.-128    	; 0x17c8 <xTaskResumeAll+0x30>
    1848:	cd 2b       	or	r28, r29
    184a:	11 f0       	breq	.+4      	; 0x1850 <xTaskResumeAll+0xb8>
    184c:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <prvResetNextTaskUnblockTime>
    1850:	c0 91 88 06 	lds	r28, 0x0688	; 0x800688 <uxPendedTicks>
    1854:	cc 23       	and	r28, r28
    1856:	51 f0       	breq	.+20     	; 0x186c <xTaskResumeAll+0xd4>
    1858:	d1 e0       	ldi	r29, 0x01	; 1
    185a:	0e 94 2c 0b 	call	0x1658	; 0x1658 <xTaskIncrementTick>
    185e:	81 11       	cpse	r24, r1
    1860:	d0 93 87 06 	sts	0x0687, r29	; 0x800687 <xYieldPending>
    1864:	c1 50       	subi	r28, 0x01	; 1
    1866:	c9 f7       	brne	.-14     	; 0x185a <xTaskResumeAll+0xc2>
    1868:	10 92 88 06 	sts	0x0688, r1	; 0x800688 <uxPendedTicks>
    186c:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <xYieldPending>
    1870:	0f 90       	pop	r0
    1872:	0f be       	out	0x3f, r0	; 63
    1874:	80 e0       	ldi	r24, 0x00	; 0
    1876:	df 91       	pop	r29
    1878:	cf 91       	pop	r28
    187a:	1f 91       	pop	r17
    187c:	0f 91       	pop	r16
    187e:	ff 90       	pop	r15
    1880:	ef 90       	pop	r14
    1882:	df 90       	pop	r13
    1884:	08 95       	ret

00001886 <vTaskDelayUntil>:
    1886:	0f 93       	push	r16
    1888:	1f 93       	push	r17
    188a:	cf 93       	push	r28
    188c:	df 93       	push	r29
    188e:	8c 01       	movw	r16, r24
    1890:	eb 01       	movw	r28, r22
    1892:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vTaskSuspendAll>
    1896:	40 91 8b 06 	lds	r20, 0x068B	; 0x80068b <xTickCount>
    189a:	50 91 8c 06 	lds	r21, 0x068C	; 0x80068c <xTickCount+0x1>
    189e:	f8 01       	movw	r30, r16
    18a0:	20 81       	ld	r18, Z
    18a2:	31 81       	ldd	r19, Z+1	; 0x01
    18a4:	c9 01       	movw	r24, r18
    18a6:	8c 0f       	add	r24, r28
    18a8:	9d 1f       	adc	r25, r29
    18aa:	42 17       	cp	r20, r18
    18ac:	53 07       	cpc	r21, r19
    18ae:	48 f4       	brcc	.+18     	; 0x18c2 <vTaskDelayUntil+0x3c>
    18b0:	82 17       	cp	r24, r18
    18b2:	93 07       	cpc	r25, r19
    18b4:	e8 f4       	brcc	.+58     	; 0x18f0 <vTaskDelayUntil+0x6a>
    18b6:	91 83       	std	Z+1, r25	; 0x01
    18b8:	80 83       	st	Z, r24
    18ba:	48 17       	cp	r20, r24
    18bc:	59 07       	cpc	r21, r25
    18be:	68 f4       	brcc	.+26     	; 0x18da <vTaskDelayUntil+0x54>
    18c0:	07 c0       	rjmp	.+14     	; 0x18d0 <vTaskDelayUntil+0x4a>
    18c2:	82 17       	cp	r24, r18
    18c4:	93 07       	cpc	r25, r19
    18c6:	80 f0       	brcs	.+32     	; 0x18e8 <vTaskDelayUntil+0x62>
    18c8:	48 17       	cp	r20, r24
    18ca:	59 07       	cpc	r21, r25
    18cc:	68 f0       	brcs	.+26     	; 0x18e8 <vTaskDelayUntil+0x62>
    18ce:	10 c0       	rjmp	.+32     	; 0x18f0 <vTaskDelayUntil+0x6a>
    18d0:	60 e0       	ldi	r22, 0x00	; 0
    18d2:	84 1b       	sub	r24, r20
    18d4:	95 0b       	sbc	r25, r21
    18d6:	0e 94 47 09 	call	0x128e	; 0x128e <prvAddCurrentTaskToDelayedList>
    18da:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskResumeAll>
    18de:	81 11       	cpse	r24, r1
    18e0:	0b c0       	rjmp	.+22     	; 0x18f8 <vTaskDelayUntil+0x72>
    18e2:	0e 94 00 06 	call	0xc00	; 0xc00 <vPortYield>
    18e6:	08 c0       	rjmp	.+16     	; 0x18f8 <vTaskDelayUntil+0x72>
    18e8:	f8 01       	movw	r30, r16
    18ea:	91 83       	std	Z+1, r25	; 0x01
    18ec:	80 83       	st	Z, r24
    18ee:	f0 cf       	rjmp	.-32     	; 0x18d0 <vTaskDelayUntil+0x4a>
    18f0:	f8 01       	movw	r30, r16
    18f2:	91 83       	std	Z+1, r25	; 0x01
    18f4:	80 83       	st	Z, r24
    18f6:	f1 cf       	rjmp	.-30     	; 0x18da <vTaskDelayUntil+0x54>
    18f8:	df 91       	pop	r29
    18fa:	cf 91       	pop	r28
    18fc:	1f 91       	pop	r17
    18fe:	0f 91       	pop	r16
    1900:	08 95       	ret

00001902 <vTaskDelay>:
    1902:	cf 93       	push	r28
    1904:	df 93       	push	r29
    1906:	ec 01       	movw	r28, r24
    1908:	89 2b       	or	r24, r25
    190a:	51 f0       	breq	.+20     	; 0x1920 <vTaskDelay+0x1e>
    190c:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vTaskSuspendAll>
    1910:	60 e0       	ldi	r22, 0x00	; 0
    1912:	ce 01       	movw	r24, r28
    1914:	0e 94 47 09 	call	0x128e	; 0x128e <prvAddCurrentTaskToDelayedList>
    1918:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskResumeAll>
    191c:	81 11       	cpse	r24, r1
    191e:	02 c0       	rjmp	.+4      	; 0x1924 <vTaskDelay+0x22>
    1920:	0e 94 00 06 	call	0xc00	; 0xc00 <vPortYield>
    1924:	df 91       	pop	r29
    1926:	cf 91       	pop	r28
    1928:	08 95       	ret

0000192a <vTaskSwitchContext>:
    192a:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <uxSchedulerSuspended>
    192e:	88 23       	and	r24, r24
    1930:	21 f0       	breq	.+8      	; 0x193a <vTaskSwitchContext+0x10>
    1932:	81 e0       	ldi	r24, 0x01	; 1
    1934:	80 93 87 06 	sts	0x0687, r24	; 0x800687 <xYieldPending>
    1938:	08 95       	ret
    193a:	10 92 87 06 	sts	0x0687, r1	; 0x800687 <xYieldPending>
    193e:	20 91 8a 06 	lds	r18, 0x068A	; 0x80068a <uxTopReadyPriority>
    1942:	82 2f       	mov	r24, r18
    1944:	90 e0       	ldi	r25, 0x00	; 0
    1946:	fc 01       	movw	r30, r24
    1948:	ee 0f       	add	r30, r30
    194a:	ff 1f       	adc	r31, r31
    194c:	ee 0f       	add	r30, r30
    194e:	ff 1f       	adc	r31, r31
    1950:	ee 0f       	add	r30, r30
    1952:	ff 1f       	adc	r31, r31
    1954:	e8 0f       	add	r30, r24
    1956:	f9 1f       	adc	r31, r25
    1958:	e0 54       	subi	r30, 0x40	; 64
    195a:	f9 4f       	sbci	r31, 0xF9	; 249
    195c:	30 81       	ld	r19, Z
    195e:	31 11       	cpse	r19, r1
    1960:	11 c0       	rjmp	.+34     	; 0x1984 <vTaskSwitchContext+0x5a>
    1962:	21 50       	subi	r18, 0x01	; 1
    1964:	82 2f       	mov	r24, r18
    1966:	90 e0       	ldi	r25, 0x00	; 0
    1968:	fc 01       	movw	r30, r24
    196a:	ee 0f       	add	r30, r30
    196c:	ff 1f       	adc	r31, r31
    196e:	ee 0f       	add	r30, r30
    1970:	ff 1f       	adc	r31, r31
    1972:	ee 0f       	add	r30, r30
    1974:	ff 1f       	adc	r31, r31
    1976:	e8 0f       	add	r30, r24
    1978:	f9 1f       	adc	r31, r25
    197a:	e0 54       	subi	r30, 0x40	; 64
    197c:	f9 4f       	sbci	r31, 0xF9	; 249
    197e:	30 81       	ld	r19, Z
    1980:	33 23       	and	r19, r19
    1982:	79 f3       	breq	.-34     	; 0x1962 <vTaskSwitchContext+0x38>
    1984:	ac 01       	movw	r20, r24
    1986:	44 0f       	add	r20, r20
    1988:	55 1f       	adc	r21, r21
    198a:	44 0f       	add	r20, r20
    198c:	55 1f       	adc	r21, r21
    198e:	44 0f       	add	r20, r20
    1990:	55 1f       	adc	r21, r21
    1992:	48 0f       	add	r20, r24
    1994:	59 1f       	adc	r21, r25
    1996:	da 01       	movw	r26, r20
    1998:	a0 54       	subi	r26, 0x40	; 64
    199a:	b9 4f       	sbci	r27, 0xF9	; 249
    199c:	11 96       	adiw	r26, 0x01	; 1
    199e:	ed 91       	ld	r30, X+
    19a0:	fc 91       	ld	r31, X
    19a2:	12 97       	sbiw	r26, 0x02	; 2
    19a4:	02 80       	ldd	r0, Z+2	; 0x02
    19a6:	f3 81       	ldd	r31, Z+3	; 0x03
    19a8:	e0 2d       	mov	r30, r0
    19aa:	12 96       	adiw	r26, 0x02	; 2
    19ac:	fc 93       	st	X, r31
    19ae:	ee 93       	st	-X, r30
    19b0:	11 97       	sbiw	r26, 0x01	; 1
    19b2:	4d 53       	subi	r20, 0x3D	; 61
    19b4:	59 4f       	sbci	r21, 0xF9	; 249
    19b6:	e4 17       	cp	r30, r20
    19b8:	f5 07       	cpc	r31, r21
    19ba:	29 f4       	brne	.+10     	; 0x19c6 <vTaskSwitchContext+0x9c>
    19bc:	42 81       	ldd	r20, Z+2	; 0x02
    19be:	53 81       	ldd	r21, Z+3	; 0x03
    19c0:	fd 01       	movw	r30, r26
    19c2:	52 83       	std	Z+2, r21	; 0x02
    19c4:	41 83       	std	Z+1, r20	; 0x01
    19c6:	fc 01       	movw	r30, r24
    19c8:	ee 0f       	add	r30, r30
    19ca:	ff 1f       	adc	r31, r31
    19cc:	ee 0f       	add	r30, r30
    19ce:	ff 1f       	adc	r31, r31
    19d0:	ee 0f       	add	r30, r30
    19d2:	ff 1f       	adc	r31, r31
    19d4:	8e 0f       	add	r24, r30
    19d6:	9f 1f       	adc	r25, r31
    19d8:	fc 01       	movw	r30, r24
    19da:	e0 54       	subi	r30, 0x40	; 64
    19dc:	f9 4f       	sbci	r31, 0xF9	; 249
    19de:	01 80       	ldd	r0, Z+1	; 0x01
    19e0:	f2 81       	ldd	r31, Z+2	; 0x02
    19e2:	e0 2d       	mov	r30, r0
    19e4:	86 81       	ldd	r24, Z+6	; 0x06
    19e6:	97 81       	ldd	r25, Z+7	; 0x07
    19e8:	90 93 ee 06 	sts	0x06EE, r25	; 0x8006ee <pxCurrentTCB+0x1>
    19ec:	80 93 ed 06 	sts	0x06ED, r24	; 0x8006ed <pxCurrentTCB>
    19f0:	20 93 8a 06 	sts	0x068A, r18	; 0x80068a <uxTopReadyPriority>
    19f4:	08 95       	ret

000019f6 <vTaskSuspend>:
    19f6:	0f 93       	push	r16
    19f8:	1f 93       	push	r17
    19fa:	cf 93       	push	r28
    19fc:	df 93       	push	r29
    19fe:	ec 01       	movw	r28, r24
    1a00:	0f b6       	in	r0, 0x3f	; 63
    1a02:	f8 94       	cli
    1a04:	0f 92       	push	r0
    1a06:	89 2b       	or	r24, r25
    1a08:	21 f4       	brne	.+8      	; 0x1a12 <vTaskSuspend+0x1c>
    1a0a:	c0 91 ed 06 	lds	r28, 0x06ED	; 0x8006ed <pxCurrentTCB>
    1a0e:	d0 91 ee 06 	lds	r29, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    1a12:	8e 01       	movw	r16, r28
    1a14:	0e 5f       	subi	r16, 0xFE	; 254
    1a16:	1f 4f       	sbci	r17, 0xFF	; 255
    1a18:	c8 01       	movw	r24, r16
    1a1a:	0e 94 38 05 	call	0xa70	; 0xa70 <uxListRemove>
    1a1e:	8c 89       	ldd	r24, Y+20	; 0x14
    1a20:	9d 89       	ldd	r25, Y+21	; 0x15
    1a22:	89 2b       	or	r24, r25
    1a24:	21 f0       	breq	.+8      	; 0x1a2e <vTaskSuspend+0x38>
    1a26:	ce 01       	movw	r24, r28
    1a28:	0c 96       	adiw	r24, 0x0c	; 12
    1a2a:	0e 94 38 05 	call	0xa70	; 0xa70 <uxListRemove>
    1a2e:	b8 01       	movw	r22, r16
    1a30:	8e e8       	ldi	r24, 0x8E	; 142
    1a32:	96 e0       	ldi	r25, 0x06	; 6
    1a34:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
    1a38:	8d a1       	ldd	r24, Y+37	; 0x25
    1a3a:	81 30       	cpi	r24, 0x01	; 1
    1a3c:	09 f4       	brne	.+2      	; 0x1a40 <vTaskSuspend+0x4a>
    1a3e:	1d a2       	std	Y+37, r1	; 0x25
    1a40:	0f 90       	pop	r0
    1a42:	0f be       	out	0x3f, r0	; 63
    1a44:	80 91 89 06 	lds	r24, 0x0689	; 0x800689 <xSchedulerRunning>
    1a48:	88 23       	and	r24, r24
    1a4a:	39 f0       	breq	.+14     	; 0x1a5a <vTaskSuspend+0x64>
    1a4c:	0f b6       	in	r0, 0x3f	; 63
    1a4e:	f8 94       	cli
    1a50:	0f 92       	push	r0
    1a52:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <prvResetNextTaskUnblockTime>
    1a56:	0f 90       	pop	r0
    1a58:	0f be       	out	0x3f, r0	; 63
    1a5a:	80 91 ed 06 	lds	r24, 0x06ED	; 0x8006ed <pxCurrentTCB>
    1a5e:	90 91 ee 06 	lds	r25, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    1a62:	c8 17       	cp	r28, r24
    1a64:	d9 07       	cpc	r29, r25
    1a66:	a1 f4       	brne	.+40     	; 0x1a90 <vTaskSuspend+0x9a>
    1a68:	80 91 89 06 	lds	r24, 0x0689	; 0x800689 <xSchedulerRunning>
    1a6c:	88 23       	and	r24, r24
    1a6e:	19 f0       	breq	.+6      	; 0x1a76 <vTaskSuspend+0x80>
    1a70:	0e 94 00 06 	call	0xc00	; 0xc00 <vPortYield>
    1a74:	0d c0       	rjmp	.+26     	; 0x1a90 <vTaskSuspend+0x9a>
    1a76:	90 91 8e 06 	lds	r25, 0x068E	; 0x80068e <xSuspendedTaskList>
    1a7a:	80 91 8d 06 	lds	r24, 0x068D	; 0x80068d <uxCurrentNumberOfTasks>
    1a7e:	98 13       	cpse	r25, r24
    1a80:	05 c0       	rjmp	.+10     	; 0x1a8c <vTaskSuspend+0x96>
    1a82:	10 92 ee 06 	sts	0x06EE, r1	; 0x8006ee <pxCurrentTCB+0x1>
    1a86:	10 92 ed 06 	sts	0x06ED, r1	; 0x8006ed <pxCurrentTCB>
    1a8a:	02 c0       	rjmp	.+4      	; 0x1a90 <vTaskSuspend+0x9a>
    1a8c:	0e 94 95 0c 	call	0x192a	; 0x192a <vTaskSwitchContext>
    1a90:	df 91       	pop	r29
    1a92:	cf 91       	pop	r28
    1a94:	1f 91       	pop	r17
    1a96:	0f 91       	pop	r16
    1a98:	08 95       	ret

00001a9a <vTaskPlaceOnEventList>:
    1a9a:	cf 93       	push	r28
    1a9c:	df 93       	push	r29
    1a9e:	eb 01       	movw	r28, r22
    1aa0:	60 91 ed 06 	lds	r22, 0x06ED	; 0x8006ed <pxCurrentTCB>
    1aa4:	70 91 ee 06 	lds	r23, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    1aa8:	64 5f       	subi	r22, 0xF4	; 244
    1aaa:	7f 4f       	sbci	r23, 0xFF	; 255
    1aac:	0e 94 07 05 	call	0xa0e	; 0xa0e <vListInsert>
    1ab0:	61 e0       	ldi	r22, 0x01	; 1
    1ab2:	ce 01       	movw	r24, r28
    1ab4:	0e 94 47 09 	call	0x128e	; 0x128e <prvAddCurrentTaskToDelayedList>
    1ab8:	df 91       	pop	r29
    1aba:	cf 91       	pop	r28
    1abc:	08 95       	ret

00001abe <xTaskRemoveFromEventList>:
    1abe:	0f 93       	push	r16
    1ac0:	1f 93       	push	r17
    1ac2:	cf 93       	push	r28
    1ac4:	df 93       	push	r29
    1ac6:	dc 01       	movw	r26, r24
    1ac8:	15 96       	adiw	r26, 0x05	; 5
    1aca:	ed 91       	ld	r30, X+
    1acc:	fc 91       	ld	r31, X
    1ace:	16 97       	sbiw	r26, 0x06	; 6
    1ad0:	c6 81       	ldd	r28, Z+6	; 0x06
    1ad2:	d7 81       	ldd	r29, Z+7	; 0x07
    1ad4:	8e 01       	movw	r16, r28
    1ad6:	04 5f       	subi	r16, 0xF4	; 244
    1ad8:	1f 4f       	sbci	r17, 0xFF	; 255
    1ada:	c8 01       	movw	r24, r16
    1adc:	0e 94 38 05 	call	0xa70	; 0xa70 <uxListRemove>
    1ae0:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <uxSchedulerSuspended>
    1ae4:	81 11       	cpse	r24, r1
    1ae6:	1c c0       	rjmp	.+56     	; 0x1b20 <xTaskRemoveFromEventList+0x62>
    1ae8:	0a 50       	subi	r16, 0x0A	; 10
    1aea:	11 09       	sbc	r17, r1
    1aec:	c8 01       	movw	r24, r16
    1aee:	0e 94 38 05 	call	0xa70	; 0xa70 <uxListRemove>
    1af2:	8e 89       	ldd	r24, Y+22	; 0x16
    1af4:	90 91 8a 06 	lds	r25, 0x068A	; 0x80068a <uxTopReadyPriority>
    1af8:	98 17       	cp	r25, r24
    1afa:	10 f4       	brcc	.+4      	; 0x1b00 <xTaskRemoveFromEventList+0x42>
    1afc:	80 93 8a 06 	sts	0x068A, r24	; 0x80068a <uxTopReadyPriority>
    1b00:	90 e0       	ldi	r25, 0x00	; 0
    1b02:	9c 01       	movw	r18, r24
    1b04:	22 0f       	add	r18, r18
    1b06:	33 1f       	adc	r19, r19
    1b08:	22 0f       	add	r18, r18
    1b0a:	33 1f       	adc	r19, r19
    1b0c:	22 0f       	add	r18, r18
    1b0e:	33 1f       	adc	r19, r19
    1b10:	82 0f       	add	r24, r18
    1b12:	93 1f       	adc	r25, r19
    1b14:	b8 01       	movw	r22, r16
    1b16:	80 54       	subi	r24, 0x40	; 64
    1b18:	99 4f       	sbci	r25, 0xF9	; 249
    1b1a:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
    1b1e:	05 c0       	rjmp	.+10     	; 0x1b2a <xTaskRemoveFromEventList+0x6c>
    1b20:	b8 01       	movw	r22, r16
    1b22:	81 ea       	ldi	r24, 0xA1	; 161
    1b24:	96 e0       	ldi	r25, 0x06	; 6
    1b26:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
    1b2a:	e0 91 ed 06 	lds	r30, 0x06ED	; 0x8006ed <pxCurrentTCB>
    1b2e:	f0 91 ee 06 	lds	r31, 0x06EE	; 0x8006ee <pxCurrentTCB+0x1>
    1b32:	9e 89       	ldd	r25, Y+22	; 0x16
    1b34:	86 89       	ldd	r24, Z+22	; 0x16
    1b36:	89 17       	cp	r24, r25
    1b38:	20 f4       	brcc	.+8      	; 0x1b42 <xTaskRemoveFromEventList+0x84>
    1b3a:	81 e0       	ldi	r24, 0x01	; 1
    1b3c:	80 93 87 06 	sts	0x0687, r24	; 0x800687 <xYieldPending>
    1b40:	01 c0       	rjmp	.+2      	; 0x1b44 <xTaskRemoveFromEventList+0x86>
    1b42:	80 e0       	ldi	r24, 0x00	; 0
    1b44:	df 91       	pop	r29
    1b46:	cf 91       	pop	r28
    1b48:	1f 91       	pop	r17
    1b4a:	0f 91       	pop	r16
    1b4c:	08 95       	ret

00001b4e <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1b4e:	20 91 86 06 	lds	r18, 0x0686	; 0x800686 <xNumOfOverflows>
    1b52:	fc 01       	movw	r30, r24
    1b54:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1b56:	20 91 8b 06 	lds	r18, 0x068B	; 0x80068b <xTickCount>
    1b5a:	30 91 8c 06 	lds	r19, 0x068C	; 0x80068c <xTickCount+0x1>
    1b5e:	32 83       	std	Z+2, r19	; 0x02
    1b60:	21 83       	std	Z+1, r18	; 0x01
    1b62:	08 95       	ret

00001b64 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1b64:	cf 93       	push	r28
    1b66:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1b68:	0f b6       	in	r0, 0x3f	; 63
    1b6a:	f8 94       	cli
    1b6c:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1b6e:	20 91 8b 06 	lds	r18, 0x068B	; 0x80068b <xTickCount>
    1b72:	30 91 8c 06 	lds	r19, 0x068C	; 0x80068c <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    1b76:	db 01       	movw	r26, r22
    1b78:	4d 91       	ld	r20, X+
    1b7a:	5c 91       	ld	r21, X
    1b7c:	4f 3f       	cpi	r20, 0xFF	; 255
    1b7e:	bf ef       	ldi	r27, 0xFF	; 255
    1b80:	5b 07       	cpc	r21, r27
    1b82:	f1 f0       	breq	.+60     	; 0x1bc0 <xTaskCheckForTimeOut+0x5c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1b84:	ec 01       	movw	r28, r24
    1b86:	e9 81       	ldd	r30, Y+1	; 0x01
    1b88:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1b8a:	a0 91 86 06 	lds	r26, 0x0686	; 0x800686 <xNumOfOverflows>
    1b8e:	b8 81       	ld	r27, Y
    1b90:	ba 17       	cp	r27, r26
    1b92:	19 f0       	breq	.+6      	; 0x1b9a <xTaskCheckForTimeOut+0x36>
    1b94:	2e 17       	cp	r18, r30
    1b96:	3f 07       	cpc	r19, r31
    1b98:	a8 f4       	brcc	.+42     	; 0x1bc4 <xTaskCheckForTimeOut+0x60>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1b9a:	2e 1b       	sub	r18, r30
    1b9c:	3f 0b       	sbc	r19, r31
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1b9e:	24 17       	cp	r18, r20
    1ba0:	35 07       	cpc	r19, r21
    1ba2:	48 f4       	brcc	.+18     	; 0x1bb6 <xTaskCheckForTimeOut+0x52>
    1ba4:	fb 01       	movw	r30, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    1ba6:	42 1b       	sub	r20, r18
    1ba8:	53 0b       	sbc	r21, r19
    1baa:	51 83       	std	Z+1, r21	; 0x01
    1bac:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    1bae:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    1bb2:	80 e0       	ldi	r24, 0x00	; 0
    1bb4:	08 c0       	rjmp	.+16     	; 0x1bc6 <xTaskCheckForTimeOut+0x62>
		}
		else
		{
			*pxTicksToWait = 0;
    1bb6:	fb 01       	movw	r30, r22
    1bb8:	11 82       	std	Z+1, r1	; 0x01
    1bba:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    1bbc:	81 e0       	ldi	r24, 0x01	; 1
    1bbe:	03 c0       	rjmp	.+6      	; 0x1bc6 <xTaskCheckForTimeOut+0x62>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    1bc0:	80 e0       	ldi	r24, 0x00	; 0
    1bc2:	01 c0       	rjmp	.+2      	; 0x1bc6 <xTaskCheckForTimeOut+0x62>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1bc4:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1bc6:	0f 90       	pop	r0
    1bc8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1bca:	df 91       	pop	r29
    1bcc:	cf 91       	pop	r28
    1bce:	08 95       	ret

00001bd0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1bd0:	81 e0       	ldi	r24, 0x01	; 1
    1bd2:	80 93 87 06 	sts	0x0687, r24	; 0x800687 <xYieldPending>
    1bd6:	08 95       	ret

00001bd8 <memcpy>:
    1bd8:	fb 01       	movw	r30, r22
    1bda:	dc 01       	movw	r26, r24
    1bdc:	02 c0       	rjmp	.+4      	; 0x1be2 <memcpy+0xa>
    1bde:	01 90       	ld	r0, Z+
    1be0:	0d 92       	st	X+, r0
    1be2:	41 50       	subi	r20, 0x01	; 1
    1be4:	50 40       	sbci	r21, 0x00	; 0
    1be6:	d8 f7       	brcc	.-10     	; 0x1bde <memcpy+0x6>
    1be8:	08 95       	ret

00001bea <_exit>:
    1bea:	f8 94       	cli

00001bec <__stop_program>:
    1bec:	ff cf       	rjmp	.-2      	; 0x1bec <__stop_program>
